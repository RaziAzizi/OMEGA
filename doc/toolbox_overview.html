<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB R2019a"><title>Toolbox overview</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin-bottom: 20px; padding-bottom: 4px;  }
.S1 { margin: 0px; padding: 10px 0px 10px 5px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: bold; text-align: start;  }
.S2 { margin: -1px 0px 0px; padding: 10px 0px 10px 7px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: start;  }
.S3 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 28.7999992370605px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: normal; text-align: left;  }
.S4 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }
.S5 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: bold; text-align: left;  }
.S6 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: bold; text-align: left;  }
.S7 { margin: 10px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 15px; font-weight: bold; text-align: left;  }</style></head><body><div class = rtcContent><div  class = 'S0'><div  class = 'S1'><span style=' font-weight: bold;'>Table of Contents</span></div><div  class = 'S2'><a href = "#T_9EFF09D6"><span>Toolbox overview
</span></a><a href = "#T_F47C0745"><span>Technical aspects
</span></a><span>    </span><a href = "#H_74568ADF"><span>Precomputation phase
</span></a><span>        </span><a href = "#H_FDF0E3F0"><span>Purpose
</span></a><span>        </span><a href = "#H_4BCC0F5C"><span>Execution
</span></a><span>    </span><a href = "#H_38F2AC36"><span>Data load
</span></a><span>        </span><a href = "#H_F6E40497"><span>Execution
</span></a><span>            </span><a href = "#H_69B0B6FE"><span>GATE data
</span></a><span>            </span><a href = "#H_FE914EAB"><span>List-mode data
</span></a><span>            </span><a href = "#H_CAE4E540"><span>Sinogram data
</span></a><span>            </span><a href = "#H_131A1AF5"><span>Saving data
</span></a><span>    </span><a href = "#H_D4DB89E0"><span>Forming sinograms
</span></a><span>        </span><a href = "#H_B329B65A"><span>Execution
</span></a><span>    </span><a href = "#H_D6F563B8"><span>Attenuation correction
</span></a><span>    </span><a href = "#H_F10748A4"><span>Normalization correction
</span></a><span>    </span><a href = "#H_EFCD8B9D"><span>Image reconstruction
</span></a><span>        </span><a href = "#H_47E27734"><span>Implementation 1
</span></a><span>        </span><a href = "#H_7ED6A9CF"><span>Implementation 2 
</span></a><span>        </span><a href = "#H_A439C981"><span>Implementation 3 
</span></a><span>        </span><a href = "#H_496A0902"><span>Implementation 4 
</span></a><span>        </span><a href = "#H_59DEC0EF"><span>Matrix-free formulation 
</span></a><span>        </span><a href = "#H_24EBB306"><span>TOF coefficients</span></a></div></div><h1  class = 'S3' id = 'T_9EFF09D6' ><span>Toolbox overview</span></h1><div  class = 'S4'><span>The general structure of OMEGA can be divided into three different layers. The top layer is the MATLAB/Octave user-interface that contains the scripts and functions necessary to call the lower layers. The middle layer is the MATLAB (C) MEX-interface that calls and computes the C++ code and then sends it back to the top layer. The bottom layer, which is not always used, contains the OpenCL kernels that compute the OpenCL code and then send the output data (reconstructed images) to the middle layer. The bottom layer is only used if OpenCL code is used. The middle layer can also be ignored, but this is not recommended and not enabled by default as the pure MATLAB/Octave implementation is extremely slow.</span></div><div  class = 'S4'><span>For the user, only the top layer is exposed. This is achieved in the form of scripts that are referred to as </span><span style=' font-style: italic;'>main-files</span><span>. These include </span><span style=' font-family: monospace;'>gate_main.m</span><span>, </span><span style=' font-family: monospace;'>main_PET.m</span><span>, </span><span style=' font-family: monospace;'>Inveon_PET_main.m</span><span>, </span><span style=' font-family: monospace;'>Biograph_mCT_main.m</span><span>, </span><span style=' font-family: monospace;'>Biograph_Vision_main.m</span><span>, </span><span style=' font-family: monospace;'>custom_prior_test_main.m</span><span>, and </span><span style=' font-family: monospace;'>forward_backward_projections_example.m</span><span>. It is from these main-files that the actual functions are called. This is achieved by storing all the user selected parameters to a MATLAB/Octave struct called options, which is then input to the functions (e.g. when loading data or performing image reconstruction). </span></div><div  class = 'S4'><span>In the main-files most parameters are set either with numerical values (e.g. </span><span style=' font-family: monospace;'>blocks_per_ring</span><span>, </span><span style=' font-family: monospace;'>span</span><span>, </span><span style=' font-family: monospace;'>tube_radius</span><span>) or as a true/false selection, where true means that the feature is included and false that it is omitted (e.g. </span><span style=' font-family: monospace;'>randoms_correction</span><span>, </span><span style=' font-family: monospace;'>scatter_smoothing</span><span>, </span><span style=' font-family: monospace;'>osem</span><span>). The main-files are divided into "sections" with specific labels (MACHINE PROPERTIES, IMAGE PROPERTIES, SINOGRAM PROPERTIES, etc.) that control different aspects. Many of these sections are completely optional, e.g. CORRECTIONS section can be omitted if the user does not wish to use any corrections. The only compulsory ones are MACHINE PROPERTIES and either SINOGRAM or RAW DATA PROPERTIES. For reconstruction it is also advisable to inspect the RECONSTRUCTION PROPERTIES section, but the default values should always output a working OSEM estimate. By default all non-compulsory options are set as false (with the exception of the Inveon main-file which has several corrections enabled by default).</span></div><div  class = 'S4'><span>There are also several functions that work very independently without the need for the main-files. These include file import and export functions, visualization functions and many reconstruction algorithm functions. For help on many of these functions, you should use </span><span style=' font-family: monospace;'>help function_name</span><span> or alternatively </span><span style=' font-family: monospace;'>doc function_name</span><span>. E.g. </span><span style=' font-family: monospace;'>help saveImage</span><span>.</span></div><h1  class = 'S3' id = 'T_F47C0745' ><span>Technical aspects</span></h1><div  class = 'S4'><span>This section explains how, exactly, does each component of OMEGA software work.</span></div><h2  class = 'S5' id = 'H_74568ADF' ><span>Precomputation phase</span></h2><div  class = 'S4'><span>The corresponding m-file is </span><span style=' font-family: monospace;'>lor_pixel_count_prepass.m</span><span>.</span></div><h3  class = 'S6' id = 'H_FDF0E3F0' ><span>Purpose</span></h3><div  class = 'S4'><span>As mentioned in other help pages, the goal of the precomputation phase is to determine the number of voxels that each line of response traverses (interacts with). Line of responses that do not intersect the FOV at all will have 0 interacted voxels and as such can be safely removed. This step is also necessary for the parallel version of implementation 1 as it requires the preallocation of the system matrix in memory. This also means that, unlike with matrix free implementations, the orthogonal and volume of intersection ray tracers require their own precomputation passes since the number of voxels that are interacted with is much higher.</span></div><h3  class = 'S6' id = 'H_4BCC0F5C' ><span>Execution</span></h3><div  class = 'S4'><span>Dedicated codes are available for the precomputation phase. Furthermore, since the OpenCL implementations use single (32-bit float) precision numbers and the C++ versions double (64-bit double) precision numbers, different versions are available for both. This is because of floating-point rounding effects that can cause LORs that are on the very edge of a voxel to be in different voxels depending on whether the single or double precision implementations are used. While this usually affects only a very small portion of all the LORs, even a single wrong one can cause a crash due to out-of-bounds variables. Implementation 2 also has its own precomputation code, although the OpenCL kernel itself is identical to implementation 3. This is simply because of the different device/platform executions.</span></div><div  class = 'S4'><span>The codes themselves are stripped versions of the actual projectors. In all cases, the ray tracing itself is always performed, no parameters outside of the ones necessary for the ray tracing are computed. For C++ version, there is a different file/function for this (</span><span style=' font-family: monospace;'>improved_Siddon_algorithm_discard.cpp</span><span>), but for OpenCL versions all the code are in "master" kernel file (</span><span style=' font-family: monospace;'>multidevice_kernel.cl</span><span>) where the correct lines are compiled during runtime by taking advantage of preprocessor directives (</span><span style=' font-family: monospace;'>#ifdef</span><span>, </span><span style=' font-family: monospace;'>#else</span><span>, etc.). For precomputation phase, the preprocessor directive that is defined is </span><span style=' font-family: monospace;'>FINDLORS</span><span>. No precomputation code is available for CUDA.</span></div><h2  class = 'S5' id = 'H_38F2AC36' ><span>Data load</span></h2><div  class = 'S4'><span>The corresponding m-files are </span><span style=' font-family: monospace;'>load_data.m</span><span>, </span><span style=' font-family: monospace;'>load_data_mCT.m</span><span> and </span><span style=' font-family: monospace;'>load_data_Vision.m</span><span>.</span></div><h3  class = 'S6' id = 'H_F6E40497' ><span>Execution</span></h3><div  class = 'S4'><span>Data load is divided into three different sections: GATE data, list-mode data and sinogram data.</span></div><h4  class = 'S7' id = 'H_69B0B6FE' ><span>GATE data</span></h4><div  class = 'S4'><span>For GATE data, the data import is separate for LMF, ASCII and ROOT. </span></div><div  class = 'S4'><span>In LMF, the data import is done in a C++ file (</span><span style=' font-family: monospace;'>gate_lmf_matlab.cpp</span><span>) and each binary packet is read sequentially. In LMF, unlike other methods, the coincidences are formed manually from the singles. This is done by first checking if the time difference between the consecutive singles is within the coincidence window length. If yes, then the singles are assumed to be coincidences and all the specified values (e.g. detector number, whether the coincidence is true, random or scattered event, source coordinates) are saved. If not, then the first single is discarded and the latter single becomes the first single and compared with the next single, etc. For time steps, there is first a check on whether the current time is larger than the time of the next time step. If yes, then the current event index is stored. This index indicates where the time was large enough for the next time step to begin and is then used to separate the measurement data into the time bins. Of all the three data types, LMF is the most limited one as it does not support delayed coincidences or scattered events except for Compton scatter in phantom.</span></div><div  class = 'S4'><span>ASCII data import is different from both LMF and ROOT in sense that it is done purely in MATLAB/Octave. It uses either readmatrix (if available) or importdata to import the ASCII text into a matrix containing all the rows and columns. If any of the columns on any of the rows is corrupted/missing (replaced by NaN value), the code will detect these, discard them and inform the line number where this occurred. All the chosen variables are then stored in individual vectors/matrices. Time steps are handled similarly to LMF.</span></div><div  class = 'S4'><span>ROOT data import is handled in a C++ MEX-file. Unlike LMF, ROOT has three different MEX-versions. One uses the "traditional" C MEX-interface (</span><span style=' font-family: monospace;'>GATE_root_matlab_C.cpp</span><span>) and is intended for MATLAB version 2018b and earlier, the second uses the new C++ MEX-interface (</span><span style=' font-family: monospace;'>GATE_root_matlab.cpp</span><span>) and is for MATLAB 2019a and newer and lastly there is a dedicated version for Octave as well (</span><span style=' font-family: monospace;'>GATE_root_matlab_oct.cpp</span><span>). All the ROOT import functions first open the trees (coincidences and delays if selected) and then the desired branches. There are also checks in place that first guarantee that a specific branch is available, e.g. the scatter data. If not a message is displayed, but the data load will still continue, unless it is the detector information that is missing as it is vital for the data load.</span></div><h4  class = 'S7' id = 'H_FE914EAB' ><span>List-mode data</span></h4><div  class = 'S4'><span>List-mode data, more specifically Siemens Inveon, Biograph mCT and Biograph Vision list-mode data, is loaded in a separate MEX-file. For Inveon, the source code is available (</span><span style=' font-family: monospace;'>inveon_list2matlab.cpp</span><span>), but for mCT and Vision only the MEX-files themselves are distributed (i.e. a closed source release). For Inveon, the code loops through all the bit-packets, determines whether they are prompt, delay or time tags and then extracts the corresponding information. Static and dynamic cases are handled a bit differently; in the former case the counts are stored in one detectors x detectors sized matrix, while in the latter they are stored event-by-event basis. In dynamic case, however, the events are stored in a same type of (sparse) matrix as in static case for each time step with the use of accumarray function. Time steps are handled as with LMF data, where the index is stored where the time exceeded the previous time step.</span></div><div  class = 'S4'><span>List-mode data is saved with </span><span style=' font-family: monospace;'>listmode</span><span> in the end of the filename. For 32-bit list-mode data (mCT only) </span><span style=' font-family: monospace;'>listmode_sinogram</span><span> is added to the end of the filename.</span></div><h4  class = 'S7' id = 'H_CAE4E540' ><span>Sinogram data</span></h4><div  class = 'S4'><span>This applies only to Biograph mCT and Vision. For Inveon, the sinogram data load occurs in </span><span style=' font-family: monospace;'>form_sinograms.m</span><span>. Uncompressed mCT and Vision sinograms (.s or .ptd files) can be loaded. Corrections can be applied normally. The data itself is saved with machinesinogram in the end of the filename. </span></div><div  class = 'S4'><span>TOF data can be loaded from mCT and Vision, but currently ONLY with the default number of bins (and bin width).</span></div><h4  class = 'S7' id = 'H_131A1AF5' ><span>Saving data</span></h4><div  class = 'S4'><span>GATE data and list-mode data go through the same procedures when saving data. All steps are repeated for the selected number of time steps, where first the sinogram is created (if raw data is not explicitly used) and then the raw data is stored (if selected). For GATE data, trues, randoms and scatter are stored as well if selected. TOF data will have different filenames from non-TOF data, though raw data does not currently support TOF data.</span></div><h2  class = 'S5' id = 'H_D4DB89E0' ><span>Forming sinograms</span></h2><div  class = 'S4'><span>The corresponding m-file is </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/form_sinograms.m"><span>form_sinograms.m</span></a><span>. Currently, when data is loaded from GATE or list-mode data the sinograms are created through separate MEX-file or OCT-file. </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/createSinogramASCII.cpp"><span>createSinogramASCII.cpp</span></a><span> is for the old C-API, </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/createSinogramASCIICPP.cpp"><span>createSinogramASCIICPP.cpp</span></a><span> is for the C++-API and </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/createSinogramASCIIOct.cpp"><span>createSinogramASCIIOct.cpp</span></a><span> is for Octave.</span></div><h3  class = 'S6' id = 'H_B329B65A' ><span>Execution</span></h3><div  class = 'S4'><span>Sinograms can be formed from saved raw data, during data load (no need to load the raw data separately) and also by simply modifying the corrections applied to the sinogram (e.g. no actual new sinogram is created). When sinograms are formed, a raw uncorrected sinogram is always created and saved regardless of the corrections applied. This is saved as </span><span style=' font-family: monospace;'>rawSinM</span><span>.</span></div><div  class = 'S4'><span>As mentioned above, the sinograms can be either created from the raw data afterwards or during the data load itself. The latter method is faster and more memory efficient. However, it can be useful to create a sinogram of different size later from the same data. In this case, if the data load takes a long time, it is probably beneficial to create a new sinogram from the raw data. This, however, only works if raw data was initially saved (</span><span style=' font-family: monospace;'>options.storerawdata = true</span><span>).</span></div><div  class = 'S4'><span style=' font-weight: bold;'>formsinograms.m:</span></div><div  class = 'S4'><span>When creating sinogram from raw data the first step is the formation of an "initial Michelogram". This is an intermediate step between the raw data format and the Michelogram/sinogram format. The raw data is divided into vectors that contain the future Michelogram bins. This is performed in </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/initial_michelogram.m"><span>initial_michelogram.m</span></a><span>.</span></div><div  class = 'S4'><span>Next step is the formation of the Michelograms by selecting the data points that are within the predetermined orthogonal distance from the center of the field-of-view. These are saved as unsigned 16-bit integers and performed for all the selected data types (trues, prompts, delays, etc.).</span></div><div  class = 'S4'><span>After this, the next step performs the axial compression, though using span of 1 (no axial compression) is also possible. However, span of 1 is only supported with prompts. </span></div><div  class = 'S4'><span style=' font-weight: bold;'>MEX/OCT:</span></div><div  class = 'S4'><span>When the sinograms are created with the MEX/OCT-file, a separate function computes the sinogram indices based on each ring number (axial position) and ring position (transaxial position).</span></div><div  class = 'S4'><span style=' font-weight: bold;'>Corrections:</span></div><div  class = 'S4'><span>The last step, corrections, is applied whether the sinogram was created from raw data or during data load. However, most corrections are not applied if </span><span style=' font-family: monospace;'>options.corrections_during_reconstruction = false</span><span>, with the exception of sinogram gap filling. Corrections are handled in the following order: Randoms (variance reduction, then smoothing) -&gt; Scatter without normalization (variance reduction, then smoothing) -&gt; normalization correction -&gt; Scatter when using normalized scatter (variance reduction, then smoothing) -&gt; global correction factor -&gt; Sinogram gap filling. If any of the corrections are set as false, then that step is omitted. Only prompts go through corrections. Scatter can be applied only with normalization separately applied to it or without separate normalization.</span></div><div  class = 'S4'><span>All the separate sinograms are saved in a same mat-file with the sinogram dimensions in the name. Included are also structs that contain whether certain corrections were applied (</span><span style=' font-family: monospace;'>appliedCorrections</span><span>) and what corrections were applied to scatter or randoms (</span><span style=' font-family: monospace;'>ScatterProp</span><span>, </span><span style=' font-family: monospace;'>RandomsProp</span><span>). In </span><span style=' font-family: monospace;'>appliedCorrections</span><span> normalization is stored as a boolean variable (false means no normalization), randoms and scatter as char (empty array means no corrections, otherwise they can be e.g. "randoms correction with smoothing"), gap filling as boolean, mashing factor as an integer and lastly the user specified global correction factor. The prop-structs contain booleans indicating whether variance reduction and/or smoothing was applied.</span></div><div  class = 'S4'><span>Randoms correction is applied as randoms subtraction from the delayed coincidences data. Scatter correction can be applied either as a subtraction by setting </span><span style=' font-family: monospace;'>options.subtractscatter = true</span><span>, or alternatively by multiplication. In the latter case the scatter data is multiplied with the sinogram. Same steps are repeated for all time steps.</span></div><div  class = 'S4'><span>When the function is used to modify the applied corrections (e.g. </span><span style=' font-family: monospace;'>form_sinograms(options, true)</span><span>), the sinogram creation step is skipped and the uncorrected sinogram is loaded. By default, formsinograms assumes that the sinogram needs to be created, i.e. the boolean value after options needs to be true in order to perform only corrections. Any sinogram, no matter where created, can be corrected like this. However, the data needs to saved as rawSinM in a mat-file with the same name as the current machine properties (e.g. for non-TOF case </span><span style=' font-family: monospace;'>[options.machine_name '_' options.name '_sinograms_combined_static_' num2str(options.Ndist) 'x' num2str(options.Nang) 'x' num2str(options.TotSinos) '_span' num2str(options.span) '.mat']</span><span> for static data and </span><span style=' font-family: monospace;'>[options.machine_name '_' options.name '_sinograms_combined_' num2str(options.partitions) 'timepoints_for_total_of ' num2str(options.tot_time) 's_' num2str(options.Ndist) 'x' num2str(options.Nang) 'x' num2str(options.TotSinos) '_span' num2str(options.span) '.mat']</span><span> for dynamic).</span></div><div  class = 'S4'><span style=' font-weight: bold;'>Saving:</span></div><div  class = 'S4'><span>In the bottom of the m-file, there is a separate section for loading Inveon Acquisition Workplace created sinograms. These sinograms automatically have randoms corrections applied. All other corrections can be applied just as with raw data. Dynamic data is also supported, but the number of time steps have to be equal to the original data.</span></div><div  class = 'S4'><span>The output of formsinograms can consist of the uncorrected sinogram, corrected sinogram, corrected delayed sinogram, uncorrected delayed sinogram as well as sinograms of trues, scatter and randoms. The first input is either the corrected sinogram (if corrections were applied) or the uncorrected sinogram (no corrections).</span></div><h2  class = 'S5' id = 'H_D6F563B8' ><span>Attenuation correction</span></h2><div  class = 'S4'><span>This section applies only to Inveon, mCT and Vision.</span></div><div  class = 'S4'><span style=' font-weight: bold;'>Inveon</span></div><div  class = 'S4'><span>For Inveon two different attenuation correction types are available. The first is based on the blank and transmission scans while the other is CT-based. Both are controlled by </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/attenuation_correction_factors.m"><span>attenuation_correction_factors.m</span></a><span>. For the blank and transmission case the .atn-file provided by the Inveon Acquisition workplace is needed. This is reconstructed into an attenuation image by the aforementioned function. All the reconstruction parameters have been pre-set. Implementation 4 with PSF is always used for the reconstruction. In the CT-case the umap-file contains ready-made attenuation images that are simply loaded and rotated. It is assumed that the bed is always at the lower part of the image. For the .atn-case the attenuation values are also scaled with </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/attenuation122_to_511.m"><span>attenuation122_to_511.m</span></a><span>.</span></div><div  class = 'S4'><span>The scaling scales the 122 keV attenuation coefficients (blank and transmission scan) to 511 keV. First the tabulated values for various tissues and elements for both 122 and 511 keV cases are computed. The input values are then scaled such that the peak is at the soft tissue level (ignore air). Air is given small values. The values are interpolated to densities and then interpolated again by using these densities to 511 keV attenuation coefficients.</span></div><div  class = 'S4'><span style=' font-weight: bold;'>mCT and Vision</span></div><div  class = 'S4'><span>mCT and Vision attenuation correction uses CT-based attenuation correction. The attenuation images for PET are computed with </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/create_atten_matrix_CT.m"><span>create_atten_matrix_CT.m</span></a><span> and </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/attenuationCT_to_511.m"><span>attenuationCT_to_511.m</span></a><span>. The CT images are first scaled to 511 keV by using trilinear interpolation.</span></div><h2  class = 'S5' id = 'H_F10748A4' ><span>Normalization correction</span></h2><div  class = 'S4'><span>Normalization coefficients are computed by </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/normalization_coefficients.m"><span>normalization_coefficients.m</span></a><span>.</span></div><h2  class = 'S5' id = 'H_EFCD8B9D' ><span>Image reconstruction</span></h2><div  class = 'S4'><span>The image reconstruction phase has been divided into four separate types that are referred as implementations. Along with these four implementations, each implementation has two different modes of working, one with a precomputation phase and one without. When the precomputation option is selected, a separate phase needs to be completed before the image reconstruction which determines the valid LORs, i.e. LORs that intersect the FOV (see above). This phase determines the indices of those LORs that intersect the FOV and also determines the number of voxels each of these valid LORs traverse (required for implementation 1). While sinogram data may not have any non-valid LORs, raw data often has significant amount of them. As such, the precomputation phase should increase the speed of the reconstruction phase as non-valid LORs are never investigated. This should make even cases with no non-valid LORs slightly faster due to lack of LOR validation, but the effect is greater with raw data. However, due to ﬂoating point rounding eﬀects the precomputation phase needs to be different when computing either implementation 1 or 4 (CPU) or 2 or 3 (OpenCL) as the ﬁrst two are computed in double precision (64-bit) while the last two are in single precision (32-bit).</span></div><div  class = 'S4'><span>All four implementations are explained here separately in the following sections. The matrix-free formulation is explained in more detail after the implementations have been presented.</span></div><h3  class = 'S6' id = 'H_47E27734' ><span>Implementation 1</span></h3><div  class = 'S4'><span>Implementation 1 solves the image reconstruction problem in matrix form and as such the system matrix is created as whole for each subset or, in</span></div><div  class = 'S4'><span>case of MLEM, the entire matrix in one go. Due to this the memory requirements are high despite the system matrix being stored in sparse format; size of the full system matrix can exceed even hundreds of gigabytes. This is partially caused by MATLAB/Octave always storing sparse matrices in double precision format with 64-bit integer indices in 64-bit systems although single precision and 32-bit integers would be enough. Using the orthogonal (ODRT) or volume-based (VRT) ray tracers even more emphasizes this as the system matrix grows even larger, making even subset-based reconstruction very memory intensive. </span></div><div  class = 'S4'><span>As previously mentioned, two different versions of each implementation is available. For this case the one without a precomputation phase is the only non-parallel version due to the need to dynamically allocate memory. The C++ code saves the row, column and non-zero indices for the sparse matrix which is constructed in MATLAB. This version also includes a pure MATLAB version (i.e. no C++ code) that can be optionally used, but both of these versions are very slow. ODRT or VRT are not supported as using them would be infeasible. The development of OMEGA has been an iterative process with this non-parallel case being the very ﬁrst to be developed. While this case is no longer recommended to be used, it is included for feature parity. </span></div><div  class = 'S4'><span>The other case, with precomputation phase, is computed in parallel with OpenMP. The precomputation phase is needed in order to allocate correct amount of memory for the sparse matrix. In this case, the sparse matrix is directly created and ﬁlled in the C++ MEX-ﬁle. MATLAB sparse matrices are in compressed sparse column (CSC) format, but PET data is handled row by row (i.e. each measurement) basis, making it more suitable for compressed sparse row (CSR) format. However, this can be solved by simply considering the sparse system matrix to be transposed, as a transposed CSC matrix is a CSR matrix. As such, the output is actually the transposed system matrix. This case also supports ODRT and VRT. The precomputed phase was developed after the case without precomputation, initially without OpenMP support. In both cases, the reconstruction itself is handled completely in MATLAB/Octave. Due to this, the reconstruction process can be relatively slow as sparse matrix multiplications are not parallel in MATLAB (on CPU). However, the reconstructions in MATLAB/Octave also allow for all reconstruction algorithms and priors to be supported. It is also possible to compute simply the system matrix (or a subset of it) instead of the reconstructions, allowing the user to use the system matrix in their own algorithms. All computations done with implementation 1 are performed in double precision. TOF data is not supported by implementation 1.</span></div><h3  class = 'S6' id = 'H_7ED6A9CF' ><span>Implementation 2 </span></h3><div  class = 'S4'><span>Implementation 2 is the recommended method for image reconstruction. It utilizes OpenCL and the open-source </span><a href = "https://arrayfire.com/download/"><span>ArrayFire</span></a><span> library. Unlike implementation 1, in this case the system matrix is never explicitly computed, but rather the computations of the forward and backward projections are done entirely matrix free. Both precomputed and non-precomputed cases are available, but this time the differences between these are smaller as there is no need to preallocate memory based on a priori data. However, the precomputed version should still be faster as before. In implementation 2, both the forward and backward projections are computed in an OpenCL kernel that also computes the system matrix elements using the selected projector (both SRT and ODRT are supported). This kernel outputs two vectors, one containing the sensitivity image and the other</span></div><div  class = 'S4'><span texencoding="\Delta = (A^Tp)/(Af + r + s)" style="vertical-align:-5px"><img src="data:image/png;base64,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" width="154" height="20" /></span></div><div  class = 'S4'><span>where </span><span style=' font-style: italic;'>A</span><span> is the system matrix, </span><span style=' font-style: italic;'>p</span><span> the measurements, </span><span style=' font-style: italic;'>f</span><span> the current estimate, </span><span style=' font-style: italic;'>r</span><span> randoms and </span><span style=' font-style: italic;'>s</span><span> scatter.</span></div><div  class = 'S4'><span>The vector </span><span style="font-family: STIXGeneral, STIXGeneral-webfont, serif; font-style: normal; font-weight: normal; color: rgb(0, 0, 0);">Δ</span><span> contains the necessary elements for all selected algorithms and as such has a size of </span><span style=' font-style: italic;'>N </span><span>×</span><span style=' font-style: italic;'> N</span><span>~algorithms~. Both of these vectors are then used to compute the ﬁnal estimates that are calculated by using ArrayFire functions. All operations occur on the selected device and only the ﬁnal result from each iteration is transferred to the host (if options.saveiter = true, otherwise only the last iteration). Implementation 2 supports all algorithms and priors. Implementation 2 was developed after implementation 1 had been completed. Furthermore, a CUDA formulation of implementation 2 exists in v1.1 and has the same features as the OpenCL variant, but is considered only as an extra feature at the moment. All operations are computed in single precision.</span></div><h3  class = 'S6' id = 'H_A439C981' ><span>Implementation 3 </span></h3><div  class = 'S4'><span>Implementation 3 is similar to 2 in that it utilizes OpenCL and has the same matrix-free formalism. However, outside of the OpenCL kernel code</span></div><div  class = 'S4'><span>the two are very different. In implementation 3, the computations are performed in "pure" OpenCL, i.e. there are no third-party (ArrayFire) functions at work and everything is computed in custom-made OpenCL kernels. </span></div><div  class = 'S4'><span>The forward and backward projections work like in implementation 2, but this time only for either OSEM or MLEM. This is due to that it allows the use of multiple devices at once, which is also the biggest difference between implementations 2 and 3. These devices can be either CPUs and/or GPUs, though currently all devices have to be from the same vendor. This allows heterogeneous computing with both CPU and GPU or multiple GPUs, as long as they are from the same vendor. When using different devices, more work (i.e. more LORs in this case) can be assigned to the more powerful device. Currently any devices with memory of 2 GB or less are ignored in order to prevent out of memory issues. All operations are computed in single precision. </span></div><div  class = 'S4'><span>Implementation 3 was developed after implementation 2 as a separate project to enable multi-device support and additionally to provide OpenCL reconstruction without the need for third-party libraries.</span></div><h3  class = 'S6' id = 'H_496A0902' ><span>Implementation 4 </span></h3><div  class = 'S4'><span>Implementation 4 is a combination of implementations 1 and 3, meaning that it is a pure CPU method that uses OpenMP for the parallellization, as</span></div><div  class = 'S4'><span>in implementation 1, but is implemented in matrix-free way as the OpenCL methods. The matrix-free formulation itself does not essentially differ from the OpenCL, except using C++ OpenMP code. </span></div><div  class = 'S4'><span>As with the OpenCL methods, the sensitivity image and &amp;Delta; are computed, but unlike the OpenCL methods, in implementation 4 these are output into MATLAB/Octave where the actual reconstruction algorithms are used. Due to this, implementation 4 supports more algorithms than 3, but less than 1. Supported ML methods include MLEM, OSEM, RAMLA and ROSEM, MAP-methods OSL, BSREM and ROSEM-MAP along with all priors, though only one algorithm and prior can be used at a time. All operations are computed in double precision. </span></div><div  class = 'S4'><span>Implementation 4 was developed after the other implementations (excluding CUDA in implementation 2) as a fallback method for matrix-free computation without the need for OpenCL. It was also developed for CPUs that lack OpenCL support and to provide numerically more accurate matrix-free formulation.</span></div><h3  class = 'S6' id = 'H_59DEC0EF' ><span>Matrix-free formulation </span></h3><div  class = 'S4'><span>The matrix-free forward and backprojection are implemented similarly regardless of the used projector or reconstruction algorithm. Since in PET the system matrix depicts the probability that an event originating from voxel j is detected on LOR i, the ﬁrst goal is compute the total distance that a LOR (or a TOR) traverses in the image domain. The computations are performed by computing several LORs at the same time in parallel. In the ﬁrst phase, the line intersection (or orthogonal distance) is computed for each voxel along the LOR (TOR) as well as the corresponding voxel index. The intersection lengths are summed together as well as</span></div><div  class = 'S4'><span texencoding="\Xi_i = \Sigma_l L_{il}f_l" style="vertical-align:-6px"><img src="data:image/png;base64,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" width="67" height="20" /></span></div><div  class = 'S4'><span>where</span></div><div  class = 'S4'><span texencoding="a_{il} = L_{il} / \Sigma_l L_{il}" style="vertical-align:-6px"><img src="data:image/png;base64,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" width="82" height="20" /></span></div><div  class = 'S4'><span>where</span><span texencoding="L_{il}" style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAoCAYAAACb3CikAAAClElEQVRYR+3XX8jOdxjH8deTUiZxwMiJFC0HiFHigBNksQMJM1pJbZH8KVKSJIWDjUaINvmXtTVpB0ItHOBQk+TPph1MbaZhB6L86dL1q7s7z++57/u57+ehnl/dJ0+/3/d6X9f1uT7X92nzjjxt7wiHHpDqTvRU5L2syADMx0QsQL+KLK7jZ/yAm82YvFo08gF2Y1kGPI0v8XczAIozGgFZjOPNhIizagEZmoGn4Q7m4bfuAJmCM6mRn7JFj7sDZA2+zsCbsA2vuhokJmUvlmTgGTjfbIhaNPJRjuhYXMYi/NkdIJ8ixjWeA4g2Pe1qkJiozfmL2F8lTCs4Sse3Pw7luP6P0MfVllB04CNjEOM6EhfwOe53B0gEPpaBv8EGPO8kyECMQyQ5CjvSJNttTW9sT3FG7EZsvRfWZgKzcSWTCKc+gn+xAg/LxrcRW++LOTiL/xAgG7EUX+BighQt/x478aIMpBFbDzHPygo8K2lh0fJPcnW8ebW9pVdp61sQvzJbH5IT9l3eU9rjiCptRUDEHedW2TWg2tY70kdARImj5HH4XYzGxxiP2/gWLxFiPYp/sBJPykDiwJOp6njvYGbxVx4Wfwsxf4iZWIdYBZXOW2mGc3EqAwbcLzktewp9VLcmMotbWFwPI6N6n8rK9UGM/KSqFoQ+9qVJnqsMUMvFqF6geH8YTmSbihYUljAZn+FeV4BMR2S8GkULBiXc729bnq2oSJwZ/rEcC3GpI32UjW8j7Si+KZZltCJg4r+AP1J/sc0D7lEK9UbZ1HQGIr4dkVMXi/JaWvmvuTImYD2m5pQFUKmhdQZmMA5jeBrhj2mG0a5V2I9deNAVYq07kVaItW6IVom1B6ShClR/1KOR6oq8BhknhSkXVHNZAAAAAElFTkSuQmCC" width="17" height="20" /></span><span> is the intersection length and </span><span texencoding="a_{il}" style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAoCAYAAACfKfiZAAACn0lEQVRYR+3WW+jPdxgH8Nc/i2wklBUX48K5GLuwmSbK4cLhgmKOF3PaamZb0exiObSWmBSyuHGaY+YGxQ1iFC5wpZTDHOJG3Ehheur5/fr28z/3+yf1+139+n4/n+d5P+/neb+fb513/Kt7x/nVANQYqDFQY6DGQI2B5jAQZwZgAXriBnrhaD7ri1m41prF1hSAbliOSViBE3iNPtiHETicQJ5WG0BUuQWfYj7OFBJ0x15MwE/Y2JrkcachBj7GX5iKuZns/0KST/A3RmI0zlYTwAdYhZXYhe/xrCLB5ziJ69n/O9UE8BX2oxOmZ6LK+D/iz2Qp/j9vAkBnDMdgfIYduFBfCzpgHZbiH3yDJxXBe2A7pmBJgqjMPxOb8EMWE++75KwMwte4VR+A/jiAofg5LxR7H3dmYw8eYjKu1FN9DG0UEuyEWiJGSDgGN2RcZq1yCMcVKB+PUxXBe2fyL3E6wTxoZv/jTsg45LwtQb2lglJ1EXMUzheCf4Q1Kcsx2JosRWXhF5ebALIYvyHaU1ZNYwzMScoibgxRJI8kUUn0PvR/EMuwHo8wEMMS5Mu8EwPaMdvZL2V9vwS2EkCYz25EhVdzkML5AsyGBBD9DwMKB2yHX7KvpZjzsDOBbcYrlHzjUrbgRUMA4nn4/mpMxE0cST+4m5X8nuoIAEHpfwXqo6Bf8V0F1aX+x2CHBMuD3dQuaOZ8lY+F1CJBWHU4aInqmPpvEexcLAatNoAh2ZrjBao/zFaGfyzE47YEUFJRcYAb7H9jy6il1Mf59vgDYzEj13bMTVh77I0AdS6/Jf5tbAhbkzzudE0FxeI6lLskXDCWWfR/Eb7IM/faAkAYVXwXTMPadLvwgJItH0t13W7LGWgxe9VWQQ1AjYH3j4E3uJWKKRPnXkIAAAAASUVORK5CYII=" width="16" height="20" /></span><span> the probability.</span></div><div  class = 'S4'><span>In implementation 4 the intersection lengths and voxel indices are then saved in temporary variables. In case attenuation is included, then </span><span texencoding="\Sigma_l \mu_l L_l" style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEoAAAAoCAYAAABZ7GwgAAAFj0lEQVRoQ+2Zach2UxSGrw/JEEqm+EFC5ojMIaGIZJ7JkDGZMmUmY5nnyDwVIRShTJn5Q0IIZciYIZmHrq+133a785xnn/M+L9+Ps+v9c5493mute91rvbMYRhUCs6pmDZMYgKp0ggGoAahKBCqnDR41AFWJQOW00qMWB24AdqxcX05z7bHALz3XT2LZ0sDuwIbArsWGzwOPAncCn3c5rCn0VgFuAdaPjS4CLgP+bNh4LmBN4BhguwD5/wYqXVOj3w1sGR+uBU4Efu4CUJrbBJTf9gSuBxYCfgIOA+4B/hlxyMLAVeFJcyJQvmEb4IU+ILlmFJnPAxwPXBgbfwLsDzzbctBWwM5zQOilK+rp9wMrAs8Ae3cNt/ytbVlvQeBi4IhY8ApwAPDOCLCWD064Avi1r+UmuE5g5CKH1HEy8Hvf/cfJgyWDd3aIA24Mj+kV530v2WPdvBEN0oBjH+CuHvtMLRkHlBNLctcyl4wg9653mR9YAPg7uDBPGN5N7pMG/P5jC0eW55r5BGZz4H1gF+DNrperDb183mbAbcCyleReeyctfmlwycHAD9nC/LHHRfjU7rsx8FgkI3mq3Lt2n04e5eQyE9aQ+7jLmFGvAfYFLgBOB/7KFqXH+qlrxkoGcK37ntfBGxvvXRN6aWGeCccR+ziQ/F3vVOdsBMiBDxeL0mO7ZixD2YSiFzm2Bp6suVDbnC5Auc8WwJXAkWOkQs29lBNPjOCQ3Nu6ZqzcAG8AewAf1FxoUkBJ6jeHsGwTn7V3auOn1YD7IpEodi2NakcygPPvCKMqOKc1aj0qyYSXOma8uYE1gFWBtYDPAmg1WuKnswH/kup3zZnBLV8A2wN6Rj402srAOrHu/KgKfM+pwLkxuWsSWAxYO8oyz7B8M2tWdTiT8HR+Ta3k/N8y+WA9qFC9CdgJeBBYAbg3Hlryk4ra37zo40H23xRACYg08FTUmVdHIlgkzlEO9C1bzLa3A54pxXxbA1QCSc6wpPl6jP+qi06JOjFV53qIFt42qvr3gBQebwG7Ae/Gvq7Xilb/S4zIhukKh4bnyUHPxcc+ZYvFs6CbTOx6pD1sDFiZzM7EbaGXspztCi/1ZUWQyy0nAEdnmkh3liu0jBZSKwmm4ZJrnCRBNo0wtXsxSlELqCRvSO8FfBp361q2eKbZUUdwP8M/7aFh1WKzxyig0qWPAg5sqe9y7LSMeuWP8L5U75UWMn0nfjKDGs6GqqJWgxhuitukqDWQgNnNSKVTEqN6Z+pWlGWLRbwh1DZSgtKwrwJN3t8KVFLiPlZxOW5YamwQk87IyNRPWui6KCOUAzk/PQQcAiwXbn4aoEclb9MDFaSvF3IkiVHpQO7TE3Il77mbjGmrmAzUW5ZPniEnJe//CtBJLJtGAlXWduNAKn/PwyVZWVFpj+ujjJ/ydd9FWD4SWVXPejq8ytZOKUf0osOB/YCXYyOFpaFsGDnMpPbI3DtlVEN2qeBAKWLRQrmbRb2DPJkSRCNQ020Fu2muhJsslPjJdo2y423grADG9bZvJVGtmTwrL5YTP60UnmAo65WuU2x2GWVmLL1/aq9aHdXl8HxuaaGcn/qWFkl5vwacFPzW9375uibv/8+AMjTskqYUnvjJjKoEkIy7DjnMcJx2j6k4OPXYP2zq0s6kR7Xx03RKiyZ+6gp20/yR/OTkmQQqT+GWFevFn3zUt/WRimUVuGS+eqT17yeAVC5g3U+hKX82kvkEzpvaIllIQk4lyEHx76Pp8tOL0XlQvVvu5H2sPm9I3r9u6DrlkYX4lAFm0qNUzfabzF7nAPOFNvkYUC+NK4eaHmyWvBVYJsqbByZE5gpNvV7hqbC9vLzfTALVx7Jz7JoBqErTDEANQFUiUDlt8KgBqEoEKqcNHlUJ1L//VF04Vt4dWgAAAABJRU5ErkJggg==" width="37" height="20" /></span><span>, where </span><span style="font-family: STIXGeneral, STIXGeneral-webfont, serif; font-style: italic; font-weight: normal; color: rgb(0, 0, 0);">μ</span><span> is the attenuation coefficient, is computed as well. </span></div><div  class = 'S4'><span>After the ﬁrst phase, the inverse of </span><span texencoding="\Sigma_l L_{il}" style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAAoCAYAAACvpem4AAAEaklEQVRoQ+2YWaiVVRTHf9ck0TQRhygfBB8UDTUN0goUQkMllbJwLhLULKKJHDHBIQc0ccIkUcIxDKRCjZKgiAash/BBfFJDyxlUJHPmf1j7uu/hfues75zvXK7es58O31l7+K+91n/9166hiYyaJoKTKtD77aarN1q90XvUA/mh2xHYCLxYIh7NfQ/4zzH/AWAo8AwwGugezbkA7Aa+Ab4FbjrWK2hSX472ALYA/W3mMmAVcKOelZoBvYF3gRfMSV6g8XKvAp/bh+PAa8CP5YKL59cHVN/GAZ8CbYDLwBvATuB2wuYPA2vtJssFmiYq3L5IYt3mwAfA0hReHmIhmBaoQnghMNv2klMFNtNRqLw8BCwH3rQdfwdeBw4nnKAr8AqwGria4pQdgK2Wr/8CI4A/U8x3mRaro4+Yd0fZap8Z2Vxxre4zetJI51EjnknAOd9Uv1UxoFopn5xmASsTyMm/813LacYH+rIEmJcFy+YfxANUcwYZK3ZxkpMXcEtjdIHVUOR87Z2cxs4LNJ+JsyoBctwOq6V/AWOAI2kAeG29QLVezMTFiMm7/8CoXoqQ3rKI8c5326UBqkWfA9bYgbIo6CpFn9hp51iOug+fxjANUJHSZhMGhcSDd3+JkfWAWFbjeeB77+S0dl6gocz8mpJxJQZ6AT2BJ4CT5qhbpm2/APoAvwDjAeV+OUPO6wc8DqhsbQJ0ZtcLQxAOsp8BFKuhsv8/Kj/SwxIa2vQlYI8hGQl8Zb9LlX1jTaC8A+yytdoak8u5krJHPUADSHlKkvBsEXerXEjKSSf/Y7ZB4g2PWLUU2afoGwycAg7Z2hL/Um/K9ZBOjwHbjb1r5Wih0A0s+zSgOnfaEVMKmQ8Befii2QeJd95ITN9LkX2dgRWASCt3SwnjWWA/MNMcnmtEkoCGuvk2MLmAvo33Ui+7GLhutx/0rtq4L631k/fVW8ay74DlZ6FokdOlyLSH0kepkTR0KfMBhfVPwSgJaFBCOqyHINSmDbBFP7JuJOwxAdgAvAx8Zx9j2VcsP1sAU82J0y0sVQH6GsGpT1b3o2Y/KK1uxuYiv9zwNN6OiK1jMtEOo48PWqunV4RADKF3VbOtIfHxPvAHcM2+icDaGZDQ1Ocrp9Cs6/91FilBaR200K29+ayfUnTOuB6GXDxjYIYZIek1Iu2Ib17nnmstZByiIT9FnGL52ocCbx1Ne6hgH3JRzzHB66WuFc9TCRGQ9nkhKpZVeOu2f4snVBqoNtQrRR1iyABpILh9UYi2spraCZgCKIpqRyWB1pefGWDMLSGC2wbEfJCYn0lklNVh4sKtfHoK+KFIafDsHRyoBkNtneTk34A6IbG6wP8MqO5KWuZGJW805OfH9jSit9pQXjyAkmzExmrpLtnbb2tTRar5yk+VIokc2ZxoCKDSmmqqdaAFdpvyfrlDslTvzHr0XmTqRzU0yMG9tt+xhsrRcgFlOr+SoZvpQctdrAq0XA82tvnVG21sN1LueZrMjd4BAB73KXs1yQIAAAAASUVORK5CYII=" width="29" height="20" /></span><span> is computed. If attenuation is included, this inverse value is multiplied with </span><span texencoding="\exp (\Sigma_l \mu_l L_l)" style="vertical-align:-6px"><img src="data:image/png;base64,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" width="71" height="20" /></span><span>. With normalization enabled there is further multiplication with the normalization coefficient. The resulting value is then used to compute </span><span texencoding="a_{il}" style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAoCAYAAACfKfiZAAACn0lEQVRYR+3WW+jPdxgH8Nc/i2wklBUX48K5GLuwmSbK4cLhgmKOF3PaamZb0exiObSWmBSyuHGaY+YGxQ1iFC5wpZTDHOJG3Ehheur5/fr28z/3+yf1+139+n4/n+d5P+/neb+fb513/Kt7x/nVANQYqDFQY6DGQI2B5jAQZwZgAXriBnrhaD7ri1m41prF1hSAbliOSViBE3iNPtiHETicQJ5WG0BUuQWfYj7OFBJ0x15MwE/Y2JrkcachBj7GX5iKuZns/0KST/A3RmI0zlYTwAdYhZXYhe/xrCLB5ziJ69n/O9UE8BX2oxOmZ6LK+D/iz2Qp/j9vAkBnDMdgfIYduFBfCzpgHZbiH3yDJxXBe2A7pmBJgqjMPxOb8EMWE++75KwMwte4VR+A/jiAofg5LxR7H3dmYw8eYjKu1FN9DG0UEuyEWiJGSDgGN2RcZq1yCMcVKB+PUxXBe2fyL3E6wTxoZv/jTsg45LwtQb2lglJ1EXMUzheCf4Q1Kcsx2JosRWXhF5ebALIYvyHaU1ZNYwzMScoibgxRJI8kUUn0PvR/EMuwHo8wEMMS5Mu8EwPaMdvZL2V9vwS2EkCYz25EhVdzkML5AsyGBBD9DwMKB2yHX7KvpZjzsDOBbcYrlHzjUrbgRUMA4nn4/mpMxE0cST+4m5X8nuoIAEHpfwXqo6Bf8V0F1aX+x2CHBMuD3dQuaOZ8lY+F1CJBWHU4aInqmPpvEexcLAatNoAh2ZrjBao/zFaGfyzE47YEUFJRcYAb7H9jy6il1Mf59vgDYzEj13bMTVh77I0AdS6/Jf5tbAhbkzzudE0FxeI6lLskXDCWWfR/Eb7IM/faAkAYVXwXTMPadLvwgJItH0t13W7LGWgxe9VWQQ1AjYH3j4E3uJWKKRPnXkIAAAAASUVORK5CYII=" width="16" height="20" /></span><span> values. Randoms and/or scatter is then added to </span><span texencoding="\Xi_i" style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAoCAYAAAAG0SEsAAAB6ElEQVRYR+3WT6hNURTH8c9DJCkDM2P/BzJBkRmSMniZKCUpBkYiUv6EohgY6CUZGMh7PQYyUhhQlFIGBgYUAyXlX8mfkWhpH12vc88575577pXurjs6e6/vXmv9fuvuIX1cQ31kG8D7Uv1B2VvLvhoPavThIvbie1mMvLL/E/AxXMXXsgzS9+XYjXt1M9+HnfhUEZxtG8b6uvAVODdJcGxfmC59rNOeT8fUKoc7uNxfR4p8HpfYgPv4XALahOd4MZkLFcFn4hQu42lB0Bk4g2t42E149H0eLhVkH9Y8iI1NwMM+Vdaa/w7+BmfbqH8KVuIC9nQ78yqCC9GGr+90Ex5eX4SXFTy/GO/wvo045uMKHuNAFm+i1aYhLPYFP6uoLGdPzIf4RYxsLcFoqkzAf/9fTITHeNyFI/jWIXwdVuFk2fk8eIhnP56UHc75PisNnLedwscxB9cLeph3r9DI2jSSjyb43OSGZQhdnGgdwXmZBzw211kZPGKEaGP0Pkt2/JAF7gU8xu8tnE4t+dEOXifbdmfjPXccW3C7dVPTT+fZGMECbMWrXsLDuqGhR3lPq6Yz34yb2Ia7iH7/mYJNww9hR5obSxFv+o+9Etx2nMcNHMbrXva80D1Nl30Az63AoOxNzPTSmL8AAV5iKQF6efkAAAAASUVORK5CYII=" width="15.5" height="20" /></span><span> if either has been selected. The ﬁnal value is then used to divide the current number of counts (</span><span texencoding="p_i" style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAoCAYAAAAPOoFWAAACWElEQVRYR+3WS8hNcRQF8J9nKZKYGCnlXQwkRRkQKaWU8iblVaRESpQwUBQDkWfII6QkA4U8BkRGJJKBV5E8yismHu2vfXU67v3u9aVvdE/dwT1n3//aa+2117kdtOPVoR2xNMH+i9pNGZsytqpA0yDtZpCu6IZP+IXO6JHoH/Gz0U6qzawvZmIShqAftmInFmNJ3guMu1iJ240AtmaQkTiD/liPETiMq4iGdmMKbmIuntUDbA1sIi7hM+4nq0eFA5dib34PFS63FSyaCDZb8Do7D0bFaw6O541gdqKtYD1xENNxBCvwtXTYfBz9H8yG4ywGJKty18F8Y36eZFMhdZsSZCrO4x5m4HHplF44hGk1mEeTx9Kta/Etfl/NIJ1yVutakXAcTqE75mVjxX6G4mQ6NcBaRlANrE92NRnLsK/EKhY8di7ceACrqsyzqpzVwGK/LmTXYeniwkb9rLT8QyxEcR3+eWaV/bmF2XheOGFMujSiaxEelE4PVUZnAET6bEYYqOUqMytKdCXB3qIjJmB7mmYDXtagMTiTJ5gvx/taYJGDMdhgcA1v0okRVS/SFHfqhO9YXMw83YYftcDCZTcyosrzqrdGledhmE25exF3f66yjFG4A9cRcfSqUYSsi1dPBPTANNLTWmCVwtibPViN7/8INgin08HReMsyV5OxUhjzqbZfjeBWkieCOQwW83pXBgs5w8r788H4NEgjAMWaSJ3YvTUYloHwoQjWO1N9FLrkgy/5koxI+mPdBpAXYBfO4a/1aP6Va0DB+iVNGetr1EBFu8r4G7vyfCkpTghAAAAAAElFTkSuQmCC" width="13.5" height="20" /></span><span>)</span></div><div  class = 'S4'><span texencoding="\Theta_i = p_i / (\Sigma_l a_{il} + r_i + s_i)" style="vertical-align:-6px"><img src="data:image/png;base64,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" width="141" height="20" /></span><span>.</span></div><div  class = 'S4'><span>In the last step, the sensitivity image and the backprojection are computed. Sensitivity image, however, is only computed during the very ﬁrst iteration unless not enough memory is available for storage in which case it will be computed on-the-ﬂy. When using implementation 4, the intersection lengths and voxel indices are loaded from memory. In OpenCL methods, however, both values are computed again, due to the high memory costs of saving the variables in all the threads as well as the slowness of the global memory in GPUs. Both the sensitivity image and the backprojection are saved in a thread-safe way by using atomic operations, more speciﬁcally the atomic addition. Atomic operations guarantee that the read-write operation to the memory location is only available to the current thread until the operation is completed, essentially making the operation sequential. Atomic addition in this case thus sums the input to the currently residing value in the current voxel index. With sensitivity image, the LOR probability is thus atomically added to the current sensitivity image vector at each voxel the LOR goes through. For backprojection, the process is otherwise identical, but instead of probability only, the LOR probability is multiplied with </span><span texencoding="\Theta_i" style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAoCAYAAABw65OnAAAC8klEQVRYR+3XW+hlYxgG8N/klHOZjFxJ1MyNC1yMuaGpmeTMREQOMc3IKczFzESO5UIxI0ZOFw45hAl3SDklEY1yRYibUVLCIGLo+feuac+y/3utvU27Uf+vVu3W9633e97D8z7vnmc3WPN2AwzmQDRZmIvE/zIS83EyzsCxWFhebMH7eAXv4rdJ2NZVE/tjFW7GXngCT+FL7FmAsn8OPsVteBnbxwEzCsRhuB/n4QNci4/wd+uCgLkI9+KQAnL3OFGZDcRB2IDL8Q0uxdsjvIudAEmUstbhHvzZJyLDQOTdddhYBu7CrT0MBngidwm+xQV4Z1IQR+JZLMbPOAXv9TGGFdhcZx/HNfil69thkRg09AYuxI/YG9uGGIyNA6oGjsbzOKaiETZ9PC6IPXAn1teHD2INjsDa+v1Dy+gC3FFPKJq6OK3OpJaeHBfEgdiEi+vDWwpU+sTT+KnlWUCfiO9wddVNCnp1fX878rQZtROudjqay9KYstogmvdt5x7GDfVyEETzfmQT21UgXsRK/FHUbiIxEYj9cF8ZHIzEoXis9t4cCG+cWFqUvgK/tkBMlI4YTU/IkzVYmGdX7/i9lYt9ioqhZiid2mnSNlFhxv6ZJUj5/WoV6fddFV77izoomkK+sTrq6SV+Q8e7w4tWy4rricCHPUF0NauAuKnkYIcUzNa2U2SPjNm2o7gP4LJKy7l4vQ/42QQsBqOEV/UUsNx1VjWq9Jr/LGAN+DAiSpjGNUrK48hJeKiGnQhenkHNSBrSyo/Hcfi8xG5m7ugaavbFlTXU5PyjeAFfF9KjCmTyu7W6Y/aHSfgg81I7LzXedoFozkWmQ7tTsWTC8S4OpZuegPPx2bgg+tRX15mI4DP4oqa06NDM6huJrgv67C8vtlxfLPpr2iDibPpD2PaviWtakTi4tCeDUYBEo77CTDSmBSIT13N4C58gMvBaI4TTApG/D5k5M79GWXei8bRAjCzcORDTpuhcOvp00qn1iZFg/gGWEakp164CIAAAAABJRU5ErkJggg==" width="16.5" height="20" /></span><span> beforeatomically added to the current </span><span style="font-family: STIXGeneral, STIXGeneral-webfont, serif; font-style: normal; font-weight: normal; color: rgb(0, 0, 0);">Δ</span><span>.</span></div><div  class = 'S4'><span>If the sensitivity image is saved, the subsequent iterations will be much faster as any LORs with zero counts will be completely ignored (the additions would be zero). Implementation 4 uses OpenMP atomic operations for 32-bit ﬂoats to compute the additions. For implementations 2 and 3 there are two diﬀerent atomic version available. As there is no inherent support for atomic addition for 32-bit ﬂoats in OpenCL, a similar method as in </span><a href = "https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/"><span>GROMACS</span></a><span> has been implemented. However, since this is relatively slow another approximate version is also provided that uses 64-bit signed integers instead of ﬂoating point numbers. In this case, the ﬂoating point values are converted to 64-bit signed integers, which causes some loss of precision due to rounding, before atomically added. This provides some speed-up compared to the 32-bit ﬂoat version, but cannot be used on some hardware. If the user has selected this option, the support is determined during compile time and the ﬂoat version is used if the hardware does not support 64-bit atomics. The output sensitivity image and </span><span style="font-family: STIXGeneral, STIXGeneral-webfont, serif; font-style: normal; font-weight: normal; color: rgb(0, 0, 0);">Δ</span><span> are then converted back to 32-bit ﬂoats before they are used in the reconstruction algorithms.</span></div><h3  class = 'S6' id = 'H_24EBB306' ><span>TOF coefficients</span></h3><div  class = 'S4'><span>TOF coefficients are computed exactly the same for all implementations. Though for implementation 4 the intermediate results are saved regardless of user selection. TOF coefficients are computed only if TOF data is selected. For implementations 2 and 3 they are included in the kernel compilation only if TOF data has been selected. With implementation 4 they are simply behind regular conditional expressions.</span></div><div  class = 'S4'><span>For TOF data the variance of the data and the bin center locations are precomputed. The variance is determined from the </span><a href = "https://en.wikipedia.org/wiki/Full_width_at_half_maximum"><span>FWHM</span></a><span>. Bin centers are determined from the input bin width, bin number and bin offset.</span></div><div  class = 'S4'><span>In the kernel itself, the first step is to compute the distance from the FOV (voxel space) to the "source" (first detector/crystal). This is achieved by using the parametrization of a line since the required parameter (often t) is given by the Siddon's algorithm. The half of the total length of the ray is then subtracted from this value. The intersection length is added to this value after each voxel. This length is the distance from the current voxel boundary to the center of the ray.</span></div><div  class = 'S4'><span>TOF coefficients are computed at each voxel for all TOF time bins. Meaning that every time a voxel is intersected, the TOF coefficients are looped through all the TOF bins. The only difference in the computations of the TOF coefficients are the different values for the TOF bin center locations. At the same time each of these TOF coefficients for the corresponding voxel and summed together. Each TOF coefficient is then later divided by this total sum. TOF coefficients themselves are computed as a 1D integral from the current ray location to the next (e.g. the intersection length is either added or subtracted from the current distance from the center of the ray). The integral itself is computed by using the </span><a href = "https://en.wikipedia.org/wiki/Trapezoidal_rule"><span>trapezoidal rule</span></a><span>. Each original probability is then multiplied with the TOF coefficients. &amp;Delta; is computed for each TOF bin and then summed together before the atomic addition. Same goes for sensitivity image, although that could be computed without any TOF information as well.</span></div><div  class = 'S4'><span>Due to the use of the trapezoidal rule, TOF bins with very high accuracy (voxel size accuracy) are not reliable.</span></div></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% Toolbox overview
% The general structure of OMEGA can be divided into three different layers. 
% The top layer is the MATLAB/Octave user-interface that contains the scripts 
% and functions necessary to call the lower layers. The middle layer is the MATLAB 
% (C) MEX-interface that calls and computes the C++ code and then sends it back 
% to the top layer. The bottom layer, which is not always used, contains the OpenCL 
% kernels that compute the OpenCL code and then send the output data (reconstructed 
% images) to the middle layer. The bottom layer is only used if OpenCL code is 
% used. The middle layer can also be ignored, but this is not recommended and 
% not enabled by default as the pure MATLAB/Octave implementation is extremely 
% slow.
% 
% For the user, only the top layer is exposed. This is achieved in the form 
% of scripts that are referred to as _main-files_. These include |gate_main.m|, 
% |main_PET.m|, |Inveon_PET_main.m|, |Biograph_mCT_main.m|, |Biograph_Vision_main.m|, 
% |custom_prior_test_main.m|, and |forward_backward_projections_example.m|. It 
% is from these main-files that the actual functions are called. This is achieved 
% by storing all the user selected parameters to a MATLAB/Octave struct called 
% options, which is then input to the functions (e.g. when loading data or performing 
% image reconstruction). 
% 
% In the main-files most parameters are set either with numerical values (e.g. 
% |blocks_per_ring|, |span|, |tube_radius|) or as a true/false selection, where 
% true means that the feature is included and false that it is omitted (e.g. |randoms_correction|, 
% |scatter_smoothing|, |osem|). The main-files are divided into "sections" with 
% specific labels (MACHINE PROPERTIES, IMAGE PROPERTIES, SINOGRAM PROPERTIES, 
% etc.) that control different aspects. Many of these sections are completely 
% optional, e.g. CORRECTIONS section can be omitted if the user does not wish 
% to use any corrections. The only compulsory ones are MACHINE PROPERTIES and 
% either SINOGRAM or RAW DATA PROPERTIES. For reconstruction it is also advisable 
% to inspect the RECONSTRUCTION PROPERTIES section, but the default values should 
% always output a working OSEM estimate. By default all non-compulsory options 
% are set as false (with the exception of the Inveon main-file which has several 
% corrections enabled by default).
% 
% There are also several functions that work very independently without the 
% need for the main-files. These include file import and export functions, visualization 
% functions and many reconstruction algorithm functions. For help on many of these 
% functions, you should use |help function_name| or alternatively |doc function_name|. 
% E.g. |help saveImage|.
%% Technical aspects
% This section explains how, exactly, does each component of OMEGA software 
% work.
%% Precomputation phase
% The corresponding m-file is |lor_pixel_count_prepass.m|.
% Purpose
% As mentioned in other help pages, the goal of the precomputation phase is 
% to determine the number of voxels that each line of response traverses (interacts 
% with). Line of responses that do not intersect the FOV at all will have 0 interacted 
% voxels and as such can be safely removed. This step is also necessary for the 
% parallel version of implementation 1 as it requires the preallocation of the 
% system matrix in memory. This also means that, unlike with matrix free implementations, 
% the orthogonal and volume of intersection ray tracers require their own precomputation 
% passes since the number of voxels that are interacted with is much higher.
% Execution
% Dedicated codes are available for the precomputation phase. Furthermore, since 
% the OpenCL implementations use single (32-bit float) precision numbers and the 
% C++ versions double (64-bit double) precision numbers, different versions are 
% available for both. This is because of floating-point rounding effects that 
% can cause LORs that are on the very edge of a voxel to be in different voxels 
% depending on whether the single or double precision implementations are used. 
% While this usually affects only a very small portion of all the LORs, even a 
% single wrong one can cause a crash due to out-of-bounds variables. Implementation 
% 2 also has its own precomputation code, although the OpenCL kernel itself is 
% identical to implementation 3. This is simply because of the different device/platform 
% executions.
% 
% The codes themselves are stripped versions of the actual projectors. In all 
% cases, the ray tracing itself is always performed, no parameters outside of 
% the ones necessary for the ray tracing are computed. For C++ version, there 
% is a different file/function for this (|improved_Siddon_algorithm_discard.cpp|), 
% but for OpenCL versions all the code are in "master" kernel file (|multidevice_kernel.cl|) 
% where the correct lines are compiled during runtime by taking advantage of preprocessor 
% directives (|#ifdef|, |#else|, etc.). For precomputation phase, the preprocessor 
% directive that is defined is |FINDLORS|. No precomputation code is available 
% for CUDA.
%% Data load
% The corresponding m-files are |load_data.m|, |load_data_mCT.m| and |load_data_Vision.m|.
% Execution
% Data load is divided into three different sections: GATE data, list-mode data 
% and sinogram data.
% GATE data
% For GATE data, the data import is separate for LMF, ASCII and ROOT. 
% 
% In LMF, the data import is done in a C++ file (|gate_lmf_matlab.cpp|) and 
% each binary packet is read sequentially. In LMF, unlike other methods, the coincidences 
% are formed manually from the singles. This is done by first checking if the 
% time difference between the consecutive singles is within the coincidence window 
% length. If yes, then the singles are assumed to be coincidences and all the 
% specified values (e.g. detector number, whether the coincidence is true, random 
% or scattered event, source coordinates) are saved. If not, then the first single 
% is discarded and the latter single becomes the first single and compared with 
% the next single, etc. For time steps, there is first a check on whether the 
% current time is larger than the time of the next time step. If yes, then the 
% current event index is stored. This index indicates where the time was large 
% enough for the next time step to begin and is then used to separate the measurement 
% data into the time bins. Of all the three data types, LMF is the most limited 
% one as it does not support delayed coincidences or scattered events except for 
% Compton scatter in phantom.
% 
% ASCII data import is different from both LMF and ROOT in sense that it is 
% done purely in MATLAB/Octave. It uses either readmatrix (if available) or importdata 
% to import the ASCII text into a matrix containing all the rows and columns. 
% If any of the columns on any of the rows is corrupted/missing (replaced by NaN 
% value), the code will detect these, discard them and inform the line number 
% where this occurred. All the chosen variables are then stored in individual 
% vectors/matrices. Time steps are handled similarly to LMF.
% 
% ROOT data import is handled in a C++ MEX-file. Unlike LMF, ROOT has three 
% different MEX-versions. One uses the "traditional" C MEX-interface (|GATE_root_matlab_C.cpp|) 
% and is intended for MATLAB version 2018b and earlier, the second uses the new 
% C++ MEX-interface (|GATE_root_matlab.cpp|) and is for MATLAB 2019a and newer 
% and lastly there is a dedicated version for Octave as well (|GATE_root_matlab_oct.cpp|). 
% All the ROOT import functions first open the trees (coincidences and delays 
% if selected) and then the desired branches. There are also checks in place that 
% first guarantee that a specific branch is available, e.g. the scatter data. 
% If not a message is displayed, but the data load will still continue, unless 
% it is the detector information that is missing as it is vital for the data load.
% List-mode data
% List-mode data, more specifically Siemens Inveon, Biograph mCT and Biograph 
% Vision list-mode data, is loaded in a separate MEX-file. For Inveon, the source 
% code is available (|inveon_list2matlab.cpp|), but for mCT and Vision only the 
% MEX-files themselves are distributed (i.e. a closed source release). For Inveon, 
% the code loops through all the bit-packets, determines whether they are prompt, 
% delay or time tags and then extracts the corresponding information. Static and 
% dynamic cases are handled a bit differently; in the former case the counts are 
% stored in one detectors x detectors sized matrix, while in the latter they are 
% stored event-by-event basis. In dynamic case, however, the events are stored 
% in a same type of (sparse) matrix as in static case for each time step with 
% the use of accumarray function. Time steps are handled as with LMF data, where 
% the index is stored where the time exceeded the previous time step.
% 
% List-mode data is saved with |listmode| in the end of the filename. For 32-bit 
% list-mode data (mCT only) |listmode_sinogram| is added to the end of the filename.
% Sinogram data
% This applies only to Biograph mCT and Vision. For Inveon, the sinogram data 
% load occurs in |form_sinograms.m|. Uncompressed mCT and Vision sinograms (.s 
% or .ptd files) can be loaded. Corrections can be applied normally. The data 
% itself is saved with machinesinogram in the end of the filename. 
% 
% TOF data can be loaded from mCT and Vision, but currently ONLY with the default 
% number of bins (and bin width).
% Saving data
% GATE data and list-mode data go through the same procedures when saving data. 
% All steps are repeated for the selected number of time steps, where first the 
% sinogram is created (if raw data is not explicitly used) and then the raw data 
% is stored (if selected). For GATE data, trues, randoms and scatter are stored 
% as well if selected. TOF data will have different filenames from non-TOF data, 
% though raw data does not currently support TOF data.
%% Forming sinograms
% The corresponding m-file is <https://github.com/villekf/OMEGA/blob/master/source/form_sinograms.m 
% form_sinograms.m>. Currently, when data is loaded from GATE or list-mode data 
% the sinograms are created through separate MEX-file or OCT-file. <https://github.com/villekf/OMEGA/blob/master/source/createSinogramASCII.cpp 
% createSinogramASCII.cpp> is for the old C-API, <https://github.com/villekf/OMEGA/blob/master/source/createSinogramASCIICPP.cpp 
% createSinogramASCIICPP.cpp> is for the C++-API and <https://github.com/villekf/OMEGA/blob/master/source/createSinogramASCIIOct.cpp 
% createSinogramASCIIOct.cpp> is for Octave.
% Execution
% Sinograms can be formed from saved raw data, during data load (no need to 
% load the raw data separately) and also by simply modifying the corrections applied 
% to the sinogram (e.g. no actual new sinogram is created). When sinograms are 
% formed, a raw uncorrected sinogram is always created and saved regardless of 
% the corrections applied. This is saved as |rawSinM|.
% 
% As mentioned above, the sinograms can be either created from the raw data 
% afterwards or during the data load itself. The latter method is faster and more 
% memory efficient. However, it can be useful to create a sinogram of different 
% size later from the same data. In this case, if the data load takes a long time, 
% it is probably beneficial to create a new sinogram from the raw data. This, 
% however, only works if raw data was initially saved (|options.storerawdata = 
% true|).
% 
% *formsinograms.m:*
% 
% When creating sinogram from raw data the first step is the formation of an 
% "initial Michelogram". This is an intermediate step between the raw data format 
% and the Michelogram/sinogram format. The raw data is divided into vectors that 
% contain the future Michelogram bins. This is performed in <https://github.com/villekf/OMEGA/blob/master/source/initial_michelogram.m 
% initial_michelogram.m>.
% 
% Next step is the formation of the Michelograms by selecting the data points 
% that are within the predetermined orthogonal distance from the center of the 
% field-of-view. These are saved as unsigned 16-bit integers and performed for 
% all the selected data types (trues, prompts, delays, etc.).
% 
% After this, the next step performs the axial compression, though using span 
% of 1 (no axial compression) is also possible. However, span of 1 is only supported 
% with prompts. 
% 
% *MEX/OCT:*
% 
% When the sinograms are created with the MEX/OCT-file, a separate function 
% computes the sinogram indices based on each ring number (axial position) and 
% ring position (transaxial position).
% 
% *Corrections:*
% 
% The last step, corrections, is applied whether the sinogram was created from 
% raw data or during data load. However, most corrections are not applied if |options.corrections_during_reconstruction 
% = false|, with the exception of sinogram gap filling. Corrections are handled 
% in the following order: Randoms (variance reduction, then smoothing) -> Scatter 
% without normalization (variance reduction, then smoothing) -> normalization 
% correction -> Scatter when using normalized scatter (variance reduction, then 
% smoothing) -> global correction factor -> Sinogram gap filling. If any of the 
% corrections are set as false, then that step is omitted. Only prompts go through 
% corrections. Scatter can be applied only with normalization separately applied 
% to it or without separate normalization.
% 
% All the separate sinograms are saved in a same mat-file with the sinogram 
% dimensions in the name. Included are also structs that contain whether certain 
% corrections were applied (|appliedCorrections|) and what corrections were applied 
% to scatter or randoms (|ScatterProp|, |RandomsProp|). In |appliedCorrections| 
% normalization is stored as a boolean variable (false means no normalization), 
% randoms and scatter as char (empty array means no corrections, otherwise they 
% can be e.g. "randoms correction with smoothing"), gap filling as boolean, mashing 
% factor as an integer and lastly the user specified global correction factor. 
% The prop-structs contain booleans indicating whether variance reduction and/or 
% smoothing was applied.
% 
% Randoms correction is applied as randoms subtraction from the delayed coincidences 
% data. Scatter correction can be applied either as a subtraction by setting |options.subtractscatter 
% = true|, or alternatively by multiplication. In the latter case the scatter 
% data is multiplied with the sinogram. Same steps are repeated for all time steps.
% 
% When the function is used to modify the applied corrections (e.g. |form_sinograms(options, 
% true)|), the sinogram creation step is skipped and the uncorrected sinogram 
% is loaded. By default, formsinograms assumes that the sinogram needs to be created, 
% i.e. the boolean value after options needs to be true in order to perform only 
% corrections. Any sinogram, no matter where created, can be corrected like this. 
% However, the data needs to saved as rawSinM in a mat-file with the same name 
% as the current machine properties (e.g. for non-TOF case |[options.machine_name 
% '_' options.name '_sinograms_combined_static_' num2str(options.Ndist) 'x' num2str(options.Nang) 
% 'x' num2str(options.TotSinos) '_span' num2str(options.span) '.mat']| for static 
% data and |[options.machine_name '_' options.name '_sinograms_combined_' num2str(options.partitions) 
% 'timepoints_for_total_of ' num2str(options.tot_time) 's_' num2str(options.Ndist) 
% 'x' num2str(options.Nang) 'x' num2str(options.TotSinos) '_span' num2str(options.span) 
% '.mat']| for dynamic).
% 
% *Saving:*
% 
% In the bottom of the m-file, there is a separate section for loading Inveon 
% Acquisition Workplace created sinograms. These sinograms automatically have 
% randoms corrections applied. All other corrections can be applied just as with 
% raw data. Dynamic data is also supported, but the number of time steps have 
% to be equal to the original data.
% 
% The output of formsinograms can consist of the uncorrected sinogram, corrected 
% sinogram, corrected delayed sinogram, uncorrected delayed sinogram as well as 
% sinograms of trues, scatter and randoms. The first input is either the corrected 
% sinogram (if corrections were applied) or the uncorrected sinogram (no corrections).
%% Attenuation correction
% This section applies only to Inveon, mCT and Vision.
% 
% *Inveon*
% 
% For Inveon two different attenuation correction types are available. The first 
% is based on the blank and transmission scans while the other is CT-based. Both 
% are controlled by <https://github.com/villekf/OMEGA/blob/master/source/attenuation_correction_factors.m 
% attenuation_correction_factors.m>. For the blank and transmission case the .atn-file 
% provided by the Inveon Acquisition workplace is needed. This is reconstructed 
% into an attenuation image by the aforementioned function. All the reconstruction 
% parameters have been pre-set. Implementation 4 with PSF is always used for the 
% reconstruction. In the CT-case the umap-file contains ready-made attenuation 
% images that are simply loaded and rotated. It is assumed that the bed is always 
% at the lower part of the image. For the .atn-case the attenuation values are 
% also scaled with <https://github.com/villekf/OMEGA/blob/master/source/attenuation122_to_511.m 
% attenuation122_to_511.m>.
% 
% The scaling scales the 122 keV attenuation coefficients (blank and transmission 
% scan) to 511 keV. First the tabulated values for various tissues and elements 
% for both 122 and 511 keV cases are computed. The input values are then scaled 
% such that the peak is at the soft tissue level (ignore air). Air is given small 
% values. The values are interpolated to densities and then interpolated again 
% by using these densities to 511 keV attenuation coefficients.
% 
% *mCT and Vision*
% 
% mCT and Vision attenuation correction uses CT-based attenuation correction. 
% The attenuation images for PET are computed with <https://github.com/villekf/OMEGA/blob/master/source/create_atten_matrix_CT.m 
% create_atten_matrix_CT.m> and <https://github.com/villekf/OMEGA/blob/master/source/attenuationCT_to_511.m 
% attenuationCT_to_511.m>. The CT images are first scaled to 511 keV by using 
% trilinear interpolation.
%% Normalization correction
% Normalization coefficients are computed by <https://github.com/villekf/OMEGA/blob/master/source/normalization_coefficients.m 
% normalization_coefficients.m>.
%% Image reconstruction
% The image reconstruction phase has been divided into four separate types that 
% are referred as implementations. Along with these four implementations, each 
% implementation has two different modes of working, one with a precomputation 
% phase and one without. When the precomputation option is selected, a separate 
% phase needs to be completed before the image reconstruction which determines 
% the valid LORs, i.e. LORs that intersect the FOV (see above). This phase determines 
% the indices of those LORs that intersect the FOV and also determines the number 
% of voxels each of these valid LORs traverse (required for implementation 1). 
% While sinogram data may not have any non-valid LORs, raw data often has significant 
% amount of them. As such, the precomputation phase should increase the speed 
% of the reconstruction phase as non-valid LORs are never investigated. This should 
% make even cases with no non-valid LORs slightly faster due to lack of LOR validation, 
% but the effect is greater with raw data. However, due to ﬂoating point rounding 
% eﬀects the precomputation phase needs to be different when computing either 
% implementation 1 or 4 (CPU) or 2 or 3 (OpenCL) as the ﬁrst two are computed 
% in double precision (64-bit) while the last two are in single precision (32-bit).
% 
% All four implementations are explained here separately in the following sections. 
% The matrix-free formulation is explained in more detail after the implementations 
% have been presented.
% Implementation 1
% Implementation 1 solves the image reconstruction problem in matrix form and 
% as such the system matrix is created as whole for each subset or, in
% 
% case of MLEM, the entire matrix in one go. Due to this the memory requirements 
% are high despite the system matrix being stored in sparse format; size of the 
% full system matrix can exceed even hundreds of gigabytes. This is partially 
% caused by MATLAB/Octave always storing sparse matrices in double precision format 
% with 64-bit integer indices in 64-bit systems although single precision and 
% 32-bit integers would be enough. Using the orthogonal (ODRT) or volume-based 
% (VRT) ray tracers even more emphasizes this as the system matrix grows even 
% larger, making even subset-based reconstruction very memory intensive. 
% 
% As previously mentioned, two different versions of each implementation is 
% available. For this case the one without a precomputation phase is the only 
% non-parallel version due to the need to dynamically allocate memory. The C++ 
% code saves the row, column and non-zero indices for the sparse matrix which 
% is constructed in MATLAB. This version also includes a pure MATLAB version (i.e. 
% no C++ code) that can be optionally used, but both of these versions are very 
% slow. ODRT or VRT are not supported as using them would be infeasible. The development 
% of OMEGA has been an iterative process with this non-parallel case being the 
% very ﬁrst to be developed. While this case is no longer recommended to be used, 
% it is included for feature parity. 
% 
% The other case, with precomputation phase, is computed in parallel with OpenMP. 
% The precomputation phase is needed in order to allocate correct amount of memory 
% for the sparse matrix. In this case, the sparse matrix is directly created and 
% ﬁlled in the C++ MEX-ﬁle. MATLAB sparse matrices are in compressed sparse column 
% (CSC) format, but PET data is handled row by row (i.e. each measurement) basis, 
% making it more suitable for compressed sparse row (CSR) format. However, this 
% can be solved by simply considering the sparse system matrix to be transposed, 
% as a transposed CSC matrix is a CSR matrix. As such, the output is actually 
% the transposed system matrix. This case also supports ODRT and VRT. The precomputed 
% phase was developed after the case without precomputation, initially without 
% OpenMP support. In both cases, the reconstruction itself is handled completely 
% in MATLAB/Octave. Due to this, the reconstruction process can be relatively 
% slow as sparse matrix multiplications are not parallel in MATLAB (on CPU). However, 
% the reconstructions in MATLAB/Octave also allow for all reconstruction algorithms 
% and priors to be supported. It is also possible to compute simply the system 
% matrix (or a subset of it) instead of the reconstructions, allowing the user 
% to use the system matrix in their own algorithms. All computations done with 
% implementation 1 are performed in double precision. TOF data is not supported 
% by implementation 1.
% Implementation 2 
% Implementation 2 is the recommended method for image reconstruction. It utilizes 
% OpenCL and the open-source <https://arrayfire.com/download/ ArrayFire> library. 
% Unlike implementation 1, in this case the system matrix is never explicitly 
% computed, but rather the computations of the forward and backward projections 
% are done entirely matrix free. Both precomputed and non-precomputed cases are 
% available, but this time the differences between these are smaller as there 
% is no need to preallocate memory based on a priori data. However, the precomputed 
% version should still be faster as before. In implementation 2, both the forward 
% and backward projections are computed in an OpenCL kernel that also computes 
% the system matrix elements using the selected projector (both SRT and ODRT are 
% supported). This kernel outputs two vectors, one containing the sensitivity 
% image and the other
% 
% $$\Delta = (A^Tp)/(Af + r + s)$$
% 
% where _A_ is the system matrix, _p_ the measurements, _f_ the current estimate, 
% _r_ randoms and _s_ scatter.
% 
% The vector $\Delta$ contains the necessary elements for all selected algorithms 
% and as such has a size of _N _×_ N_~algorithms~. Both of these vectors are then 
% used to compute the ﬁnal estimates that are calculated by using ArrayFire functions. 
% All operations occur on the selected device and only the ﬁnal result from each 
% iteration is transferred to the host (if options.saveiter = true, otherwise 
% only the last iteration). Implementation 2 supports all algorithms and priors. 
% Implementation 2 was developed after implementation 1 had been completed. Furthermore, 
% a CUDA formulation of implementation 2 exists in v1.1 and has the same features 
% as the OpenCL variant, but is considered only as an extra feature at the moment. 
% All operations are computed in single precision.
% Implementation 3 
% Implementation 3 is similar to 2 in that it utilizes OpenCL and has the same 
% matrix-free formalism. However, outside of the OpenCL kernel code
% 
% the two are very different. In implementation 3, the computations are performed 
% in "pure" OpenCL, i.e. there are no third-party (ArrayFire) functions at work 
% and everything is computed in custom-made OpenCL kernels. 
% 
% The forward and backward projections work like in implementation 2, but this 
% time only for either OSEM or MLEM. This is due to that it allows the use of 
% multiple devices at once, which is also the biggest difference between implementations 
% 2 and 3. These devices can be either CPUs and/or GPUs, though currently all 
% devices have to be from the same vendor. This allows heterogeneous computing 
% with both CPU and GPU or multiple GPUs, as long as they are from the same vendor. 
% When using different devices, more work (i.e. more LORs in this case) can be 
% assigned to the more powerful device. Currently any devices with memory of 2 
% GB or less are ignored in order to prevent out of memory issues. All operations 
% are computed in single precision. 
% 
% Implementation 3 was developed after implementation 2 as a separate project 
% to enable multi-device support and additionally to provide OpenCL reconstruction 
% without the need for third-party libraries.
% Implementation 4 
% Implementation 4 is a combination of implementations 1 and 3, meaning that 
% it is a pure CPU method that uses OpenMP for the parallellization, as
% 
% in implementation 1, but is implemented in matrix-free way as the OpenCL methods. 
% The matrix-free formulation itself does not essentially differ from the OpenCL, 
% except using C++ OpenMP code. 
% 
% As with the OpenCL methods, the sensitivity image and &Delta; are computed, 
% but unlike the OpenCL methods, in implementation 4 these are output into MATLAB/Octave 
% where the actual reconstruction algorithms are used. Due to this, implementation 
% 4 supports more algorithms than 3, but less than 1. Supported ML methods include 
% MLEM, OSEM, RAMLA and ROSEM, MAP-methods OSL, BSREM and ROSEM-MAP along with 
% all priors, though only one algorithm and prior can be used at a time. All operations 
% are computed in double precision. 
% 
% Implementation 4 was developed after the other implementations (excluding 
% CUDA in implementation 2) as a fallback method for matrix-free computation without 
% the need for OpenCL. It was also developed for CPUs that lack OpenCL support 
% and to provide numerically more accurate matrix-free formulation.
% Matrix-free formulation 
% The matrix-free forward and backprojection are implemented similarly regardless 
% of the used projector or reconstruction algorithm. Since in PET the system matrix 
% depicts the probability that an event originating from voxel j is detected on 
% LOR i, the ﬁrst goal is compute the total distance that a LOR (or a TOR) traverses 
% in the image domain. The computations are performed by computing several LORs 
% at the same time in parallel. In the ﬁrst phase, the line intersection (or orthogonal 
% distance) is computed for each voxel along the LOR (TOR) as well as the corresponding 
% voxel index. The intersection lengths are summed together as well as
% 
% $$\Xi_i = \Sigma_l L_{il}f_l$$
% 
% where
% 
% $$a_{il} = L_{il} / \Sigma_l L_{il}$$
% 
% where$L_{il}$ is the intersection length and $a_{il}$ the probability.
% 
% In implementation 4 the intersection lengths and voxel indices are then saved 
% in temporary variables. In case attenuation is included, then $\Sigma_l \mu_l 
% L_l$, where $\mu$ is the attenuation coefficient, is computed as well. 
% 
% After the ﬁrst phase, the inverse of $\Sigma_l L_{il}$ is computed. If attenuation 
% is included, this inverse value is multiplied with $\exp (\Sigma_l \mu_l L_l)$. 
% With normalization enabled there is further multiplication with the normalization 
% coefficient. The resulting value is then used to compute $a_{il}$ values. Randoms 
% and/or scatter is then added to $\Xi_i$ if either has been selected. The ﬁnal 
% value is then used to divide the current number of counts ($p_i$)
% 
% $\Theta_i = p_i / (\Sigma_l a_{il} + r_i + s_i)$.
% 
% In the last step, the sensitivity image and the backprojection are computed. 
% Sensitivity image, however, is only computed during the very ﬁrst iteration 
% unless not enough memory is available for storage in which case it will be computed 
% on-the-ﬂy. When using implementation 4, the intersection lengths and voxel indices 
% are loaded from memory. In OpenCL methods, however, both values are computed 
% again, due to the high memory costs of saving the variables in all the threads 
% as well as the slowness of the global memory in GPUs. Both the sensitivity image 
% and the backprojection are saved in a thread-safe way by using atomic operations, 
% more speciﬁcally the atomic addition. Atomic operations guarantee that the read-write 
% operation to the memory location is only available to the current thread until 
% the operation is completed, essentially making the operation sequential. Atomic 
% addition in this case thus sums the input to the currently residing value in 
% the current voxel index. With sensitivity image, the LOR probability is thus 
% atomically added to the current sensitivity image vector at each voxel the LOR 
% goes through. For backprojection, the process is otherwise identical, but instead 
% of probability only, the LOR probability is multiplied with $\Theta_i$ beforeatomically 
% added to the current $\Delta$.
% 
% If the sensitivity image is saved, the subsequent iterations will be much 
% faster as any LORs with zero counts will be completely ignored (the additions 
% would be zero). Implementation 4 uses OpenMP atomic operations for 32-bit ﬂoats 
% to compute the additions. For implementations 2 and 3 there are two diﬀerent 
% atomic version available. As there is no inherent support for atomic addition 
% for 32-bit ﬂoats in OpenCL, a similar method as in <https://streamhpc.com/blog/2016-02-09/atomic-operations-for-floats-in-opencl-improved/ 
% GROMACS> has been implemented. However, since this is relatively slow another 
% approximate version is also provided that uses 64-bit signed integers instead 
% of ﬂoating point numbers. In this case, the ﬂoating point values are converted 
% to 64-bit signed integers, which causes some loss of precision due to rounding, 
% before atomically added. This provides some speed-up compared to the 32-bit 
% ﬂoat version, but cannot be used on some hardware. If the user has selected 
% this option, the support is determined during compile time and the ﬂoat version 
% is used if the hardware does not support 64-bit atomics. The output sensitivity 
% image and $\Delta$ are then converted back to 32-bit ﬂoats before they are used 
% in the reconstruction algorithms.
% TOF coefficients
% TOF coefficients are computed exactly the same for all implementations. Though 
% for implementation 4 the intermediate results are saved regardless of user selection. 
% TOF coefficients are computed only if TOF data is selected. For implementations 
% 2 and 3 they are included in the kernel compilation only if TOF data has been 
% selected. With implementation 4 they are simply behind regular conditional expressions.
% 
% For TOF data the variance of the data and the bin center locations are precomputed. 
% The variance is determined from the <https://en.wikipedia.org/wiki/Full_width_at_half_maximum 
% FWHM>. Bin centers are determined from the input bin width, bin number and bin 
% offset.
% 
% In the kernel itself, the first step is to compute the distance from the FOV 
% (voxel space) to the "source" (first detector/crystal). This is achieved by 
% using the parametrization of a line since the required parameter (often t) is 
% given by the Siddon's algorithm. The half of the total length of the ray is 
% then subtracted from this value. The intersection length is added to this value 
% after each voxel. This length is the distance from the current voxel boundary 
% to the center of the ray.
% 
% TOF coefficients are computed at each voxel for all TOF time bins. Meaning 
% that every time a voxel is intersected, the TOF coefficients are looped through 
% all the TOF bins. The only difference in the computations of the TOF coefficients 
% are the different values for the TOF bin center locations. At the same time 
% each of these TOF coefficients for the corresponding voxel and summed together. 
% Each TOF coefficient is then later divided by this total sum. TOF coefficients 
% themselves are computed as a 1D integral from the current ray location to the 
% next (e.g. the intersection length is either added or subtracted from the current 
% distance from the center of the ray). The integral itself is computed by using 
% the <https://en.wikipedia.org/wiki/Trapezoidal_rule trapezoidal rule>. Each 
% original probability is then multiplied with the TOF coefficients. &Delta; is 
% computed for each TOF bin and then summed together before the atomic addition. 
% Same goes for sensitivity image, although that could be computed without any 
% TOF information as well.
% 
% Due to the use of the trapezoidal rule, TOF bins with very high accuracy (voxel 
% size accuracy) are not reliable.
##### SOURCE END #####
--></body></html>