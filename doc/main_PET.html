<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB R2019a"><title>main_PET</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.7999992370605px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: normal; text-align: left;  }
.S1 { margin-bottom: 20px; padding-bottom: 4px;  }
.S2 { margin: 0px; padding: 10px 0px 10px 5px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: bold; text-align: start;  }
.S3 { margin: -1px 0px 0px; padding: 10px 0px 10px 7px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: start;  }
.S4 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: bold; text-align: left;  }
.S5 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }
.S6 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: bold; text-align: left;  }</style></head><body><div class = rtcContent><h1  class = 'S0' id = 'T_23831B69' ><span>main_PET</span></h1><div  class = 'S1'><div  class = 'S2'><span style=' font-weight: bold;'>Table of Contents</span></div><div  class = 'S3'><a href = "#H_F75EB04E"><span>SCANNER PROPERTIES
</span></a><a href = "#H_76EE12CA"><span>IMAGE PROPERTIES
</span></a><a href = "#H_82C0D710"><span>RAW DATA PROPERTIES
</span></a><a href = "#H_434E4051"><span>SINOGRAM PROPERTIES
</span></a><a href = "#H_4DDBA787"><span>CORRECTIONS
</span></a><a href = "#H_7B53C82B"><span>DYNAMIC IMAGING PROPERTIES
</span></a><a href = "#H_1F1238BC"><span>TOF PROPERTIES
</span></a><a href = "#H_4C623800"><span>MISCELLANEOUS PROPERTIES
</span></a><a href = "#H_47E769AC"><span>RECONSTRUCTION PROPERTIES
</span></a><span>    </span><a href = "#H_D8B1FFCE"><span>IMPLEMENTATIONS
</span></a><span>    </span><a href = "#H_3D808D43"><span>PROJECTOR
</span></a><span>    </span><a href = "#H_5E96EC1E"><span>RECONSTRUCTION SETTINGS
</span></a><span>    </span><a href = "#H_1570E9D8"><span>MISC SETTINGS
</span></a><span>    </span><a href = "#H_A56A75EF"><span>RECONSTRUCTION ALGORITHMS
</span></a><a href = "#H_EC5FFC41"><span>LOAD SCATTER DATA
</span></a><a href = "#H_AD984B83"><span>CUSTOM DETECTOR COORDINATES
</span></a><a href = "#H_CC3384E0"><span>Load measurement data
</span></a><a href = "#H_0AC208EF"><span>DEPTH OF INTERACTION</span></a></div></div><h2  class = 'S4' id = 'H_F75EB04E' ><span>SCANNER PROPERTIES</span></h2><div  class = 'S5'><span>The first section contains the device parameters and is included in both files. These include (name in parenthesis is the MATLAB variable name):</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Blocks per ring (blocks_per_ring)</span><span> = This is the number of "blocks" in your scanner on each ring. If you have cylindrical PET geometry, then this should be the number of R-sectors/modules per ring. For ECAT it is the number of blocks/R-sectors. If you need more help, see the included example (# R E P E A T R S E C T O R).</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Linear multiply (linear_multip)</span><span> = The repeater number in GATE. See the example on how this compares with the GATE macros (# R E P E A T M O D U L E). For non-GATE it is the number of blocks in axial direction.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Transaxial multiplier (transaxial_multip)</span><span> = This is the number of times above blocks per ring needs to be multiplied to get the total number of blocks per ring. Most often this is simply 1.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Crystals per block, transaxial direction (cryst_per_block)</span><span> = The number of crystals on the transaxial side of each block. In the  example the crystals are in 8x8 grids meaning this value is 8.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Crystals per block, axial direction (cryst_per_block_axial)</span><span> = The number of crystals on the axial side of each block. In the  example the crystals are in 8x8 grids meaning this value is 8. Using  20x10 blocks would mean this value would be 10.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Crystal pitch x/y-direction (cr_p)</span><span> = Crystal pitch in the x- and y-directions. I.e. the distance between the centers of adjacent crystals.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Crystal pitch z-direction (cr_pz)</span><span> = Same as above, but in z-direction.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Bore diameter (diameter)</span><span> = Diameter of the scanner bore. I.e. distance between perpendicular crystals.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Transaxial field-of-view (FOVa_x)</span><span> = Transaxial field-of-view (x-direction), i.e. the reconstructed image location.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Transaxial field-of-view (FOVa_y)</span><span> = Transaxial field-of-view (y-direction), i.e. the reconstructed image location.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Axial FOV (axial_fov)</span><span> = Same as above, but in axial (z) direction.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Pseudo rings (pseudot)</span><span> = The number of pseudo rings. Use 0 or [] if none.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Detectors per ring (det_per_ring)</span><span> = Number of detectors per ring without pseudo detectors. Can be automatically determined as in the example.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Detectors per ring w/ pseudo detectors (det_w_pseudo)</span><span> = Same as above, but with pseudo detectors included. Since pseudo detectors are usually included in each detector block, you can determine this number by adding +1 to crystals per block. E.g. </span><span style=' font-family: monospace;'>options.det_w_pseudo = options.blocks_per_ring*(options.cryst_per_block + 1);</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Total number of rings (rings)</span><span> = Number of crystal rings. Can be computed automatically.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Total number of detectors (detectors)</span><span> = Can be automatically determined.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Machine name</span><span> = The name of your scanner. Used for naming purposes.</span></div><h2  class = 'S4' id = 'H_76EE12CA' ><span>IMAGE PROPERTIES</span></h2><div  class = 'S5'><span style=' font-weight: bold;'>Image size in x-direction (Nx)</span><span> = If the total image size is 128x128x63 then this is 128. </span></div><div  class = 'S5'><span style=' font-weight: bold;'>Image size in y-direction (Ny)</span><span> = If the total image size is 128x128x63 then this is 128. </span></div><div  class = 'S5'><span style=' font-weight: bold;'>Image size in z-direction (Nz)</span><span> = If the total image size is 128x128x63 then this is 63.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Flip image</span><span> = Flips the image in vertical direction (before reconstruction, e.g. flips the detector coordinates).</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Image rotation (offangle)</span><span> = How much is the image rotated. This is performed before reconstruction and shifts the detector coordinates with the specified amount. Due to this, this should be a certain percentage of the total number of detectors on one ring (</span><span style=' font-family: monospace;'>det_per_ring</span><span>).</span></div><h2  class = 'S4' id = 'H_82C0D710' ><span>RAW DATA PROPERTIES</span></h2><div  class = 'S5'><span style=' font-weight: bold;'>Use raw data (use_raw_data)</span><span> = Set this to true if  you want to use raw data, i.e. data that has not been compressed at all. This step requires its own precompute phase if </span><span style=' font-family: monospace;'>options.precompute_lor = true</span><span>. The raw data in OMEGA is formatted such that the saved measurement data is a vector formed from a lower triangular matrix. This lower  triangular matrix is extracted from a matrix of size </span><span style=' font-family: monospace;'>total_number_of_detectors x total_number_of_detectors</span><span>. The matrix contains all the possible line of response combinations,  e.g. between detector 1 and detector 3. Since the LOR between detectors 1 and 3 is the same as the LOR between detectors 3 and 1, the upper  triangular part is added to the lower triangular part before the lower  triangular part is extracted. The raw date is always saved in cell  format, regardless of the number of time steps. Non-cell data should work, but cell data is recommended. TOF data is currently not supported  with raw data.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Store raw data (store_raw_data)</span><span> = If this is set to  false, then raw data is not separately stored during data import (e.g.  using GATE or Biograph list-mode data). If you are using your own data, ignore this.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Maximum ring difference (ring_difference_raw)</span><span> = The maximum distance (in rings) from which LORs are included, when using raw data.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Increasing raw data sampling (sampling_raw)</span><span> = Interpolates additional rows and columns to the raw data. If this is set to two, it will double the size of the raw data in each dimension. Has to be 1 or divisible by 2. Can be used to prevent aliasing artifacts, but will increase memory usage and computation time.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Sampling interpolation type (sampling_interpolation_method_raw)</span><span> = Specifies the interpolation method used for increased sampling. All methods supported by </span><span style=' font-family: monospace;'>interp2</span><span> are available.</span></div><h2  class = 'S4' id = 'H_434E4051' ><span>SINOGRAM PROPERTIES</span></h2><div  class = 'S5'><span style=' font-weight: bold;'>Span (span) </span><span>= The span factor (also called axial compression). The higher the number, the greater the compression of oblique LORs).</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Maximum ring difference (ring_difference)</span><span> = The maximum distance (in rings) from which oblique LORs are included.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Number of angles (Nang)</span><span> = How many different angles (tangential positions) are in the sinogram. The angles depict the angle between the LOR and x-axis. Is mashing is used, this value should be the final sinogram size AFTER mashing.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Number of views (Ndist)</span><span> = How many different views (angular positions) are in the sinogram. The views are the shortest (orthogonal) distance between the LOR and the origin.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Segment table (segment_table)</span><span> = Oblique sinograms are divided into groups specified by the segment table. This value depends on the span value and can be automatically computed as in the example.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Total number of sinograms (TotSinos)</span><span> = The total number of sinograms. Can be obtained by summing the segment table.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Number of sinograms used in reconstruction (NSinos)</span><span> = Less sinograms can be used in the reconstruction process itself (e.g. only parallel LORs). This is an experimental feature. Only the N first sinograms can be used, e.g. you can’t pick only 100 last sinograms, but you can pick the first 100.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Distance side (ndist_side)</span><span> = When Ndist value is even, then one extra view has to be taken either from the "negative" or "positive" side. With this you can specify whether this is from the "negative" (+1) or "positive" (-1). If you are unsure what value to use, use the default value. This varies from device to device. If you compare the sinogram produced by OMEGA to the scanner generated one and see a slight shift, then this parameter is most likely incorrect.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Increasing sinogram sampling (sampling)</span><span> = The first dimension of the sinogram (views) can be increased with this value. For example setting sampling to 2, would double the size of the first dimension. The extra values are interpolated (see below). This can be used to prevent aliasing artifacts. Value should be either 1 or divisible by two.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Sampling interpolation type (sampling_interpolation_method)</span><span> = Specifies the interpolation method used for increased sampling. All methods supported by </span><span style=' font-family: monospace;'>interp1</span><span> are available.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Fill sinogram gaps (fill_sinogram_gaps)</span><span> = If pseudo detectors are used, setting this to true will fill the gaps caused by them. Experimental feature.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Gap filling method (gap_filling_method)</span><span> = What method is used to fill the gaps. Available methods are the MATLAB’s built-in </span><span style=' font-family: monospace;'>fillmissing</span><span> or alternatively </span><a href = "https://se.mathworks.com/matlabcentral/fileexchange/4551-inpaint_nans"><span style=' text-decoration: underline; font-family: monospace;'>inpaint_nans</span></a><span> from file exchange. Must be in char format.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Interpolation method (fillmissing) (interpolation_method_fillmissing)</span><span> = Which of the interpolation methods are used when using </span><span style=' font-family: monospace;'>fillmissing</span><span> for gap filling. See the help file on </span><span style=' font-family: monospace;'>fillmissing</span><span> for more information. Input is char, e.g. </span><span style=' font-family: monospace;'>'linear'</span><span>.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Interpolation method (inpaint_nans) (interpolation_method_inpaint)</span><span> = Which of the interpolation methods are used when using </span><span style=' font-family: monospace;'>inpaint_nans</span><span> for gap filling. See the help on </span><span style=' font-family: monospace;'>inpaint_nans</span><span> for more information. Input is a number.</span></div><h2  class = 'S4' id = 'H_4DDBA787' ><span>CORRECTIONS</span></h2><div  class = 'S5'><span style=' font-weight: bold;'>Randoms correction (randoms_correction)</span><span> = If set to true, then the delayed coincidences are stored during data load (GATE and Inveon data) and used for randoms correction during sinogram formation or image reconstruction. For other data, the user will be prompted for the randoms correction data when it is required. The data (mat-file) should then include a variable named SinDelayed (sinogram data), delayed_coincidences (raw_data) or be the only variable in the file.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Variance reduction (variance_reduction)</span><span> = If true, performs variance reduction to randoms data before corrections. The variance reduction uses 3D fan sum algorithm [</span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>3</span></a><span>].</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Randoms smoothing (randoms_smoothing)</span><span> = If true, performs smoothing to the randoms data before corrections. The smoothing is a fixed 8x8 moving mean smoothing. The window size can be adjusted in the original function </span><span style=' font-family: monospace;'>randoms_smoothing</span><span>. For sinogram data, the smoothing is done when the randoms sinogram is formed. Activating smoothing later and performing the corrections during reconstructions does NOT perform smoothing unless the sinogram formation step is done as well.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Scatter correction (scatter_correction)</span><span> = If set to true, scatter correction will be performed during sinogram formation or image reconstruction. In all cases, the user will be prompted for the scatter correction data. The input data (mat-file) must include a variable named SinScatter (sinogram data), scattered_coincidences (raw data) or be the only variable in the file. In the first two cases, the data can be scatter data created by OMEGA from a different MC scatter correction simulation.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Scatter variance reduction (scatter_variance_reduction)</span><span> = If true, performs variance reduction to scatter data before corrections. </span></div><div  class = 'S5'><span style=' font-weight: bold;'>Normalize scatter (normalize_scatter)</span><span> = If set to true, performs normalization correction to the scatter correction data before the reconstruction phase. This phase is ignored if the corrections are applied directly to the measured data in which case it will be subtracted before the normalization correction.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Scatter smoothing (scatter_smoothing)</span><span> = If true, performs smoothing to the scatter data before corrections. The smoothing is a fixed 8x8 moving mean smoothing. The window size can be adjusted in the original function </span><span style=' font-family: monospace;'>randoms_smoothing</span><span>.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Subtract scatter data (subtract_scatter)</span><span> = If true, then the scatter data are subtracted from the sinogram/raw data or the forward projection, depending on whether the corrections are applied before reconstruction or during it. If false, the scatter data is instead multiplied with the sinogram/raw data or the system matrix elements. The multiplication case can be considered as the scatter data included in the system matrix itself as a diagonal matrix, where the input scatter data is placed on the diagonal.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Attenuation correction (attenuation_correction)</span><span> = If true, performs attenuation correction during the reconstruction. You need attenuation images scaled to 511 keV for this. CT images can be scaled with the function </span><span style=' font-family: monospace;'>attenuationCT_to_511</span><span> provided with OMEGA. DICOM CT images might automatically scale with </span><span style=' font-family: monospace;'>create_atten_matrix_CT</span><span>, but currently it has been tested only with one scanner. </span><span style=' font-family: monospace;'>attenuation122_to_511</span><span> can be used to scale 122 keV blank/transmission data to 511 keV, i.e. GE-68 attenuation measurement.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Attenuation datafile (attenuation_datafile)</span><span> = Name of the data file containing the (scaled) attenuation images. Use full path if it is not on MATLAB/Octave path. This is required if the attenuation correction is applied. One exception is if you are using Inveon data and have an atn-file, you can then leave this one blank and will be asked separately to input the atn-data.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Compute normalization coefficients (compute_normalization)</span><span> = If true and the main-file is run, then the input data will be used to compute the normalization coefficients. Currently supported normalization correction components are axial geometric correction (axial block profile and geometric factors), detector efficiency (fan-sum algorithm for both sinogram and raw data or SPC for raw data), transaxial block profile correction and transaxial geometric correction. Supports both raw data or sinogram data. Transaxial geometric correction is not recommended for objects that do not cover the entire FOV (or rather do not irradiate the entire FOV region). The corresponding function will output the corrected measurement data, the normalization matrix (multiplying this with the original measurement data gives the same corrected data) and each individual correction factors. Computation of the normalization coefficients follows the book [</span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>1</span></a><span>]. Fan-sum algorithm, used in computing the detector efficiencies, can be found from [</span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>2</span></a><span>].</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Normalization options (normalization_options)</span><span> = A vector representing all the four possible normalization correction steps that can be performed (see above). 1 means that the method is included, 0 that it is excluded. E.g. the default setting </span><span style=' font-family: monospace;'>[1 1 1 0] </span><span>computes axial geometric, detector efficiency and transaxial block profile corrections, but not transaxial geometric correction.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Phantom radius (normalization_phantom_radius)</span><span> = If the source phantom is cylinder that is smaller than the FOV, input the radius of the cylinder here (in cm). For an object encompassing the entire FOV, use an empty array </span><span style=' font-family: monospace;'>[]</span><span> or </span><span style=' font-family: monospace;'>inf</span><span>.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Attenuation (phantom_attenuation) </span><span>= Specify the attenuation coefficient of the phantom material used for normalization measurements. If no attenuation is needed then use an empty array []. If the phantom radius is inf, this value is ignored.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Scatter correction (normalization_scatter_correction)</span><span> = If a phantom, that is smaller than the FOV, is used, compute the scatter correction for the data. Requires the above cylinder radius and only supports sinogram data. For GATE data it is recommended to use trues in the normalization correction in order to skip this phase.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Apply normalization (normalization_correction)</span><span> = Once the normalization correction coefficients have been separately computed, turning this to true will enable them in the sinogram formation or in the reconstruction phase.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Apply user normalization (use_user_normalization)</span><span> = If this is true, then the user will be prompted for the normalization correction data. This file can be either a mat-file with one variable (the normalization coefficients, such that normalized_data = un_normalized_data * normalization) or an Inveon PET .nrm-file. In the latter case, the file needs to be exactly as output by the Siemens software.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Arc correction (arc_correction)</span><span> = Applies arc correction to the input sinogram data. For the interpolation method, see below.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Arc correction interpolation (arc_interpolation)</span><span> = Method used in the arc correction interpolation. All methods supported either by </span><span style=' font-family: monospace;'>scatteredInterpolant</span><span> or </span><span style=' font-family: monospace;'>griddata</span><span> are available. By default </span><span style=' font-family: monospace;'>scatteredInterpolant</span><span> is used, but if the method is not supported by it </span><span style=' font-family: monospace;'>gridddata</span><span> is used. </span><span style=' font-family: monospace;'>griddata</span><span> is also used if </span><span style=' font-family: monospace;'>scatteredInterpolant</span><span> is not found.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Apply corrections during reconstruction (corrections_during_reconstruction)</span><span> = If set to true, then the corrections are applied during the reconstruction phase. I.e. uncorrected sinogram/raw data is automatically loaded and used in the reconstruction process. The corrections data is also automatically loaded (assuming it has been previously created). Smoothing and/or variance reduction needs to be performed beforehand.</span></div><h2  class = 'S4' id = 'H_7B53C82B' ><span>DYNAMIC IMAGING PROPERTIES</span></h2><div  class = 'S5'><span style=' font-weight: bold;'>Total time (tot_time)</span><span> = The total time of the experiment (seconds). If you have a static experiment, use inf to load all the data regardless of the total time.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Number of time step (partitions)</span><span> = How many time steps are in the dynamic case. Currently all time steps have equal length. Use 1 for static case.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Start time (start)</span><span> = The start time for the data load (seconds). Any measurements before this time will be ignored and will not be loaded.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>End time (end)</span><span> = The end time for the data load (seconds). Any measurements after this time will be ignored and will not be loaded.</span></div><h2  class = 'S4' id = 'H_1F1238BC' ><span>TOF PROPERTIES</span></h2><div  class = 'S5'><span style=' font-weight: bold;'>Total number of TOF bins (TOF_bins)</span><span> = The total  number of TOF bins in the TOF data file or, when using GATE data, also  the number of TOF bins you wish to have in the saved data. Sinogram data ONLY.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Length of each TOF bin (TOF_width)</span><span> = The  width/length of each of the TOF bins (in seconds). Currently all TOF  bins need to be of equal length. This value multiplied with the above  TOF bins should be, at most, the size of the coincidence window.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>TOF offset (TOF_offset)</span><span> = Offset value (in seconds)  for TOF data. In case your TOF bins are not centered in zero use this  value to offset the values towards positive or negative bins. In the  case of Biograph mCT and Vision this is automatically filled for the  list-mode data. If using simulated GATE data, no offset is required in  any case by default nor is this value used to offset the data (this has  to be done manually currently if needed).</span></div><div  class = 'S5'><span style=' font-weight: bold;'>FWHM of the temporal noise/FWHM of the TOF data (TOF_noise_FWHM)</span><span> = This value has two different purposes, first one applies to ALL data  saved by OMEGA while the second only to GATE data. The first purpose is  in naming the TOF data and thus also used when loading the data. In this case it tells the full width at half maximum (FWHM) of the temporal  (TOF) resolution of the data (in seconds). The second purpose is to add  additional temporal noise to the GATE data with the specified FWHM (in  seconds). This is recommended when you have not added any temporal  blurring in GATE itself. If you have added temporal blurring in GATE, it is recommended to set this to zero unless you wish to add additional  temporal noise.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>FWHM of the TOF data (TOF_FWHM)</span><span> = This is the FWHM  of the TOF data (in seconds) used purely for reconstruction purposes and as such does NOT need to be the same as the above value. In fact in  practically all cases the actual FWHM of the data should always differ  from the above one. One way to determine the actual FWHM is to simulate a point source.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Number of TOF bins used in (TOF_bins_used)</span><span> = This  specifies how many TOF bins are actually used during the reconstruction  phase. Currently this has to be either same as the total number of bins  or 1 (in which case all TOF bins are summed together). In the future,  this will allow TOF mashing.</span></div><h2  class = 'S4' id = 'H_4C623800' ><span>MISCELLANEOUS PROPERTIES</span></h2><div  class = 'S5'><span style=' font-weight: bold;'>Name (name) </span><span>= Name of the experiment/simulation/whatever (char). Used for naming purposes.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Precompute necessary data (precompute)</span><span> = If this is true, then some of the obligatory mat-files are computed that are required if the </span><span style=' font-family: monospace;'>options.precompute_lor</span><span> is set to true. Otherwise, there is no need to pass the precomputation step. All mat-files are saved in the </span><span style=' font-family: monospace;'>mat-files</span><span> folder.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Path to the input data (fpath)</span><span> = This is the path to the folder where the input data is (char). All the files for the specified GATE output will be read. E.g. if you set use_ASCII to true, then from the folder specified by fpath, all the .dat files with Coincidences in them will be loaded, for LMF all .ccs files will be loaded and for Root all .root files will be loaded. If you use Windows, use the </span><span style=' font-family: monospace;'>fpat</span><span> value after </span><span style=' font-family: monospace;'>ispc</span><span>, otherwise the one after </span><span style=' font-family: monospace;'>else</span><span>.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Form only sinograms (only_sinos)</span><span> = If this is set to true, then running the m-file only performs steps up to the sinogram formation. I.e. data is loaded and then the sinogram is formed. No reconstructions, normalization coefficient computations or precomputations will be done.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Skip data load (no_data_load)</span><span> = This value can be  used to control whether any data load steps are performed during the  running of a main-file. If set to false, then no data will be loaded  from the GATE ROOT/ASCII/LMF files or list-mode files. All other steps  (precomputation, corrections, reconstruction, etc.) are still performed.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Precompute the observation/system matrix (precompute_obs_matrix)</span><span> = Experimental feature. Setting to true computes the entire system matrix on one go and will most likely require a significant amount of memory (most likely over 100 GB). Supports only MLEM reconstruction. If set to false, then the system matrix is calculated on-the-fly (recommended).</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Only reconstructions (only_reconstruction)</span><span> = Setting to true skips all other steps except the reconstruction phase. Precompute step is also skipped even if set to true. All necessary data is loaded from the previously computed mat-files. This step also overwrites ´only_sinos`.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>How many pixels a LOR traverses (precompute_lor)</span><span> = When true, this option changes the reconstruction process quite radically. First, it requires its own precompute phase. Secondly, it affects greatly on how the system matrix is formed. With this option set to true, the number of pixels each LOR traverses is determined beforehand. For implementation 1 this allows for more efficient memory management, while with other methods the computational speed is enhanced (more for raw data). This step is recommended if you use implementation 1. Improved Siddon’s algorithm with more than 1 rays is not supported when this is true.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Precompute everything (precompute_all)</span><span> = This option causes the prepass phase to compute all mat-files even if they were not selected. E.g. if you use sinogram data, also all precomputations for raw data are done.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Status messages (verbose)</span><span> = If this is set to true, then you will receive occasional status messages and also elapsed time of functions.</span></div><h2  class = 'S4' id = 'H_47E769AC' ><span>RECONSTRUCTION PROPERTIES</span></h2><h3  class = 'S6' id = 'H_D8B1FFCE' ><span style=' font-weight: bold;'>IMPLEMENTATIONS</span></h3><div  class = 'S5'><span>In OMEGA the different ways to compute the different algorithms and projections is referred to as implementations.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Implementation </span><span>= This option determines how the reconstructions and the system matrix are computed. In all cases the system matrix is computed through a mex-file (implementation 1 does have fallback non-mex system matrix formation method, but that is very slow).</span></div><div  class = 'S5'><span>If set to 1, then all the reconstructions will be done purely in MATLAB using nothing but MATLAB commands. Implementation 1 also supports all algorithms available. The system matrix is formed as an actual matrix in a mex-file and then output to MATLAB (when </span><span style=' font-family: monospace;'>precompute_lor = true</span><span>) or as sparse matrix indices (</span><span style=' font-family: monospace;'>precompute_lor = false</span><span>) which are used to form the sparse matrix itself. The latter option is NOT parallel and uses also more memory.</span></div><div  class = 'S5'><span>Implementation 2 is an OpenCL/ArrayFire reconstruction, and everything is done in a mex-file. This is a matrix-free method. In Implementation 2 both the system matrix creation and reconstruction are performed on the selected device. Supports all the same algorithms as implementation 1. AD-MRP prior behaves differently from implementation 1.</span></div><div  class = 'S5'><span>Implementation 3 uses pure OpenCL, i.e. doe not require ArrayFire libraries. This is a matrix-free method. Implementation 3, however, only supports OSEM and MLEM. Unlike implementation 2, implementation 3 does support multi-device computation. The multi-device computation consists using of multiple GPUs (from the same manufacturer) or using GPU + CPU combination (from the same manufacturer).</span></div><div  class = 'S5'><span>If set to 4, then all the computations are done parallel on the CPU by using OpenMP (if supported by the compiler). This is a matrix-free method. This implementation does not require OpenCL and should work on all CPUs. All CPUs/cores are used automatically. All algorithms except MRAMLA and MBSREM are supported. All priors are supported. Only one MLEM-based algorithm and one OS-based algorithm are supported (with one prior) at a time. E.g. you can have MLEM and OSL-OSEM with NLM, but not OSEM and OSL-OSEM.</span></div><div  class = 'S5'><span>In Implementations 2 and 3, the system matrix is created by using single precision numbers, meaning that it can be slightly inaccurate when compared to Implementations 1 and 4 that use double precision numbers.</span></div><div  class = 'S5'><span>On which implementation to select, see </span><a href = "useful_information.html"><span>Recommendations</span></a><span>.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Device (use_device)</span><span> = This determines the device used in implementation 2 and the platform in 4. For implementation 2 the devices mean the actual devices available that are either CPUs, GPUs or accelerators, with GPUs usually being first in the list (0 should use always use your GPU if you have one). Use </span><span style=' font-family: monospace;'>ArrayFire_OpenCL_device_info()</span><span> to determine the devices you have and their respective number. For implementation 4, the platforms are divided by manufacturer. Same manufacturer can have multiple platforms, however, if you have multiple OpenCL runtimes installed. Use </span><span style=' font-family: monospace;'>OpenCL_device_info()</span><span> to see the available platforms and the devices included in each of them. In implementation 4, by default, all the devices associated with certain platform are used except devices that have less than 2 GB of memory. Single device can also be selected with the </span><span style=' font-family: monospace;'>options.cpu_to_gpu_factor</span><span> (see below).</span></div><div  class = 'S5'><span style=' font-weight: bold;'>64 bit atomics (use_64bit_atomics)</span><span> = If true, then 64-bit atomic functions are used. This affects ONLY implementations 2 and 3. If your device does not support 64-bit atomics, the result will be equivalent to setting this to false (with slightly slower overall computations due to extra compilation). Intel hardware usually do not support 64-bit atomics, but AMD or Nvidia GPUs should. Setting this to false will cause slower computations if the 64-bit atomics are supported but can be slightly more reliable and accurate. This is recommended when using GPUs and OpenCL.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Use CUDA</span><span> = If true, uses CUDA code for implementation 2 instead of OpenCL. This affects implementation 2 ONLY. Running </span><span style=' font-family: monospace;'>install_mex</span><span> will automatically try to compile the CUDA code, but the CUDA kernels themselves are compiled at runtime (with nvrtc). Currently this is recommended only when using the improved Siddon as the projector. Orthogonal or volume-based ray tracer will most likely be slower than when using OpenCL code.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>CPU to GPU factor (cpu_to_gpu_factor)</span><span> = Affects only implementation 3. This variable has dual purpose. The first purpose is in heterogeneous computing by delegating more LORs to the GPU part. E.g. if this is set to 2, then the GPU will have 2x more LORs compared to the CPU. Another use is obtained by setting this to 0, when it will use only a single device from the platform. GPUs are prioritized with the GPU having the most memory taken.</span></div><h3  class = 'S6' id = 'H_3D808D43' ><span style=' font-weight: bold;'>PROJECTOR</span></h3><div  class = 'S5'><span style=' font-weight: bold;'>Projector used (projector_type)</span><span> = Three different projectors are available for all implementations. These are the improved Siddon’s algorithm (1), orthogonal distance-based ray tracer (2) and volume-of-intersection based ray tracer (3). Implementation 1, when </span><span style=' font-family: monospace;'>options.precompute_lor = false</span><span> also has the original Siddon’s ray tracer (0). Orthogonal ray tracer allows for both 2.5D or 3D modes (see below). For some additional help on selecting the projector see </span><a href = "useful_information.html"><span>Recommendations</span></a><span>. </span></div><div  class = 'S5'><span style=' font-weight: bold;'>Use PSF</span><span> = Setting this to true will apply point spread function to the reconstruction. This is equivalent to applying an image blurring matrix to the system matrix computation.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>FWHM of the PSF (FWHM) </span><span>= This specifies the full width at half maximum (FWHM) of the Gaussian blurring used in PSF. Separate values are available for all three different dimensions (x, y and z).</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Use deblurring in PSF (use_deblurring)</span><span> = This performs convolution deblurring to the PSF reconstruction AFTER the image reconstruction has fully completed. This is performed for all iterations. The number of iterations for the deblurring is the same as the number of subsets times the number of iterations.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Strip width (tube_width_xy)</span><span> = Affects only orthogonal distance-based ray tracer. This is the maximum distance from the ray to a voxel center allowed in the projector in 2D (x- and y-directions). I.e. the width of the strip of response. If the below value is zero, then this value is used and the orthogonal ray tracer will be run in 2.5D mode. If the below value is non-zero then this value is ignored.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Tube width (tube_width_z)</span><span> = Affects only orthogonal distance-based ray tracer. This is the maximum distance from the ray to a voxel center allowed in the projector in 3D (x-, y- and z-directions). I.e. the width and height of the tube of response. Only square tubes are allowed; if this is non-zero, any value in </span><span style=' font-family: monospace;'>tube_width_xy</span><span> is ignored.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Tube radius</span><span> = Affects only volume-of-intersection based ray tracer. This is the radius of the tube of response, which is a cylinder in this case.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Voxel radius</span><span> = Affects only volume-of-intersection based ray tracer. Relative voxel radius of the spherical voxels used in the projector 3. If 1, then the spherical voxel will be just large enough to completely contain the original voxel. Lower values cause smaller voxels while larger values give larges ones.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Number of transaxial rays (n_rays_transaxial)</span><span> = Affects only improved Siddon’s algorithm when </span><span style=' font-family: monospace;'>options.precompute_lor = false</span><span> and using any implementation other than 1 (i.e. works with implementations 2, 3 and 4). This is the number of rays used in the improved Siddon in the transaxial dimension. Any number of rays can be used. The total number of rays is </span><span style=' font-family: monospace;'>n_rays_axial</span><span> * </span><span style=' font-family: monospace;'>n_rays_transaxial</span><span>.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Number of axial rays (n_rays_axial)</span><span> = Affects only improved Siddon’s algorithm when </span><span style=' font-family: monospace;'>options.precompute_lor = false</span><span> and using any implementation other than 1 (i.e. works with implementations 2, 3 and 4). This is the number of rays used in the improved Siddon in the axial dimension. Any number of rays can be used. The total number of rays is </span><span style=' font-family: monospace;'>n_rays_axial</span><span> * </span><span style=' font-family: monospace;'>n_rays_transaxial</span><span>.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Accelerate reconstruction (apply_acceleration)</span><span> = Affects only improved Siddon when TOF is enabled or orthogonal distance-based and volume ray tracers, in all cases only with  implementations 2 and 3. If set to true, intermediate values are stored in memory. This accelerates the computations by about 30%, but will lead to increased memory cost on GPUs. Can also cause CL_OUT_OF_HOST_MEMORY errors. Has less significance when using TOF data.</span></div><h3  class = 'S6' id = 'H_5E96EC1E' ><span style=' font-weight: bold;'>RECONSTRUCTION SETTINGS</span></h3><div  class = 'S5'><span style=' font-weight: bold;'>Number of iterations (Niter)</span><span> = The number of iterations.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Number of subsets (subsets)</span><span> = In subset methods, this value determines the number of subsets that the sinogram/raw data is divided into. Depending on the data type used (sinogram or raw), there are several different ways to select the subsets (see below </span><span style=' font-family: monospace;'>subset_type</span><span>).</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Type of subset division (subset_type)</span><span> = Six different methods, numbered from 1 to 6, to sort the measurements into subsets.</span></div><div  class = 'S5'><span>1 = Every nth column is taken in order (sinogram only), e.g. once the end of the column is reached, indexing starts from the first column again in the next row.</span></div><div  class = 'S5'><span>2 = Every nth row (both sinogram and raw data, default in raw data), once the end of the row is reached, indexing starts from the first row again in the next column.</span></div><div  class = 'S5'><span>3 = The measurements are taken randomly, by default uses </span><span style=' font-family: monospace;'>randperm</span><span>, but can use the file exchange </span><span style=' font-family: monospace;'>Shuffle</span><span> (see below) for faster speed and better memory use.</span></div><div  class = 'S5'><span>4 = Every nth column from the sinogram, takes an entire column and then jumps n columns to the next.</span></div><div  class = 'S5'><span>5 = Every nth row from the sinogram, takes an entire row and then jumps n row to the next.</span></div><div  class = 'S5'><span>6 = Uses n number of angles to form each subset. First the LORs are sorted according to the angle they create with the (positive) x-axis. Then </span><span style=' font-family: monospace;'>n_angles</span><span> (see below) angles are grouped together to form one subset. E.g. if </span><span style=' font-family: monospace;'>n_angles = 2</span><span> then angles 0 and 1 form one subset, 2 and 3 another, etc. For 2D slices there will be a total of 180°/n</span><span>angles</span><span> subsets and 360°/n</span><span>angles</span><span> for 3D. This method is explained in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[4</span></a><span>].</span></div><div  class = 'S5'><span>7 = Uses golden angle sampling to select the subsets. Each sinogram uses the same number of angles and the same angles, the golden angle sampling is thus performed on single sinogram basis. The next angle is selected such that the difference is roughly the same as the golden angle (approx. 111.246°). Currently this subset sampling is supported only by sinogram data.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Number of angles (n_angles)</span><span> = If the above method 6 is selected, this value is used to determine how many angles are used in one subset.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Initial value (x0)</span><span> = The initial value of all of the reconstruction methods. In dynamic studies all the time steps have the same initial value.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Epsilon value (epps)</span><span> = This small value is added to divisions to prevent division by zero.</span></div><h3  class = 'S6' id = 'H_1570E9D8' ><span style=' font-weight: bold;'>MISC SETTINGS</span></h3><div  class = 'S5'><span style=' font-weight: bold;'>Use Shuffle (use_Shuffle)</span><span> = Whether the MATLAB file exchange code </span><a href = "https://se.mathworks.com/matlabcentral/fileexchange/27076-shuffle"><span style=' text-decoration: underline;'>Shuffle</span></a><span> is used. Applies only to </span><span style=' font-family: monospace;'>subset_type = 3</span><span>. Speeds up the pre-process a bit and also uses less memory.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Use FSparse (use_fsparse)</span><span> = Whether </span><a href = "https://github.com/stefanengblom/stenglib"><span style=' text-decoration: underline;'>FSparse</span></a><span> is used. Only used if precompute_lor is set to false. Suggested only for MATLAB 2019b and earlier.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>MRP-type prior without normalization (med_no_norm)</span><span> = Normally MPR-type priors (MRP, FMH, L-filter, AD and weighted mean) are of the form (λ - M</span><span>b</span><span>)/M</span><span>b</span><span>. If this is set to true, then the denominator (normalization) is removed (i.e. (λ - M</span><span>b</span><span>)/1).</span></div><h3  class = 'S6' id = 'H_A56A75EF' ><span style=' font-weight: bold;'>RECONSTRUCTION ALGORITHMS</span></h3><div  class = 'S5'><span style=' font-weight: bold;'>Use MLEM/OSEM/etc.</span><span> = When any of these are set to true, the specific algorithm is computed. This is dependent on the selected implementation. Separate sections are for the maximum likelihood-based methods, maximum a posteriori methods and priors. MAP methods require at least one prior and priors require at least one MAP method.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>ACOSEM properties</span><span> = Only the acceleration factor can be adjusted. See the original article for details.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>MRAMLA/MBSREM properties</span><span> = Relaxation parameter and the upper bound can be adjusted.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>RAMLA/BSREM properties</span><span> = Relaxation parameter can be adjusted.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>ROSEM properties</span><span> = Relaxation parameter can be adjusted.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>DRAMA properties</span><span> = Parameters α, β and β</span><span>0</span><span> can be adjusted. See [4], e.g. eq. (20).</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Neighborhood properties</span><span> = Adjust how many neighboring voxels are taken into account (</span><span style=' font-family: monospace;'>Ndx</span><span>, </span><span style=' font-family: monospace;'>Ndy</span><span> and </span><span style=' font-family: monospace;'>Ndz</span><span>). Used in MRP, quadratic prior, FMH, L-filter, weighted mean and NLM.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>MRP properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Quadratic prior properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span>Custom weights can be input. The weights vector should be of size </span><span style=' font-family: monospace;'>(Ndx*2+1) * (Ndy*2+1) * (Ndz*2+1)</span><span> and the middle value inf.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>L-filter properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span>Custom weights can be input. The weights vector should be of size </span><span style=' font-family: monospace;'>(Ndx*2+1) * (Ndy*2+1) * (Ndz*2+1)</span><span> (middle value is NOT inf).</span></div><div  class = 'S5'><span>If custom weights are not given, the </span><span style=' font-family: monospace;'>options.oneD_weights</span><span> determines whether 1D (true) or 2D (false) weighting scheme is used. In 1D case, if </span><span style=' font-family: monospace;'>(Ndx*2+1) * (Ndy*2+1) * (Ndz*2+1)</span><span> = 3, = 9 or = 25 then the weights are exactly as in literature </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[5</span></a><span>]. Otherwise the pattern follows a </span><a href = "https://en.wikipedia.org/wiki/Laplace_distribution"><span style=' text-decoration: underline;'>Laplace distribution</span></a><span>. In 2D case, the weights follow Laplace distribution, but are also weighted based on the distance of the neighboring voxel from the center voxel. For Laplace distribution, the mean value is set to 0 and b = 1/sqrt(2). The weights are normalized such that the sum equals 1.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>FMH properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span>Custom weights can be input. The weights vector should be of size </span><span style=' font-family: monospace;'>[Ndx*2+1, 4]</span><span> if </span><span style=' font-family: monospace;'>Nz = 1</span><span> or </span><span style=' font-family: monospace;'>Ndz = 0</span><span> or ´[Ndx*2+1, 13]´ otherwise. The weight for the center pixel should also be the middle value when the weight matrix is in vector form. The weights are normalized such that the sum equals 1.</span></div><div  class = 'S5'><span>If custom weights are not provided, then the </span><span style=' font-family: monospace;'>options.fmh_center_weight</span><span> parameter is needed. Default value is 4 as in the original article </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[6</span></a><span>].</span></div><div  class = 'S5'><span style=' font-weight: bold;'>Weighted mean properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span>Custom weights can be input. The weights vector should be of size </span><span style=' font-family: monospace;'>(Ndx*2+1) * (Ndy*2+1) * (Ndz*2+1)</span><span>.</span></div><div  class = 'S5'><span>If custom weights are not provided, then the </span><span style=' font-family: monospace;'>options.weighted_center_weight</span><span> parameter is needed. Default value is 4 as in the original article </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[6</span></a><span>]</span></div><div  class = 'S5'><span style=' font-weight: bold;'>TV properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.TVsmoothing</span><span> is a "smoothing" parameter that also prevents zero in square root (it is summed to the square root values). (variable β in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[7</span></a><span>] eq. 11 and </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>] eq. 13).</span></div><div  class = 'S5'><span>If </span><span style=' font-family: monospace;'>options.TV_use_anatomical = true</span><span>, then an anatomical prior is used in TV regularization. </span><span style=' font-family: monospace;'>options.TV_reference_image</span><span> is the name of the file containing the anatomical reference images (image size needs to be the same as the reconstructed images). The reference images need to be the only variable in the file.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.TVtype</span><span> controls the type of TV regularization used. For </span><span style=' font-family: monospace;'>TVtype = 1</span><span> see </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[7</span></a><span>], </span><span style=' font-family: monospace;'>TVtype = 2</span><span> </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>] and </span><span style=' font-family: monospace;'>TVtype = 3</span><span> </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[9</span></a><span>]. If no anatomical prior is used, then type 1 and 2 are the same. Type 3 uses the same weights as quadratic prior.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.T</span><span> is the edge threshold parameter in type 1 (variable C in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[7</span></a><span>], see e.g. eq. 8), scale parameter for side information in type 2 (variable γ in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>], see eq. 13), weight parameter for anatomical information in type 2 (variable η in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[9</span></a><span>], see eq. 11).</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.C</span><span> is the weight of the original image in type 3 (variable δ in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[9</span></a><span>], see e.g. eq. 11).</span></div><div  class = 'S5'><span>All TV types are isotropic.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>MRP-AD properties</span><span> = In MRP-AD, the median filtered image is replaced with anisotropic diffusion smoothed image. I.e. if M</span><span>AD</span><span> is the anisotropic diffusion smoothed image, the prior is (λ - M</span><span>AD</span><span>)/M</span><span>AD</span><span>. Using this with implementation 1 requires the Image Processing Toolbox. This prior does not work on Octave.</span></div><div  class = 'S5'><span>Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.TimeStepAD</span><span> is the time step for the AD filter (implementation 2 only). More information </span><a href = "http://arrayfire.org/docs/group__image__func__anisotropic__diffusion.htm"><span style=' text-decoration: underline;'>here</span></a><span>.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.KAD</span><span> is the conductivity/connectivity parameter. More information </span><a href = "https://se.mathworks.com/help/images/ref/imdiffusefilt.html"><span style=' text-decoration: underline;'>here</span></a><span> and </span><a href = "http://arrayfire.org/docs/group__image__func__anisotropic__diffusion.htm"><span style=' text-decoration: underline;'>here</span></a><span>.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.NiterAD</span><span> number of iterations for the AD smoothing part.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.FluxType</span><span> is the flux/conduction type. Available methods are Exponential (1) and Quadratic (2). E.g. </span><span style=' font-family: monospace;'>options.FluxType = 2</span><span> uses quadratic.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.DiffusionType</span><span> is the diffusion type (implementation 2 only). Available methods are Gradient (1) and Modified curvature (2). E.g. </span><span style=' font-family: monospace;'>options.DiffusionType= 2</span><span> uses modified curvature.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>APLS properties</span><span> = Using asymmetric parallel level sets requires the use of anatomic prior. Without anatomical prior it functions as TV types 1 and 2.</span></div><div  class = 'S5'><span>Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.eta</span><span> is a scaling parameter in regularized norm (see variable η in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>]).</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.APLSsmoothing</span><span> is a "smoothing" parameter that also prevents zero in square root (it is summed to the square root values). Has the same function as the </span><span style=' font-family: monospace;'>TVsmoothing</span><span> parameter (see </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>] eq. 9).</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.APLS_reference_image</span><span> is the name of the file containing the anatomical reference images (image size needs to be the same as the reconstructed images). The reference images need to be the only variable in the file.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>TGV properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.betaTGV</span><span> is the first weighting value for the TGV (see parameter α</span><span>1</span><span> in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[10</span></a><span>]).</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.alphaTGV</span><span> is the second weighting value for the TGV (see parameter α</span><span>0</span><span> in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[10</span></a><span>]). Weight for the symmetrized derivative.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.NiterTGV</span><span> number of iterations for the TGV smoothing part.</span></div><div  class = 'S5'><span style=' font-weight: bold;'>NLM properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S5'><span style=' font-family: monospace;'>options.sigma</span><span> is the filtering parameter (see parameter h in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[11</span></a><span>] or σ in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[12</span></a><span>], eq. 6).</span></div><div  class = 'S5'><span>The patch radius is controlled with parameters </span><span style=' font-family: monospace;'>options.Nlx</span><span>, </span><span style=' font-family: monospace;'>options.Nly</span><span> and </span><span style=' font-family: monospace;'>options.Nlz</span><span>. The similarity is investigated in this area.</span></div><div  class = 'S5'><span>The strength of the Gaussian weighting (standard deviation) of the weights can be adjusted with </span><span style=' font-family: monospace;'>options.NLM_gauss</span><span>.</span></div><div  class = 'S5'><span>If </span><span style=' font-family: monospace;'>options.NLM_use_anatomical = true</span><span> then an anatomical reference image is used in the similarity search of the neighborhood. Normally the original image is used for this. </span><span style=' font-family: monospace;'>options.NLM_reference_image</span><span> is the name of the anatomical reference data file. The reference images need to be the only variable in the file.</span></div><div  class = 'S5'><span>If you wish to use non-local total variation, set </span><span style=' font-family: monospace;'>options.NLTV = true</span><span>. This overwrites the MRP selection (see below). All other NLM options apply.</span></div><div  class = 'S5'><span>NLM can also be used like MRP (and MRP-AD) where the median filtered image is replaced with NLM replaced image. This is achieved by setting </span><span style=' font-family: monospace;'>options.NLM_MRP = true</span><span>. This is computed without normalization ((λ - M</span><span>NLM</span><span>)/1). All other NLM options apply.</span></div><h2  class = 'S4' id = 'H_EC5FFC41' ><span>LOAD SCATTER DATA</span></h2><div  class = 'S5'><span>In this section, the user will be prompted to load the scatter correction data if </span><span style=' font-family: monospace;'>options.scatter_correction = true</span><span>.</span></div><h2  class = 'S4' id = 'H_AD984B83' ><span>CUSTOM DETECTOR COORDINATES</span></h2><div  class = 'S5'><span>Here you can input custom detector coordinates. These enable the use of non-cylindrical devices or continuous detectors (e.g. CPET in GATE). Transaxial coordinates are specified as </span><span style=' font-family: monospace;'>options.x</span><span> and </span><span style=' font-family: monospace;'>options.y</span><span> while axial are </span><span style=' font-family: monospace;'>options.z</span><span> (or alternatively </span><span style=' font-family: monospace;'>options.z_det</span><span>). Simply save your custom coordinates to the specified </span><span style=' font-family: monospace;'>x</span><span>, </span><span style=' font-family: monospace;'>y</span><span> and </span><span style=' font-family: monospace;'>z</span><span> variables in the </span><span style=' font-family: monospace;'>options</span><span> struct. For sinogram data, the </span><span style=' font-family: monospace;'>x</span><span> and </span><span style=' font-family: monospace;'>y</span><span> sizes should be </span><span style=' font-family: monospace;'>[sinogram_elements 2]</span><span> and </span><span style=' font-family: monospace;'>z</span><span> </span><span style=' font-family: monospace;'>[number_of_sinograms 2]</span><span>. For raw data </span><span style=' font-family: monospace;'>[detectors_per_ring 1]</span><span> and</span><span style=' font-family: monospace;'> [number_of_rings 1]</span><span>, respectively. </span></div><div  class = 'S5'><span>It is also possible to use pure event-by-event list-mode reconstruction with custom coordinates. In this case each event should have its own detector coordinates and as such each coordinate should be of size </span><span style=' font-family: monospace;'>[total_events 2]</span><span>. Currently only implementation 4 supports event-by-event reconstruction and it is also ONLY supported with custom detectors.</span></div><h2  class = 'S4' id = 'H_CC3384E0' ><span>Load measurement data</span></h2><div  class = 'S5'><span>The function </span><a href = "loadMeasurementData.m"><span>loadMeasurementData</span></a><span> allows you to load measurement data in different formats. Curently supported are  MATLAB-data, NIfTI, Analyze 7.5, DICOM, Interfile, MetaImage, and binary data. Analyze requires </span><a href = "https://se.mathworks.com/matlabcentral/fileexchange/8797-tools-for-nifti-and-analyze-image"><span style=' text-decoration: underline;'>Tools for NIfTI and ANALYZE image</span></a><span> from MathWorks file exchange, NIfTI either image processing toolbox or  Tools for NIfTI and ANALYZE image and DICOM support requires image  processing toolbox on MATLAB and dicom package on Octave (untested on  Octave).</span></div><div  class = 'S5'><span>Binary data can be of any type, but if binary data other than int32 is used, then it has to be specified. E.g. </span><span style=' font-family: monospace;'>options = loadMeasurementData(options,'uint16')</span><span> loads 16-bit unsigned integer data. If the binary data has a header of </span><span style=' font-style: italic;'>n</span><span> bytes, it can be skipped by specifying the number of bytes (e.g. </span><span style=' font-family: monospace;'>options = loadMeasurementData(options,'uint16', n)</span><span>. If the header is at the end of the file, using a negative value will ignore the last </span><span style=' font-style: italic;'>n</span><span> bytes. </span></div><div  class = 'S5'><span>The data is saved in the </span><span style=' font-family: monospace;'>options</span><span> structure, either in </span><span style=' font-family: monospace;'>SinM</span><span> (sinogram data) or </span><span style=' font-family: monospace;'>coincidences</span><span> (raw data).</span></div><div  class = 'S5'><span>Raw data can only be used with MATLAB-data (mat-file).</span></div><div  class = 'S5'><span>DICOM data currently supports only 2D slices.</span></div><div  class = 'S5'><span>The user should also always check that the output measurement data looks correct (e.g. </span><span style=' font-family: monospace;'>imagesc(options.SinM(:,:,30))</span><span>).</span></div><h2  class = 'S4' id = 'H_0AC208EF' ><span>DEPTH OF INTERACTION</span></h2><div  class = 'S5'><span>This section is commented by default, but can be used to specify a  depth of interaction value (millimeters). By default this is set to 0,  i.e. it is assumed that all the interactions occur at the surface of the detector crystals. What this value changes is the depth of where the  interactions are assumed to occur, i.e. it only changes the detector  coordinates such that the transaxial coordinates are "deeper" in the  crystal. Having too large values can cause issues with the  reconstruction.</span></div><div  class = 'S5'><span>This value does not affect custom detector coordinates.</span></div></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% main_PET
%% SCANNER PROPERTIES
% The first section contains the device parameters and is included in both files. 
% These include (name in parenthesis is the MATLAB variable name):
% 
% *Blocks per ring (blocks_per_ring)* = This is the number of "blocks" in your 
% scanner on each ring. If you have cylindrical PET geometry, then this should 
% be the number of R-sectors/modules per ring. For ECAT it is the number of blocks/R-sectors. 
% If you need more help, see the included example (# R E P E A T R S E C T O R).
% 
% *Linear multiply (linear_multip)* = The repeater number in GATE. See the example 
% on how this compares with the GATE macros (# R E P E A T M O D U L E). For non-GATE 
% it is the number of blocks in axial direction.
% 
% *Transaxial multiplier (transaxial_multip)* = This is the number of times 
% above blocks per ring needs to be multiplied to get the total number of blocks 
% per ring. Most often this is simply 1.
% 
% *Crystals per block, transaxial direction (cryst_per_block)* = The number 
% of crystals on the transaxial side of each block. In the  example the crystals 
% are in 8x8 grids meaning this value is 8.
% 
% *Crystals per block, axial direction (cryst_per_block_axial)* = The number 
% of crystals on the axial side of each block. In the  example the crystals are 
% in 8x8 grids meaning this value is 8. Using  20x10 blocks would mean this value 
% would be 10.
% 
% *Crystal pitch x/y-direction (cr_p)* = Crystal pitch in the x- and y-directions. 
% I.e. the distance between the centers of adjacent crystals.
% 
% *Crystal pitch z-direction (cr_pz)* = Same as above, but in z-direction.
% 
% *Bore diameter (diameter)* = Diameter of the scanner bore. I.e. distance between 
% perpendicular crystals.
% 
% *Transaxial field-of-view (FOVa_x)* = Transaxial field-of-view (x-direction), 
% i.e. the reconstructed image location.
% 
% *Transaxial field-of-view (FOVa_y)* = Transaxial field-of-view (y-direction), 
% i.e. the reconstructed image location.
% 
% *Axial FOV (axial_fov)* = Same as above, but in axial (z) direction.
% 
% *Pseudo rings (pseudot)* = The number of pseudo rings. Use 0 or [] if none.
% 
% *Detectors per ring (det_per_ring)* = Number of detectors per ring without 
% pseudo detectors. Can be automatically determined as in the example.
% 
% *Detectors per ring w/ pseudo detectors (det_w_pseudo)* = Same as above, but 
% with pseudo detectors included. Since pseudo detectors are usually included 
% in each detector block, you can determine this number by adding +1 to crystals 
% per block. E.g. |options.det_w_pseudo = options.blocks_per_ring*(options.cryst_per_block 
% + 1);|
% 
% *Total number of rings (rings)* = Number of crystal rings. Can be computed 
% automatically.
% 
% *Total number of detectors (detectors)* = Can be automatically determined.
% 
% *Machine name* = The name of your scanner. Used for naming purposes.
%% IMAGE PROPERTIES
% *Image size in x-direction (Nx)* = If the total image size is 128x128x63 then 
% this is 128. 
% 
% *Image size in y-direction (Ny)* = If the total image size is 128x128x63 then 
% this is 128. 
% 
% *Image size in z-direction (Nz)* = If the total image size is 128x128x63 then 
% this is 63.
% 
% *Flip image* = Flips the image in vertical direction (before reconstruction, 
% e.g. flips the detector coordinates).
% 
% *Image rotation (offangle)* = How much is the image rotated. This is performed 
% before reconstruction and shifts the detector coordinates with the specified 
% amount. Due to this, this should be a certain percentage of the total number 
% of detectors on one ring (|det_per_ring|).
%% RAW DATA PROPERTIES
% *Use raw data (use_raw_data)* = Set this to true if  you want to use raw data, 
% i.e. data that has not been compressed at all. This step requires its own precompute 
% phase if |options.precompute_lor = true|. The raw data in OMEGA is formatted 
% such that the saved measurement data is a vector formed from a lower triangular 
% matrix. This lower  triangular matrix is extracted from a matrix of size |total_number_of_detectors 
% x total_number_of_detectors|. The matrix contains all the possible line of response 
% combinations,  e.g. between detector 1 and detector 3. Since the LOR between 
% detectors 1 and 3 is the same as the LOR between detectors 3 and 1, the upper  
% triangular part is added to the lower triangular part before the lower  triangular 
% part is extracted. The raw date is always saved in cell  format, regardless 
% of the number of time steps. Non-cell data should work, but cell data is recommended. 
% TOF data is currently not supported  with raw data.
% 
% *Store raw data (store_raw_data)* = If this is set to  false, then raw data 
% is not separately stored during data import (e.g.  using GATE or Biograph list-mode 
% data). If you are using your own data, ignore this.
% 
% *Maximum ring difference (ring_difference_raw)* = The maximum distance (in 
% rings) from which LORs are included, when using raw data.
% 
% *Increasing raw data sampling (sampling_raw)* = Interpolates additional rows 
% and columns to the raw data. If this is set to two, it will double the size 
% of the raw data in each dimension. Has to be 1 or divisible by 2. Can be used 
% to prevent aliasing artifacts, but will increase memory usage and computation 
% time.
% 
% *Sampling interpolation type (sampling_interpolation_method_raw)* = Specifies 
% the interpolation method used for increased sampling. All methods supported 
% by |interp2| are available.
%% SINOGRAM PROPERTIES
% *Span (span) *= The span factor (also called axial compression). The higher 
% the number, the greater the compression of oblique LORs).
% 
% *Maximum ring difference (ring_difference)* = The maximum distance (in rings) 
% from which oblique LORs are included.
% 
% *Number of angles (Nang)* = How many different angles (tangential positions) 
% are in the sinogram. The angles depict the angle between the LOR and x-axis. 
% Is mashing is used, this value should be the final sinogram size AFTER mashing.
% 
% *Number of views (Ndist)* = How many different views (angular positions) are 
% in the sinogram. The views are the shortest (orthogonal) distance between the 
% LOR and the origin.
% 
% *Segment table (segment_table)* = Oblique sinograms are divided into groups 
% specified by the segment table. This value depends on the span value and can 
% be automatically computed as in the example.
% 
% *Total number of sinograms (TotSinos)* = The total number of sinograms. Can 
% be obtained by summing the segment table.
% 
% *Number of sinograms used in reconstruction (NSinos)* = Less sinograms can 
% be used in the reconstruction process itself (e.g. only parallel LORs). This 
% is an experimental feature. Only the N first sinograms can be used, e.g. you 
% can’t pick only 100 last sinograms, but you can pick the first 100.
% 
% *Distance side (ndist_side)* = When Ndist value is even, then one extra view 
% has to be taken either from the "negative" or "positive" side. With this you 
% can specify whether this is from the "negative" (+1) or "positive" (-1). If 
% you are unsure what value to use, use the default value. This varies from device 
% to device. If you compare the sinogram produced by OMEGA to the scanner generated 
% one and see a slight shift, then this parameter is most likely incorrect.
% 
% *Increasing sinogram sampling (sampling)* = The first dimension of the sinogram 
% (views) can be increased with this value. For example setting sampling to 2, 
% would double the size of the first dimension. The extra values are interpolated 
% (see below). This can be used to prevent aliasing artifacts. Value should be 
% either 1 or divisible by two.
% 
% *Sampling interpolation type (sampling_interpolation_method)* = Specifies 
% the interpolation method used for increased sampling. All methods supported 
% by |interp1| are available.
% 
% *Fill sinogram gaps (fill_sinogram_gaps)* = If pseudo detectors are used, 
% setting this to true will fill the gaps caused by them. Experimental feature.
% 
% *Gap filling method (gap_filling_method)* = What method is used to fill the 
% gaps. Available methods are the MATLAB’s built-in |fillmissing| or alternatively 
% <https://se.mathworks.com/matlabcentral/fileexchange/4551-inpaint_nans |inpaint_nans|> 
% from file exchange. Must be in char format.
% 
% *Interpolation method (fillmissing) (interpolation_method_fillmissing)* = 
% Which of the interpolation methods are used when using |fillmissing| for gap 
% filling. See the help file on |fillmissing| for more information. Input is char, 
% e.g. |'linear'|.
% 
% *Interpolation method (inpaint_nans) (interpolation_method_inpaint)* = Which 
% of the interpolation methods are used when using |inpaint_nans| for gap filling. 
% See the help on |inpaint_nans| for more information. Input is a number.
%% CORRECTIONS
% *Randoms correction (randoms_correction)* = If set to true, then the delayed 
% coincidences are stored during data load (GATE and Inveon data) and used for 
% randoms correction during sinogram formation or image reconstruction. For other 
% data, the user will be prompted for the randoms correction data when it is required. 
% The data (mat-file) should then include a variable named SinDelayed (sinogram 
% data), delayed_coincidences (raw_data) or be the only variable in the file.
% 
% *Variance reduction (variance_reduction)* = If true, performs variance reduction 
% to randoms data before corrections. The variance reduction uses 3D fan sum algorithm 
% [<https://github.com/villekf/OMEGA/wiki/Function-help#references 3>].
% 
% *Randoms smoothing (randoms_smoothing)* = If true, performs smoothing to the 
% randoms data before corrections. The smoothing is a fixed 8x8 moving mean smoothing. 
% The window size can be adjusted in the original function |randoms_smoothing|. 
% For sinogram data, the smoothing is done when the randoms sinogram is formed. 
% Activating smoothing later and performing the corrections during reconstructions 
% does NOT perform smoothing unless the sinogram formation step is done as well.
% 
% *Scatter correction (scatter_correction)* = If set to true, scatter correction 
% will be performed during sinogram formation or image reconstruction. In all 
% cases, the user will be prompted for the scatter correction data. The input 
% data (mat-file) must include a variable named SinScatter (sinogram data), scattered_coincidences 
% (raw data) or be the only variable in the file. In the first two cases, the 
% data can be scatter data created by OMEGA from a different MC scatter correction 
% simulation.
% 
% *Scatter variance reduction (scatter_variance_reduction)* = If true, performs 
% variance reduction to scatter data before corrections. 
% 
% *Normalize scatter (normalize_scatter)* = If set to true, performs normalization 
% correction to the scatter correction data before the reconstruction phase. This 
% phase is ignored if the corrections are applied directly to the measured data 
% in which case it will be subtracted before the normalization correction.
% 
% *Scatter smoothing (scatter_smoothing)* = If true, performs smoothing to the 
% scatter data before corrections. The smoothing is a fixed 8x8 moving mean smoothing. 
% The window size can be adjusted in the original function |randoms_smoothing|.
% 
% *Subtract scatter data (subtract_scatter)* = If true, then the scatter data 
% are subtracted from the sinogram/raw data or the forward projection, depending 
% on whether the corrections are applied before reconstruction or during it. If 
% false, the scatter data is instead multiplied with the sinogram/raw data or 
% the system matrix elements. The multiplication case can be considered as the 
% scatter data included in the system matrix itself as a diagonal matrix, where 
% the input scatter data is placed on the diagonal.
% 
% *Attenuation correction (attenuation_correction)* = If true, performs attenuation 
% correction during the reconstruction. You need attenuation images scaled to 
% 511 keV for this. CT images can be scaled with the function |attenuationCT_to_511| 
% provided with OMEGA. DICOM CT images might automatically scale with |create_atten_matrix_CT|, 
% but currently it has been tested only with one scanner. |attenuation122_to_511| 
% can be used to scale 122 keV blank/transmission data to 511 keV, i.e. GE-68 
% attenuation measurement.
% 
% *Attenuation datafile (attenuation_datafile)* = Name of the data file containing 
% the (scaled) attenuation images. Use full path if it is not on MATLAB/Octave 
% path. This is required if the attenuation correction is applied. One exception 
% is if you are using Inveon data and have an atn-file, you can then leave this 
% one blank and will be asked separately to input the atn-data.
% 
% *Compute normalization coefficients (compute_normalization)* = If true and 
% the main-file is run, then the input data will be used to compute the normalization 
% coefficients. Currently supported normalization correction components are axial 
% geometric correction (axial block profile and geometric factors), detector efficiency 
% (fan-sum algorithm for both sinogram and raw data or SPC for raw data), transaxial 
% block profile correction and transaxial geometric correction. Supports both 
% raw data or sinogram data. Transaxial geometric correction is not recommended 
% for objects that do not cover the entire FOV (or rather do not irradiate the 
% entire FOV region). The corresponding function will output the corrected measurement 
% data, the normalization matrix (multiplying this with the original measurement 
% data gives the same corrected data) and each individual correction factors. 
% Computation of the normalization coefficients follows the book [<https://github.com/villekf/OMEGA/wiki/Function-help#references 
% 1>]. Fan-sum algorithm, used in computing the detector efficiencies, can be 
% found from [<https://github.com/villekf/OMEGA/wiki/Function-help#references 
% 2>].
% 
% *Normalization options (normalization_options)* = A vector representing all 
% the four possible normalization correction steps that can be performed (see 
% above). 1 means that the method is included, 0 that it is excluded. E.g. the 
% default setting |[1 1 1 0] |computes axial geometric, detector efficiency and 
% transaxial block profile corrections, but not transaxial geometric correction.
% 
% *Phantom radius (normalization_phantom_radius)* = If the source phantom is 
% cylinder that is smaller than the FOV, input the radius of the cylinder here 
% (in cm). For an object encompassing the entire FOV, use an empty array |[]| 
% or |inf|.
% 
% *Attenuation (phantom_attenuation) *= Specify the attenuation coefficient 
% of the phantom material used for normalization measurements. If no attenuation 
% is needed then use an empty array []. If the phantom radius is inf, this value 
% is ignored.
% 
% *Scatter correction (normalization_scatter_correction)* = If a phantom, that 
% is smaller than the FOV, is used, compute the scatter correction for the data. 
% Requires the above cylinder radius and only supports sinogram data. For GATE 
% data it is recommended to use trues in the normalization correction in order 
% to skip this phase.
% 
% *Apply normalization (normalization_correction)* = Once the normalization 
% correction coefficients have been separately computed, turning this to true 
% will enable them in the sinogram formation or in the reconstruction phase.
% 
% *Apply user normalization (use_user_normalization)* = If this is true, then 
% the user will be prompted for the normalization correction data. This file can 
% be either a mat-file with one variable (the normalization coefficients, such 
% that normalized_data = un_normalized_data * normalization) or an Inveon PET 
% .nrm-file. In the latter case, the file needs to be exactly as output by the 
% Siemens software.
% 
% *Arc correction (arc_correction)* = Applies arc correction to the input sinogram 
% data. For the interpolation method, see below.
% 
% *Arc correction interpolation (arc_interpolation)* = Method used in the arc 
% correction interpolation. All methods supported either by |scatteredInterpolant| 
% or |griddata| are available. By default |scatteredInterpolant| is used, but 
% if the method is not supported by it |gridddata| is used. |griddata| is also 
% used if |scatteredInterpolant| is not found.
% 
% *Apply corrections during reconstruction (corrections_during_reconstruction)* 
% = If set to true, then the corrections are applied during the reconstruction 
% phase. I.e. uncorrected sinogram/raw data is automatically loaded and used in 
% the reconstruction process. The corrections data is also automatically loaded 
% (assuming it has been previously created). Smoothing and/or variance reduction 
% needs to be performed beforehand.
%% DYNAMIC IMAGING PROPERTIES
% *Total time (tot_time)* = The total time of the experiment (seconds). If you 
% have a static experiment, use inf to load all the data regardless of the total 
% time.
% 
% *Number of time step (partitions)* = How many time steps are in the dynamic 
% case. Currently all time steps have equal length. Use 1 for static case.
% 
% *Start time (start)* = The start time for the data load (seconds). Any measurements 
% before this time will be ignored and will not be loaded.
% 
% *End time (end)* = The end time for the data load (seconds). Any measurements 
% after this time will be ignored and will not be loaded.
%% TOF PROPERTIES
% *Total number of TOF bins (TOF_bins)* = The total  number of TOF bins in the 
% TOF data file or, when using GATE data, also  the number of TOF bins you wish 
% to have in the saved data. Sinogram data ONLY.
% 
% *Length of each TOF bin (TOF_width)* = The  width/length of each of the TOF 
% bins (in seconds). Currently all TOF  bins need to be of equal length. This 
% value multiplied with the above  TOF bins should be, at most, the size of the 
% coincidence window.
% 
% *TOF offset (TOF_offset)* = Offset value (in seconds)  for TOF data. In case 
% your TOF bins are not centered in zero use this  value to offset the values 
% towards positive or negative bins. In the  case of Biograph mCT and Vision this 
% is automatically filled for the  list-mode data. If using simulated GATE data, 
% no offset is required in  any case by default nor is this value used to offset 
% the data (this has  to be done manually currently if needed).
% 
% *FWHM of the temporal noise/FWHM of the TOF data (TOF_noise_FWHM)* = This 
% value has two different purposes, first one applies to ALL data  saved by OMEGA 
% while the second only to GATE data. The first purpose is  in naming the TOF 
% data and thus also used when loading the data. In this case it tells the full 
% width at half maximum (FWHM) of the temporal  (TOF) resolution of the data (in 
% seconds). The second purpose is to add  additional temporal noise to the GATE 
% data with the specified FWHM (in  seconds). This is recommended when you have 
% not added any temporal  blurring in GATE itself. If you have added temporal 
% blurring in GATE, it is recommended to set this to zero unless you wish to add 
% additional  temporal noise.
% 
% *FWHM of the TOF data (TOF_FWHM)* = This is the FWHM  of the TOF data (in 
% seconds) used purely for reconstruction purposes and as such does NOT need to 
% be the same as the above value. In fact in  practically all cases the actual 
% FWHM of the data should always differ  from the above one. One way to determine 
% the actual FWHM is to simulate a point source.
% 
% *Number of TOF bins used in (TOF_bins_used)* = This  specifies how many TOF 
% bins are actually used during the reconstruction  phase. Currently this has 
% to be either same as the total number of bins  or 1 (in which case all TOF bins 
% are summed together). In the future,  this will allow TOF mashing.
%% MISCELLANEOUS PROPERTIES
% *Name (name) *= Name of the experiment/simulation/whatever (char). Used for 
% naming purposes.
% 
% *Precompute necessary data (precompute)* = If this is true, then some of the 
% obligatory mat-files are computed that are required if the |options.precompute_lor| 
% is set to true. Otherwise, there is no need to pass the precomputation step. 
% All mat-files are saved in the |mat-files| folder.
% 
% *Path to the input data (fpath)* = This is the path to the folder where the 
% input data is (char). All the files for the specified GATE output will be read. 
% E.g. if you set use_ASCII to true, then from the folder specified by fpath, 
% all the .dat files with Coincidences in them will be loaded, for LMF all .ccs 
% files will be loaded and for Root all .root files will be loaded. If you use 
% Windows, use the |fpat| value after |ispc|, otherwise the one after |else|.
% 
% *Form only sinograms (only_sinos)* = If this is set to true, then running 
% the m-file only performs steps up to the sinogram formation. I.e. data is loaded 
% and then the sinogram is formed. No reconstructions, normalization coefficient 
% computations or precomputations will be done.
% 
% *Skip data load (no_data_load)* = This value can be  used to control whether 
% any data load steps are performed during the  running of a main-file. If set 
% to false, then no data will be loaded  from the GATE ROOT/ASCII/LMF files or 
% list-mode files. All other steps  (precomputation, corrections, reconstruction, 
% etc.) are still performed.
% 
% *Precompute the observation/system matrix (precompute_obs_matrix)* = Experimental 
% feature. Setting to true computes the entire system matrix on one go and will 
% most likely require a significant amount of memory (most likely over 100 GB). 
% Supports only MLEM reconstruction. If set to false, then the system matrix is 
% calculated on-the-fly (recommended).
% 
% *Only reconstructions (only_reconstruction)* = Setting to true skips all other 
% steps except the reconstruction phase. Precompute step is also skipped even 
% if set to true. All necessary data is loaded from the previously computed mat-files. 
% This step also overwrites ´only_sinos`.
% 
% *How many pixels a LOR traverses (precompute_lor)* = When true, this option 
% changes the reconstruction process quite radically. First, it requires its own 
% precompute phase. Secondly, it affects greatly on how the system matrix is formed. 
% With this option set to true, the number of pixels each LOR traverses is determined 
% beforehand. For implementation 1 this allows for more efficient memory management, 
% while with other methods the computational speed is enhanced (more for raw data). 
% This step is recommended if you use implementation 1. Improved Siddon’s algorithm 
% with more than 1 rays is not supported when this is true.
% 
% *Precompute everything (precompute_all)* = This option causes the prepass 
% phase to compute all mat-files even if they were not selected. E.g. if you use 
% sinogram data, also all precomputations for raw data are done.
% 
% *Status messages (verbose)* = If this is set to true, then you will receive 
% occasional status messages and also elapsed time of functions.
%% RECONSTRUCTION PROPERTIES
% *IMPLEMENTATIONS*
% In OMEGA the different ways to compute the different algorithms and projections 
% is referred to as implementations.
% 
% *Implementation *= This option determines how the reconstructions and the 
% system matrix are computed. In all cases the system matrix is computed through 
% a mex-file (implementation 1 does have fallback non-mex system matrix formation 
% method, but that is very slow).
% 
% If set to 1, then all the reconstructions will be done purely in MATLAB using 
% nothing but MATLAB commands. Implementation 1 also supports all algorithms available. 
% The system matrix is formed as an actual matrix in a mex-file and then output 
% to MATLAB (when |precompute_lor = true|) or as sparse matrix indices (|precompute_lor 
% = false|) which are used to form the sparse matrix itself. The latter option 
% is NOT parallel and uses also more memory.
% 
% Implementation 2 is an OpenCL/ArrayFire reconstruction, and everything is 
% done in a mex-file. This is a matrix-free method. In Implementation 2 both the 
% system matrix creation and reconstruction are performed on the selected device. 
% Supports all the same algorithms as implementation 1. AD-MRP prior behaves differently 
% from implementation 1.
% 
% Implementation 3 uses pure OpenCL, i.e. doe not require ArrayFire libraries. 
% This is a matrix-free method. Implementation 3, however, only supports OSEM 
% and MLEM. Unlike implementation 2, implementation 3 does support multi-device 
% computation. The multi-device computation consists using of multiple GPUs (from 
% the same manufacturer) or using GPU + CPU combination (from the same manufacturer).
% 
% If set to 4, then all the computations are done parallel on the CPU by using 
% OpenMP (if supported by the compiler). This is a matrix-free method. This implementation 
% does not require OpenCL and should work on all CPUs. All CPUs/cores are used 
% automatically. All algorithms except MRAMLA and MBSREM are supported. All priors 
% are supported. Only one MLEM-based algorithm and one OS-based algorithm are 
% supported (with one prior) at a time. E.g. you can have MLEM and OSL-OSEM with 
% NLM, but not OSEM and OSL-OSEM.
% 
% In Implementations 2 and 3, the system matrix is created by using single precision 
% numbers, meaning that it can be slightly inaccurate when compared to Implementations 
% 1 and 4 that use double precision numbers.
% 
% On which implementation to select, see <useful_information.html Recommendations>.
% 
% *Device (use_device)* = This determines the device used in implementation 
% 2 and the platform in 4. For implementation 2 the devices mean the actual devices 
% available that are either CPUs, GPUs or accelerators, with GPUs usually being 
% first in the list (0 should use always use your GPU if you have one). Use |ArrayFire_OpenCL_device_info()| 
% to determine the devices you have and their respective number. For implementation 
% 4, the platforms are divided by manufacturer. Same manufacturer can have multiple 
% platforms, however, if you have multiple OpenCL runtimes installed. Use |OpenCL_device_info()| 
% to see the available platforms and the devices included in each of them. In 
% implementation 4, by default, all the devices associated with certain platform 
% are used except devices that have less than 2 GB of memory. Single device can 
% also be selected with the |options.cpu_to_gpu_factor| (see below).
% 
% *64 bit atomics (use_64bit_atomics)* = If true, then 64-bit atomic functions 
% are used. This affects ONLY implementations 2 and 3. If your device does not 
% support 64-bit atomics, the result will be equivalent to setting this to false 
% (with slightly slower overall computations due to extra compilation). Intel 
% hardware usually do not support 64-bit atomics, but AMD or Nvidia GPUs should. 
% Setting this to false will cause slower computations if the 64-bit atomics are 
% supported but can be slightly more reliable and accurate. This is recommended 
% when using GPUs and OpenCL.
% 
% *Use CUDA* = If true, uses CUDA code for implementation 2 instead of OpenCL. 
% This affects implementation 2 ONLY. Running |install_mex| will automatically 
% try to compile the CUDA code, but the CUDA kernels themselves are compiled at 
% runtime (with nvrtc). Currently this is recommended only when using the improved 
% Siddon as the projector. Orthogonal or volume-based ray tracer will most likely 
% be slower than when using OpenCL code.
% 
% *CPU to GPU factor (cpu_to_gpu_factor)* = Affects only implementation 3. This 
% variable has dual purpose. The first purpose is in heterogeneous computing by 
% delegating more LORs to the GPU part. E.g. if this is set to 2, then the GPU 
% will have 2x more LORs compared to the CPU. Another use is obtained by setting 
% this to 0, when it will use only a single device from the platform. GPUs are 
% prioritized with the GPU having the most memory taken.
% *PROJECTOR*
% *Projector used (projector_type)* = Three different projectors are available 
% for all implementations. These are the improved Siddon’s algorithm (1), orthogonal 
% distance-based ray tracer (2) and volume-of-intersection based ray tracer (3). 
% Implementation 1, when |options.precompute_lor = false| also has the original 
% Siddon’s ray tracer (0). Orthogonal ray tracer allows for both 2.5D or 3D modes 
% (see below). For some additional help on selecting the projector see <useful_information.html 
% Recommendations>. 
% 
% *Use PSF* = Setting this to true will apply point spread function to the reconstruction. 
% This is equivalent to applying an image blurring matrix to the system matrix 
% computation.
% 
% *FWHM of the PSF (FWHM) *= This specifies the full width at half maximum (FWHM) 
% of the Gaussian blurring used in PSF. Separate values are available for all 
% three different dimensions (x, y and z).
% 
% *Use deblurring in PSF (use_deblurring)* = This performs convolution deblurring 
% to the PSF reconstruction AFTER the image reconstruction has fully completed. 
% This is performed for all iterations. The number of iterations for the deblurring 
% is the same as the number of subsets times the number of iterations.
% 
% *Strip width (tube_width_xy)* = Affects only orthogonal distance-based ray 
% tracer. This is the maximum distance from the ray to a voxel center allowed 
% in the projector in 2D (x- and y-directions). I.e. the width of the strip of 
% response. If the below value is zero, then this value is used and the orthogonal 
% ray tracer will be run in 2.5D mode. If the below value is non-zero then this 
% value is ignored.
% 
% *Tube width (tube_width_z)* = Affects only orthogonal distance-based ray tracer. 
% This is the maximum distance from the ray to a voxel center allowed in the projector 
% in 3D (x-, y- and z-directions). I.e. the width and height of the tube of response. 
% Only square tubes are allowed; if this is non-zero, any value in |tube_width_xy| 
% is ignored.
% 
% *Tube radius* = Affects only volume-of-intersection based ray tracer. This 
% is the radius of the tube of response, which is a cylinder in this case.
% 
% *Voxel radius* = Affects only volume-of-intersection based ray tracer. Relative 
% voxel radius of the spherical voxels used in the projector 3. If 1, then the 
% spherical voxel will be just large enough to completely contain the original 
% voxel. Lower values cause smaller voxels while larger values give larges ones.
% 
% *Number of transaxial rays (n_rays_transaxial)* = Affects only improved Siddon’s 
% algorithm when |options.precompute_lor = false| and using any implementation 
% other than 1 (i.e. works with implementations 2, 3 and 4). This is the number 
% of rays used in the improved Siddon in the transaxial dimension. Any number 
% of rays can be used. The total number of rays is |n_rays_axial| * |n_rays_transaxial|.
% 
% *Number of axial rays (n_rays_axial)* = Affects only improved Siddon’s algorithm 
% when |options.precompute_lor = false| and using any implementation other than 
% 1 (i.e. works with implementations 2, 3 and 4). This is the number of rays used 
% in the improved Siddon in the axial dimension. Any number of rays can be used. 
% The total number of rays is |n_rays_axial| * |n_rays_transaxial|.
% 
% *Accelerate reconstruction (apply_acceleration)* = Affects only improved Siddon 
% when TOF is enabled or orthogonal distance-based and volume ray tracers, in 
% all cases only with  implementations 2 and 3. If set to true, intermediate values 
% are stored in memory. This accelerates the computations by about 30%, but will 
% lead to increased memory cost on GPUs. Can also cause CL_OUT_OF_HOST_MEMORY 
% errors. Has less significance when using TOF data.
% *RECONSTRUCTION SETTINGS*
% *Number of iterations (Niter)* = The number of iterations.
% 
% *Number of subsets (subsets)* = In subset methods, this value determines the 
% number of subsets that the sinogram/raw data is divided into. Depending on the 
% data type used (sinogram or raw), there are several different ways to select 
% the subsets (see below |subset_type|).
% 
% *Type of subset division (subset_type)* = Six different methods, numbered 
% from 1 to 6, to sort the measurements into subsets.
% 
% 1 = Every nth column is taken in order (sinogram only), e.g. once the end 
% of the column is reached, indexing starts from the first column again in the 
% next row.
% 
% 2 = Every nth row (both sinogram and raw data, default in raw data), once 
% the end of the row is reached, indexing starts from the first row again in the 
% next column.
% 
% 3 = The measurements are taken randomly, by default uses |randperm|, but can 
% use the file exchange |Shuffle| (see below) for faster speed and better memory 
% use.
% 
% 4 = Every nth column from the sinogram, takes an entire column and then jumps 
% n columns to the next.
% 
% 5 = Every nth row from the sinogram, takes an entire row and then jumps n 
% row to the next.
% 
% 6 = Uses n number of angles to form each subset. First the LORs are sorted 
% according to the angle they create with the (positive) x-axis. Then |n_angles| 
% (see below) angles are grouped together to form one subset. E.g. if |n_angles 
% = 2| then angles 0 and 1 form one subset, 2 and 3 another, etc. For 2D slices 
% there will be a total of 180°/nangles subsets and 360°/nangles for 3D. This 
% method is explained in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [4>].
% 
% 7 = Uses golden angle sampling to select the subsets. Each sinogram uses the 
% same number of angles and the same angles, the golden angle sampling is thus 
% performed on single sinogram basis. The next angle is selected such that the 
% difference is roughly the same as the golden angle (approx. 111.246°). Currently 
% this subset sampling is supported only by sinogram data.
% 
% *Number of angles (n_angles)* = If the above method 6 is selected, this value 
% is used to determine how many angles are used in one subset.
% 
% *Initial value (x0)* = The initial value of all of the reconstruction methods. 
% In dynamic studies all the time steps have the same initial value.
% 
% *Epsilon value (epps)* = This small value is added to divisions to prevent 
% division by zero.
% *MISC SETTINGS*
% *Use Shuffle (use_Shuffle)* = Whether the MATLAB file exchange code <https://se.mathworks.com/matlabcentral/fileexchange/27076-shuffle 
% Shuffle> is used. Applies only to |subset_type = 3|. Speeds up the pre-process 
% a bit and also uses less memory.
% 
% *Use FSparse (use_fsparse)* = Whether <https://github.com/stefanengblom/stenglib 
% FSparse> is used. Only used if precompute_lor is set to false. Suggested only 
% for MATLAB 2019b and earlier.
% 
% *MRP-type prior without normalization (med_no_norm)* = Normally MPR-type priors 
% (MRP, FMH, L-filter, AD and weighted mean) are of the form (λ - Mb)/Mb. If this 
% is set to true, then the denominator (normalization) is removed (i.e. (λ - Mb)/1).
% *RECONSTRUCTION ALGORITHMS*
% *Use MLEM/OSEM/etc.* = When any of these are set to true, the specific algorithm 
% is computed. This is dependent on the selected implementation. Separate sections 
% are for the maximum likelihood-based methods, maximum a posteriori methods and 
% priors. MAP methods require at least one prior and priors require at least one 
% MAP method.
% 
% *ACOSEM properties* = Only the acceleration factor can be adjusted. See the 
% original article for details.
% 
% *MRAMLA/MBSREM properties* = Relaxation parameter and the upper bound can 
% be adjusted.
% 
% *RAMLA/BSREM properties* = Relaxation parameter can be adjusted.
% 
% *ROSEM properties* = Relaxation parameter can be adjusted.
% 
% *DRAMA properties* = Parameters α, β and β0 can be adjusted. See [4], e.g. 
% eq. (20).
% 
% *Neighborhood properties* = Adjust how many neighboring voxels are taken into 
% account (|Ndx|, |Ndy| and |Ndz|). Used in MRP, quadratic prior, FMH, L-filter, 
% weighted mean and NLM.
% 
% *MRP properties* = Regularization parameters for all MAP-methods can be adjusted.
% 
% *Quadratic prior properties* = Regularization parameters for all MAP-methods 
% can be adjusted.
% 
% Custom weights can be input. The weights vector should be of size |(Ndx*2+1) 
% * (Ndy*2+1) * (Ndz*2+1)| and the middle value inf.
% 
% *L-filter properties* = Regularization parameters for all MAP-methods can 
% be adjusted.
% 
% Custom weights can be input. The weights vector should be of size |(Ndx*2+1) 
% * (Ndy*2+1) * (Ndz*2+1)| (middle value is NOT inf).
% 
% If custom weights are not given, the |options.oneD_weights| determines whether 
% 1D (true) or 2D (false) weighting scheme is used. In 1D case, if |(Ndx*2+1) 
% * (Ndy*2+1) * (Ndz*2+1)| = 3, = 9 or = 25 then the weights are exactly as in 
% literature <https://github.com/villekf/OMEGA/wiki/Function-help#references [5>]. 
% Otherwise the pattern follows a <https://en.wikipedia.org/wiki/Laplace_distribution 
% Laplace distribution>. In 2D case, the weights follow Laplace distribution, 
% but are also weighted based on the distance of the neighboring voxel from the 
% center voxel. For Laplace distribution, the mean value is set to 0 and b = 1/sqrt(2). 
% The weights are normalized such that the sum equals 1.
% 
% *FMH properties* = Regularization parameters for all MAP-methods can be adjusted.
% 
% Custom weights can be input. The weights vector should be of size |[Ndx*2+1, 
% 4]| if |Nz = 1| or |Ndz = 0| or ´[Ndx*2+1, 13]´ otherwise. The weight for the 
% center pixel should also be the middle value when the weight matrix is in vector 
% form. The weights are normalized such that the sum equals 1.
% 
% If custom weights are not provided, then the |options.fmh_center_weight| parameter 
% is needed. Default value is 4 as in the original article <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [6>].
% 
% *Weighted mean properties* = Regularization parameters for all MAP-methods 
% can be adjusted.
% 
% Custom weights can be input. The weights vector should be of size |(Ndx*2+1) 
% * (Ndy*2+1) * (Ndz*2+1)|.
% 
% If custom weights are not provided, then the |options.weighted_center_weight| 
% parameter is needed. Default value is 4 as in the original article <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [6>]
% 
% *TV properties* = Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.TVsmoothing| is a "smoothing" parameter that also prevents zero in 
% square root (it is summed to the square root values). (variable β in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [7>] eq. 11 and <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [8>] eq. 13).
% 
% If |options.TV_use_anatomical = true|, then an anatomical prior is used in 
% TV regularization. |options.TV_reference_image| is the name of the file containing 
% the anatomical reference images (image size needs to be the same as the reconstructed 
% images). The reference images need to be the only variable in the file.
% 
% |options.TVtype| controls the type of TV regularization used. For |TVtype 
% = 1| see <https://github.com/villekf/OMEGA/wiki/Function-help#references [7>], 
% |TVtype = 2| <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [8>] and |TVtype = 3| <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [9>]. If no anatomical prior is used, then type 1 and 2 are the same. Type 3 
% uses the same weights as quadratic prior.
% 
% |options.T| is the edge threshold parameter in type 1 (variable C in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [7>], see e.g. eq. 8), scale parameter for side information in type 2 (variable 
% γ in <https://github.com/villekf/OMEGA/wiki/Function-help#references [8>], see 
% eq. 13), weight parameter for anatomical information in type 2 (variable η in 
% <https://github.com/villekf/OMEGA/wiki/Function-help#references [9>], see eq. 
% 11).
% 
% |options.C| is the weight of the original image in type 3 (variable δ in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [9>], see e.g. eq. 11).
% 
% All TV types are isotropic.
% 
% *MRP-AD properties* = In MRP-AD, the median filtered image is replaced with 
% anisotropic diffusion smoothed image. I.e. if MAD is the anisotropic diffusion 
% smoothed image, the prior is (λ - MAD)/MAD. Using this with implementation 1 
% requires the Image Processing Toolbox. This prior does not work on Octave.
% 
% Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.TimeStepAD| is the time step for the AD filter (implementation 2 
% only). More information <http://arrayfire.org/docs/group__image__func__anisotropic__diffusion.htm 
% here>.
% 
% |options.KAD| is the conductivity/connectivity parameter. More information 
% <https://se.mathworks.com/help/images/ref/imdiffusefilt.html here> and <http://arrayfire.org/docs/group__image__func__anisotropic__diffusion.htm 
% here>.
% 
% |options.NiterAD| number of iterations for the AD smoothing part.
% 
% |options.FluxType| is the flux/conduction type. Available methods are Exponential 
% (1) and Quadratic (2). E.g. |options.FluxType = 2| uses quadratic.
% 
% |options.DiffusionType| is the diffusion type (implementation 2 only). Available 
% methods are Gradient (1) and Modified curvature (2). E.g. |options.DiffusionType= 
% 2| uses modified curvature.
% 
% *APLS properties* = Using asymmetric parallel level sets requires the use 
% of anatomic prior. Without anatomical prior it functions as TV types 1 and 2.
% 
% Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.eta| is a scaling parameter in regularized norm (see variable η in 
% <https://github.com/villekf/OMEGA/wiki/Function-help#references [8>]).
% 
% |options.APLSsmoothing| is a "smoothing" parameter that also prevents zero 
% in square root (it is summed to the square root values). Has the same function 
% as the |TVsmoothing| parameter (see <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [8>] eq. 9).
% 
% |options.APLS_reference_image| is the name of the file containing the anatomical 
% reference images (image size needs to be the same as the reconstructed images). 
% The reference images need to be the only variable in the file.
% 
% *TGV properties* = Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.betaTGV| is the first weighting value for the TGV (see parameter 
% α1 in <https://github.com/villekf/OMEGA/wiki/Function-help#references [10>]).
% 
% |options.alphaTGV| is the second weighting value for the TGV (see parameter 
% α0 in <https://github.com/villekf/OMEGA/wiki/Function-help#references [10>]). 
% Weight for the symmetrized derivative.
% 
% |options.NiterTGV| number of iterations for the TGV smoothing part.
% 
% *NLM properties* = Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.sigma| is the filtering parameter (see parameter h in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [11>] or σ in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [12>], eq. 6).
% 
% The patch radius is controlled with parameters |options.Nlx|, |options.Nly| 
% and |options.Nlz|. The similarity is investigated in this area.
% 
% The strength of the Gaussian weighting (standard deviation) of the weights 
% can be adjusted with |options.NLM_gauss|.
% 
% If |options.NLM_use_anatomical = true| then an anatomical reference image 
% is used in the similarity search of the neighborhood. Normally the original 
% image is used for this. |options.NLM_reference_image| is the name of the anatomical 
% reference data file. The reference images need to be the only variable in the 
% file.
% 
% If you wish to use non-local total variation, set |options.NLTV = true|. This 
% overwrites the MRP selection (see below). All other NLM options apply.
% 
% NLM can also be used like MRP (and MRP-AD) where the median filtered image 
% is replaced with NLM replaced image. This is achieved by setting |options.NLM_MRP 
% = true|. This is computed without normalization ((λ - MNLM)/1). All other NLM 
% options apply.
%% LOAD SCATTER DATA
% In this section, the user will be prompted to load the scatter correction 
% data if |options.scatter_correction = true|.
%% CUSTOM DETECTOR COORDINATES
% Here you can input custom detector coordinates. These enable the use of non-cylindrical 
% devices or continuous detectors (e.g. CPET in GATE). Transaxial coordinates 
% are specified as |options.x| and |options.y| while axial are |options.z| (or 
% alternatively |options.z_det|). Simply save your custom coordinates to the specified 
% |x|, |y| and |z| variables in the |options| struct. For sinogram data, the |x| 
% and |y| sizes should be |[sinogram_elements 2]| and |z| |[number_of_sinograms 
% 2]|. For raw data |[detectors_per_ring 1]| and| [number_of_rings 1]|, respectively. 
% 
% It is also possible to use pure event-by-event list-mode reconstruction with 
% custom coordinates. In this case each event should have its own detector coordinates 
% and as such each coordinate should be of size |[total_events 2]|. Currently 
% only implementation 4 supports event-by-event reconstruction and it is also 
% ONLY supported with custom detectors.
%% Load measurement data
% The function <loadMeasurementData.m loadMeasurementData> allows you to load 
% measurement data in different formats. Curently supported are  MATLAB-data, 
% NIfTI, Analyze 7.5, DICOM, Interfile, MetaImage, and binary data. Analyze requires 
% <https://se.mathworks.com/matlabcentral/fileexchange/8797-tools-for-nifti-and-analyze-image 
% Tools for NIfTI and ANALYZE image> from MathWorks file exchange, NIfTI either 
% image processing toolbox or  Tools for NIfTI and ANALYZE image and DICOM support 
% requires image  processing toolbox on MATLAB and dicom package on Octave (untested 
% on  Octave).
% 
% Binary data can be of any type, but if binary data other than int32 is used, 
% then it has to be specified. E.g. |options = loadMeasurementData(options,'uint16')| 
% loads 16-bit unsigned integer data. If the binary data has a header of _n_ bytes, 
% it can be skipped by specifying the number of bytes (e.g. |options = loadMeasurementData(options,'uint16', 
% n)|. If the header is at the end of the file, using a negative value will ignore 
% the last _n_ bytes. 
% 
% The data is saved in the |options| structure, either in |SinM| (sinogram data) 
% or |coincidences| (raw data).
% 
% Raw data can only be used with MATLAB-data (mat-file).
% 
% DICOM data currently supports only 2D slices.
% 
% The user should also always check that the output measurement data looks correct 
% (e.g. |imagesc(options.SinM(:,:,30))|).
%% DEPTH OF INTERACTION
% This section is commented by default, but can be used to specify a  depth 
% of interaction value (millimeters). By default this is set to 0,  i.e. it is 
% assumed that all the interactions occur at the surface of the detector crystals. 
% What this value changes is the depth of where the  interactions are assumed 
% to occur, i.e. it only changes the detector  coordinates such that the transaxial 
% coordinates are "deeper" in the  crystal. Having too large values can cause 
% issues with the  reconstruction.
% 
% This value does not affect custom detector coordinates.
##### SOURCE END #####
--></body></html>