<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB R2019a"><title>Computing the forward and/or backward projections</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.7999992370605px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: normal; text-align: left;  }
.S1 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }
.S2 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: bold; text-align: left;  }
.S3 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: bold; text-align: left;  }</style></head><body><div class = rtcContent><h1  class = 'S0'><span>Computing the forward and/or backward projections</span></h1><div  class = 'S1'><span>This page details on how to separately compute the forward and/or backward projections when using OMEGA.</span></div><h2  class = 'S2'><span>Computing the forward and/or backward projections</span></h2><div  class = 'S1'><span>When you are manually computing the forward and/or backward projections, it is recommended to use the </span><a href = "forward_backward_projections_example.m"><span>forward_backward_projections_example.m</span></a><span> and modify it according to your specifications.</span></div><div  class = 'S1'><span>The initial part works very much like </span><a href = "https://github.com/villekf/OMEGA/blob/master/main_PET.m"><span>main_PET.m</span></a><span>, however, there are no adjustments for the reconstruction algorithms. You still need to input the necessary information (machine properties, sinogram/raw data properties, corrections, etc.) before proceeding. For </span><span style=' font-family: monospace;'>options.precompute_lor = true</span><span> you also need to perform the precomputation phase if it hasn't been performed before. Note that if you want the measurement data to be precorrected, you need to do that manually. Corrections during reconstruction are applied automatically, though in some cases (such as randoms correction) you need to select the correction data when it is prompted.</span></div><div  class = 'S1'><span>For the reconstruction, implementations 1, 3 and 4 are supported with 3 recommended.</span></div><div  class = 'S1'><span>After the initial setup phase, there are two different ways to actually compute </span><span style=' font-style: italic;'>Ax</span><span> and </span><span style=' font-style: italic;'>A^Ty</span><span>. The first, recommended, method is by using a MATLAB/Octave class that is demonstrated in the initial examples in </span><a href = "https://github.com/villekf/OMEGA/blob/master/forward_backward_projections_example.m#L821"><span>forward_backward_projections_example.m</span></a><span>, the second method is the old one using functions.</span></div><h3  class = 'S3'><span>Class based examples</span></h3><div  class = 'S1'><span>First is a class-based exampled computing OSEM/MLEM estimates (line 821) with the use of the special forward and backward projection operators. The major steps needed for class based use is the creation of the class object with </span><span style=' font-family: monospace;'>forwardBackwardProject(options)</span><span> and the load of the measurement data. Sensitivity image can be obtained from the backprojection. PSF is applied automatically if selected.</span></div><div  class = 'S1'><span>You can also create the same class object as above without the need for any of the main-files, however, several features are then unavailable (such as corrections). This is achieved by inputting the required variables manually: </span><span style=' font-family: monospace;'>A = forwardBackwardProject(Nx, Ny, Nz, FOVa_x, axial_fov, diameter, rings, cr_p, cr_pz, cryst_per_block, blocks_per_ring, det_per_ring, Ndist, Nang,NSinos, span, ring_difference, subsets, implementation, use_device, projector_type, tube_width_z, tube_radius, voxel_radius, use_psf, FWHM);</span></div><div  class = 'S1'><span>To use your own measurement data, replace </span><span style=' font-family: monospace;'>load('Cylindrical_PET_example_cylpet_example_sinograms_combined_static_200x168x703_span3.mat','raw_SinM')</span><span> with your own custom load or simply run the code up to that and manually load your data (you can use </span><span style=' font-family: monospace;'>loadMeasurementData</span><span> to load custom data, such as interfiles). You should either name your measurement data as </span><span style=' font-family: monospace;'>raw_SinM</span><span> or rename all instances of </span><span style=' font-family: monospace;'>raw_SinM</span><span> to the same name as your input measurement data (</span><span style=' font-family: monospace;'>options.SinM</span><span> if you use </span><span style=' font-family: monospace;'>loadMeasurementData</span><span>). Your input data needs to be oriented the same way as the measurement data used in OMEGA. For sinograms that is thus </span><span style=' font-family: monospace;'>options.Ndist</span><span> x </span><span style=' font-family: monospace;'>options.Nang</span><span> x </span><span style=' font-family: monospace;'>options.NSinos</span><span>. Dynamic data needs to be manually correctly formatted.</span></div><div  class = 'S1'><span>The second class-based example computing Conjugate-gradient Least-squares (CGLS) utilizes the operator overloading. This means that after you have created the class (e.g. with </span><span style=' font-family: monospace;'>A = forwardBackwardProject(options);</span><span>) you can then simply multiply this with the desired vector (e.g.</span><span style=' font-family: monospace;'> A * x</span><span> or </span><span style=' font-family: monospace;'>A * y</span><span>). Whether forward or backward projection is computed, is determined automatically from the dimensions of the input vector. Alternative, backprojection can be forced with </span><span style=' font-family: monospace;'>A' * y</span><span>.</span></div><div  class = 'S1'><span>Other examples include LSQR, SA-WLS (includes TOF example), ATP-WLS, EM-PKMA with TV regularization and ADMM with TV. Of these, EM-PKMA and ADMM provide examples on how to use the built-in priors. Prepass functions must be run for the following priors: </span></div><div  class = 'S1'><span>MRP (</span><span style=' font-family: monospace;'>options = computeOffsets(options);</span><span>)</span></div><div  class = 'S1'><span>Quadratic prior (</span><span style=' font-family: monospace;'>options = computeWeights(options); </span><span>and</span><span style=' font-family: monospace;'> options = quadWeights(options, options.empty_weight);</span><span>)</span></div><div  class = 'S1'><span>Huber prior (</span><span style=' font-family: monospace;'>options = computeWeights(options);</span><span> and</span><span style=' font-family: monospace;'> options = huberWeights(options);</span><span>)</span></div><div  class = 'S1'><span>L-filter (</span><span style=' font-family: monospace;'>options = computeWeights(options);</span><span>, </span><span style=' font-family: monospace;'>options = computeOffsets(options);</span><span> and </span><span style=' font-family: monospace;'>options.a_L = lfilter_weights(options.Ndx, options.Ndy, options.Ndz, options.FOVa_x/options.Nx, options.FOVa_y/options.Ny, options.axial_fov/options.Nz, options.oneD_weights);</span><span>)</span></div><div  class = 'S1'><span>FMH (</span><span style=' font-family: monospace;'>options = computeWeights(options);</span><span>,</span><span style=' font-family: monospace;'> options = computeOffsets(options);</span><span> and </span><span style=' font-family: monospace;'>options = fmhWeights(options);</span><span>)</span></div><div  class = 'S1'><span>Weighted mean (</span><span style=' font-family: monospace;'>options = computeWeights(options);</span><span> and</span><span style=' font-family: monospace;'> options = weightedWeights(options);</span><span>)</span></div><div  class = 'S1'><span>TV (</span><span style=' font-family: monospace;'>options = TVPrepass(options);</span><span>, the following ONLY when </span><span style=' font-family: monospace;'>options.TVtype = 3</span><span>: </span><span style=' font-family: monospace;'>options = computeWeights(options);</span><span>, </span><span style=' font-family: monospace;'>options = computeOffsets(options);</span><span> and </span><span style=' font-family: monospace;'>options = quadWeights(options, options.empty_weight);</span><span>)</span></div><div  class = 'S1'><span>APLS (</span><span style=' font-family: monospace;'>options = APLSPrepass(options);</span><span>)</span></div><div  class = 'S1'><span>NLM (</span><span style=' font-family: monospace;'>options = NLMPrepass(options);</span><span>).</span></div><div  class = 'S1'><span>Furthermore, you can also obtain the (subset of the) system matrix from the same class object. This is demonstrated in the System matrix (OSEM) example between SA-WLS and ATP-WLS.</span></div><h3  class = 'S3'><span>Function based examples</span></h3><div  class = 'S1'><span>This is the very last example script in </span><a href = "https://github.com/villekf/OMEGA/blob/master/forward_backward_projections_example.m#L1137"><span>forward_backward_projections_example.m</span></a><span>. It is no longer recommended to compute the forward and/or backward projections this way.</span></div><div  class = 'S1'><span>You'll need to run the </span><a href = "https://github.com/villekf/OMEGA/blob/master/source/index_maker.m"><span>index_maker.m</span></a><span> as specified to get the necessary subset indices. The line </span><span style=' font-family: monospace;'>[gaussK, options] = PSFKernel(options);</span><span> is only applicable if PSF reconstruction is used as it creates the PSF kernel gaussK.</span></div><div  class = 'S1'><span>To use your own measurement data, replace </span><span style=' font-family: monospace;'>load('Cylindrical_PET_example_cylpet_example_sinograms_combined_static_200x168x703_span3.mat','raw_SinM'</span><span>) with your own custom load or simply run the code up to that and manually load your data. You should either name your measurement data as </span><span style=' font-family: monospace;'>raw_SinM</span><span> or rename all instances of </span><span style=' font-family: monospace;'>raw_SinM</span><span> to the same name as your input measurement data. Your input data needs to be oriented the same way as the measurement data used in OMEGA. For sinograms that is thus </span><span style=' font-family: monospace;'>options.Ndist</span><span> x </span><span style=' font-family: monospace;'>options.Nang</span><span> x </span><span style=' font-family: monospace;'>options.NSinos</span><span>. Dynamic data needs to be manually correctly formatted.</span></div><div  class = 'S1'><span>After the above steps, simply use the functions [forward_project](https://github.com/villekf/OMEGA/blob/master/source/forward_project.m) and [backproject](https://github.com/villekf/OMEGA/blob/master/source/backproject.m) as you like. The example provided uses them the same way as in OSEM, but as they simply implement the operations </span><span style=' font-style: italic;'>y = Ax</span><span> and</span><span style=' font-style: italic;'> x = A^Tb</span><span>, respectively, you can implement any algorithm that uses these matrix-vector operations. An example of PSF reconstruction is included as well. Sensitivity image is obtained with backprojection, but can also be omitted by simply having only one output parameter.</span></div><div  class = 'S1'><span>All selected corrections are applied to the forward and/or backward projections. If you wish to use different projectors for the forward or backward projections, you need to manually set options.projector_type between them. E.g. compute forward projection when</span><span style=' font-family: monospace;'> options.projector_type = 2</span><span> and then set </span><span style=' font-family: monospace;'>options.projector_type = 1</span><span> and compute backprojection. This, however, is untested and may especially not work when using implementation 1. If you wish to use different projectors, it is recommended to use implementation 3 and set </span><span style=' font-family: monospace;'>options.precompute_lor = false</span><span>.</span></div><div  class = 'S1'><span>The optional PSF deblurring phase can also be performed and an example of that is also included.</span></div></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% Computing the forward and/or backward projections
% This page details on how to separately compute the forward and/or backward 
% projections when using OMEGA.
%% Computing the forward and/or backward projections
% When you are manually computing the forward and/or backward projections, it 
% is recommended to use the <forward_backward_projections_example.m forward_backward_projections_example.m> 
% and modify it according to your specifications.
% 
% The initial part works very much like <https://github.com/villekf/OMEGA/blob/master/main_PET.m 
% main_PET.m>, however, there are no adjustments for the reconstruction algorithms. 
% You still need to input the necessary information (machine properties, sinogram/raw 
% data properties, corrections, etc.) before proceeding. For |options.precompute_lor 
% = true| you also need to perform the precomputation phase if it hasn't been 
% performed before. Note that if you want the measurement data to be precorrected, 
% you need to do that manually. Corrections during reconstruction are applied 
% automatically, though in some cases (such as randoms correction) you need to 
% select the correction data when it is prompted.
% 
% For the reconstruction, implementations 1, 3 and 4 are supported with 3 recommended.
% 
% After the initial setup phase, there are two different ways to actually compute 
% _Ax_ and _A^Ty_. The first, recommended, method is by using a MATLAB/Octave 
% class that is demonstrated in the initial examples in <https://github.com/villekf/OMEGA/blob/master/forward_backward_projections_example.m#L821 
% forward_backward_projections_example.m>, the second method is the old one using 
% functions.
% Class based examples
% First is a class-based exampled computing OSEM/MLEM estimates (line 821) with 
% the use of the special forward and backward projection operators. The major 
% steps needed for class based use is the creation of the class object with |forwardBackwardProject(options)| 
% and the load of the measurement data. Sensitivity image can be obtained from 
% the backprojection. PSF is applied automatically if selected.
% 
% You can also create the same class object as above without the need for any 
% of the main-files, however, several features are then unavailable (such as corrections). 
% This is achieved by inputting the required variables manually: |A = forwardBackwardProject(Nx, 
% Ny, Nz, FOVa_x, axial_fov, diameter, rings, cr_p, cr_pz, cryst_per_block, blocks_per_ring, 
% det_per_ring, Ndist, Nang,NSinos, span, ring_difference, subsets, implementation, 
% use_device, projector_type, tube_width_z, tube_radius, voxel_radius, use_psf, 
% FWHM);|
% 
% To use your own measurement data, replace |load('Cylindrical_PET_example_cylpet_example_sinograms_combined_static_200x168x703_span3.mat','raw_SinM')| 
% with your own custom load or simply run the code up to that and manually load 
% your data (you can use |loadMeasurementData| to load custom data, such as interfiles). 
% You should either name your measurement data as |raw_SinM| or rename all instances 
% of |raw_SinM| to the same name as your input measurement data (|options.SinM| 
% if you use |loadMeasurementData|). Your input data needs to be oriented the 
% same way as the measurement data used in OMEGA. For sinograms that is thus |options.Ndist| 
% x |options.Nang| x |options.NSinos|. Dynamic data needs to be manually correctly 
% formatted.
% 
% The second class-based example computing Conjugate-gradient Least-squares 
% (CGLS) utilizes the operator overloading. This means that after you have created 
% the class (e.g. with |A = forwardBackwardProject(options);|) you can then simply 
% multiply this with the desired vector (e.g.| A * x| or |A * y|). Whether forward 
% or backward projection is computed, is determined automatically from the dimensions 
% of the input vector. Alternative, backprojection can be forced with |A' * y|.
% 
% Other examples include LSQR, SA-WLS (includes TOF example), ATP-WLS, EM-PKMA 
% with TV regularization and ADMM with TV. Of these, EM-PKMA and ADMM provide 
% examples on how to use the built-in priors. Prepass functions must be run for 
% the following priors: 
% 
% MRP (|options = computeOffsets(options);|)
% 
% Quadratic prior (|options = computeWeights(options); |and| options = quadWeights(options, 
% options.empty_weight);|)
% 
% Huber prior (|options = computeWeights(options);| and| options = huberWeights(options);|)
% 
% L-filter (|options = computeWeights(options);|, |options = computeOffsets(options);| 
% and |options.a_L = lfilter_weights(options.Ndx, options.Ndy, options.Ndz, options.FOVa_x/options.Nx, 
% options.FOVa_y/options.Ny, options.axial_fov/options.Nz, options.oneD_weights);|)
% 
% FMH (|options = computeWeights(options);|,| options = computeOffsets(options);| 
% and |options = fmhWeights(options);|)
% 
% Weighted mean (|options = computeWeights(options);| and| options = weightedWeights(options);|)
% 
% TV (|options = TVPrepass(options);|, the following ONLY when |options.TVtype 
% = 3|: |options = computeWeights(options);|, |options = computeOffsets(options);| 
% and |options = quadWeights(options, options.empty_weight);|)
% 
% APLS (|options = APLSPrepass(options);|)
% 
% NLM (|options = NLMPrepass(options);|).
% 
% Furthermore, you can also obtain the (subset of the) system matrix from the 
% same class object. This is demonstrated in the System matrix (OSEM) example 
% between SA-WLS and ATP-WLS.
% Function based examples
% This is the very last example script in <https://github.com/villekf/OMEGA/blob/master/forward_backward_projections_example.m#L1137 
% forward_backward_projections_example.m>. It is no longer recommended to compute 
% the forward and/or backward projections this way.
% 
% You'll need to run the <https://github.com/villekf/OMEGA/blob/master/source/index_maker.m 
% index_maker.m> as specified to get the necessary subset indices. The line |[gaussK, 
% options] = PSFKernel(options);| is only applicable if PSF reconstruction is 
% used as it creates the PSF kernel gaussK.
% 
% To use your own measurement data, replace |load('Cylindrical_PET_example_cylpet_example_sinograms_combined_static_200x168x703_span3.mat','raw_SinM'|) 
% with your own custom load or simply run the code up to that and manually load 
% your data. You should either name your measurement data as |raw_SinM| or rename 
% all instances of |raw_SinM| to the same name as your input measurement data. 
% Your input data needs to be oriented the same way as the measurement data used 
% in OMEGA. For sinograms that is thus |options.Ndist| x |options.Nang| x |options.NSinos|. 
% Dynamic data needs to be manually correctly formatted.
% 
% After the above steps, simply use the functions [forward_project](https://github.com/villekf/OMEGA/blob/master/source/forward_project.m) 
% and [backproject](https://github.com/villekf/OMEGA/blob/master/source/backproject.m) 
% as you like. The example provided uses them the same way as in OSEM, but as 
% they simply implement the operations _y = Ax_ and_ x = A^Tb_, respectively, 
% you can implement any algorithm that uses these matrix-vector operations. An 
% example of PSF reconstruction is included as well. Sensitivity image is obtained 
% with backprojection, but can also be omitted by simply having only one output 
% parameter.
% 
% All selected corrections are applied to the forward and/or backward projections. 
% If you wish to use different projectors for the forward or backward projections, 
% you need to manually set options.projector_type between them. E.g. compute forward 
% projection when| options.projector_type = 2| and then set |options.projector_type 
% = 1| and compute backprojection. This, however, is untested and may especially 
% not work when using implementation 1. If you wish to use different projectors, 
% it is recommended to use implementation 3 and set |options.precompute_lor = 
% false|.
% 
% The optional PSF deblurring phase can also be performed and an example of 
% that is also included.
##### SOURCE END #####
--></body></html>