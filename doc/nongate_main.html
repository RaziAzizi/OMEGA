<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB R2019a"><title>nongate_main</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.7999992370605px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: normal; text-align: left;  }
.S1 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: bold; text-align: left;  }
.S2 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }</style></head><body><div class = rtcContent><h1  class = 'S0'><span>nongate_main</span></h1><h2  class = 'S1'><span>MACHINE PROPERTIES</span></h2><div  class = 'S2'><span>The first section contains the device parameters and is included in both files. These include (name in parenthesis is the MATLAB variable name):</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Blocks per ring (blocks_per_ring)</span><span> = This is the number of "blocks" in your machine on each ring. If you have cylindrical PET geometry, then this should be the number of R-sectors/modules per ring. For ECAT it is the number of blocks/R-sectors. If you need more help, see the included example (# R E P E A T R S E C T O R).</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Linear multiply (linear_multip)</span><span> = The repeater number in GATE. See the example on how this compares with the GATE macros (# R E P E A T M O D U L E). For non-GATE it is the number of blocks in axial direction.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Crystals per block (cryst_per_block)</span><span> = The number of crystals on the side of each block. In the example the crystals are in 8x8 grids meaning this value is 8. Blocks need to contain square crystal grids.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Crystal pitch x/y-direction (cr_p)</span><span> = Crystal pitch in the x- and y-directions. I.e. the distance between the centers of adjacent crystals.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Crystal pitch z-direction (cr_pz)</span><span> = Same as above, but in z-direction.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Bore diameter (diameter)</span><span> = Diameter of the machine bore. I.e. distance between perpendicular crystals.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Transaxial field-of-view (FOVa_x)</span><span> = Transaxial field-of-view (x-direction), i.e. the reconstructed image location.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Transaxial field-of-view (FOVa_y)</span><span> = Transaxial field-of-view (y-direction), i.e. the reconstructed image location.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Axial FOV (axial_fov)</span><span> = Same as above, but in axial (z) direction.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Pseudo rings (pseudot)</span><span> = The number of pseudo rings. Use 0 or [] if none.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Detectors per ring (det_per_ring)</span><span> = Number of detectors per ring without pseudo detectors. Can be automatically determined as in the example.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Detectors per ring w/ pseudo detectors (det_w_pseudo)</span><span> = Same as above, but with pseudo detectors included. Since pseudo detectors are usually included in each detector block, you can determine this number by adding +1 to crystals per block. E.g. </span><span style=' font-family: monospace;'>options.det_w_pseudo = options.blocks_per_ring*(options.cryst_per_block + 1);</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Total number of rings (rings)</span><span> = Number of crystal rings. Can be computed automatically.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Total number of detectors (detectors)</span><span> = Can be automatically determined.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Machine name</span><span> = The name of your machine. Used for naming purposes.</span></div><h2  class = 'S1'><span>IMAGE PROPERTIES</span></h2><div  class = 'S2'><span>Image size in x-direction (Nx)</span><span> = If the total image size is 128x128x63 then this is 128. Non-square sizes are technically supported, but untested.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Image size in y-direction (Ny)</span><span> = If the total image size is 128x128x63 then this is 128. Non-square sizes are technically supported, but untested.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Image size in z-direction (Nz)</span><span> = If the total image size is 128x128x63 then this is 63.</span></div><h2  class = 'S1'><span>SINOGRAM PROPERTIES</span></h2><div  class = 'S2'><span>Span (span)</span><span> = The span factor (also called axial compression). The higher the number, the greater the compression of oblique LORs).</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Maximum ring difference (ring_difference)</span><span> = The maximum distance (in rings) from which oblique LORs are included.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Number of angles (Nang)</span><span> = How many different angles (tangential positions) are in the sinogram. The angles depict the angle between the LOR and x-axis. Is mashing is used, this value should be the final sinogram size AFTER mashing.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Number of views (Ndist)</span><span> = How many different views (angular positions) are in the sinogram. The views are the shortest (orthogonal) distance between the LOR and the origin.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Segment table (segment_table)</span><span> = Oblique sinograms are divided into groups specified by the segment table. This value depends on the span value and can be automatically computed as in the example.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Total number of sinograms (TotSinos)</span><span> = The total number of sinograms. Can be obtained by summing the segment table.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Number of sinograms used in reconstruction (NSinos)</span><span> = Less sinograms can be used in the reconstruction process itself (e.g. only parallel LORs). This is an experimental feature. Only the N first sinograms can be used, e.g. you can’t pick only 100 last sinograms, but you can pick the first 100.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Distance side (ndist_side)</span><span> = When Ndist value is even, then one extra view has to be taken either from the "negative" or "positive" side. With this you can specify whether this is from the "negative" (+1) or "positive" (-1). If you are unsure what value to use, use the default value. This varies from device to device. If you compare the sinogram produced by OMEGA to the machine generated one and see a slight shift, then this parameter is most likely incorrect.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Increasing sinogram sampling (sampling)</span><span> = The first dimension of the sinogram (views) can be increased with this value. For example setting sampling to 2, would double the size of the first dimension. The extra values are interpolated (see below). This can be used to prevent aliasing artifacts. Value should be either 1 or divisible by two.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Sampling interpolation type (sampling_interpolation_method)</span><span> = Specifies the interpolation method used for increased sampling. All methods supported by </span><span style=' font-family: monospace;'>interp1</span><span> are available.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Fill sinogram gaps (fill_sinogram_gaps)</span><span> = If pseudo detectors are used, setting this to true will fill the gaps caused by them. Experimental feature.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Gap filling method (gap_filling_method)</span><span> = What method is used to fill the gaps. Available methods are the MATLAB’s built-in </span><span style=' font-family: monospace;'>fillmissing</span><span> or alternatively </span><a href = "https://se.mathworks.com/matlabcentral/fileexchange/4551-inpaint_nans"><span style=' text-decoration: underline; font-family: monospace;'>inpaint_nans</span></a><span> from file exchange. Must be in char format.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Interpolation method (fillmissing) (interpolation_method_fillmissing)</span><span> = Which of the interpolation methods are used when using </span><span style=' font-family: monospace;'>fillmissing</span><span> for gap filling. See the help file on </span><span style=' font-family: monospace;'>fillmissing</span><span> for more information. Input is char, e.g. </span><span style=' font-family: monospace;'>'linear'</span><span>.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Interpolation method (inpaint_nans) (interpolation_method_inpaint)</span><span> = Which of the interpolation methods are used when using </span><span style=' font-family: monospace;'>inpaint_nans</span><span> for gap filling. See the help on </span><span style=' font-family: monospace;'>inpaint_nans</span><span> for more information. Input is a number.</span></div><h2  class = 'S1'><span>CORRECTIONS</span></h2><div  class = 'S2'><span>Randoms correction (randoms_correction)</span><span> = If set to true, then the delayed coincidences are stored during data load (GATE and Inveon data) and used for randoms correction during sinogram formation or image reconstruction. For other data, the user will be prompted for the randoms correction data when it is required. The data (mat-file) should then include a variable named SinDelayed (sinogram data), delayed_coincidences (raw_data) or be the only variable in the file.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Variance reduction (variance_reduction)</span><span> = If true, performs variance reduction to randoms data before corrections. The variance reduction uses 3D fan sum algorithm [</span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>3</span></a><span>].</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Randoms smoothing (randoms_smoothing)</span><span> = If true, performs smoothing to the randoms data before corrections. The smoothing is a fixed 8x8 moving mean smoothing. The window size can be adjusted in the original function </span><span style=' font-family: monospace;'>randoms_smoothing</span><span>. For sinogram data, the smoothing is done when the randoms sinogram is formed. Activating smoothing later and performing the corrections during reconstructions does NOT perform smoothing unless the sinogram formation step is done as well.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Scatter correction (scatter_correction)</span><span> = If set to true, scatter correction will be performed during sinogram formation or image reconstruction. In all cases, the user will be prompted for the scatter correction data. The input data (mat-file) must include a variable named SinScatter (sinogram data), scattered_coincidences (raw data) or be the only variable in the file. In the first two cases, the data can be scatter data created by OMEGA from a different MC scatter correction simulation.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Normalize scatter (normalize_scatter)</span><span> = If set to true, performs normalization correction to the scatter correction data before the reconstruction phase. This phase is ignored if the corrections are applied directly to the measured data in which case it will be subtracted before the normalization correction.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Scatter smoothing (scatter_smoothing)</span><span> = If true, performs smoothing to the scatter data before corrections. The smoothing is a fixed 8x8 moving mean smoothing. The window size can be adjusted in the original function </span><span style=' font-family: monospace;'>randoms_smoothing</span><span>.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Attenuation correction (attenuation_correction)</span><span> = If true, performs attenuation correction during the reconstruction. You need attenuation images scaled to 511 keV for this. CT images can be scaled with the function </span><span style=' font-family: monospace;'>attenuationCT_to_511</span><span> provided with OMEGA. DICOM CT images might automatically scale with </span><span style=' font-family: monospace;'>create_atten_matrix_CT</span><span>, but currently it has been tested only with one machine. </span><span style=' font-family: monospace;'>attenuation122_to_511</span><span> can be used to scale 122 keV blank/transmission data to 511 keV, i.e. GE-68 attenuation measurement.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Attenuation datafile (attenuation_datafile)</span><span> = Name of the data file containing the (scaled) attenuation images. Use full path if it is not on MATLAB/Octave path. This is required if the attenuation correction is applied. One exception is if you are using Inveon data and have an atn-file, you can then leave this one blank and will be asked separately to input the atn-data.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Compute normalization coefficients (compute_normalization)</span><span> = If true and the main-file is run, then the input data will be used to compute the normalization coefficients. Currently supported normalization correction components are axial geometric correction (axial block profile and geometric factors), detector efficiency (fan-sum algorithm for both sinogram and raw data or SPC for raw data), transaxial block profile correction and transaxial geometric correction. Supports both raw list-mode data or sinogram data. Transaxial geometric correction is not recommended for objects that do not cover the entire FOV (or rather do not irradiate the entire FOV region). The corresponding function will output the corrected measurement data, the normalization matrix (multiplying this with the original measurement data gives the same corrected data) and each individual correction factors. Computation of the normalization coefficients follows the book [</span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>1</span></a><span>]. Fan-sum algorithm, used in computing the detector efficiencies, can be found from [</span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>2</span></a><span>].</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Normalization options (normalization_options)</span><span> = A vector representing all the four possible normalization correction steps that can be performed (see above). 1 means that the method is included, 0 that it is excluded. E.g. the default setting </span><span style=' font-family: monospace;'>[1 1 1 0] </span><span>computes axial geometric, detector efficiency and transaxial block profile corrections, but not transaxial geometric correction.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Phantom radius (normalization_phantom_radius)</span><span> = If the source phantom is cylinder that is smaller than the FOV, input the radius of the cylinder here (in cm). For an object encompassing the entire FOV, use an empty array </span><span style=' font-family: monospace;'>[]</span><span> or </span><span style=' font-family: monospace;'>inf</span><span>.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Scatter correction (normalization_scatter_correction)</span><span> = If a phantom, that is smaller than the FOV, is used, compute the scatter correction for the data. Requires the above cylinder radius and only supports sinogram data. For GATE data it is recommended to use trues in the normalization correction in order to skip this phase.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Apply normalization (normalization_correction)</span><span> = Once the normalization correction coefficients have been separately computed, turning this to true will enable them in the sinogram formation or in the reconstruction phase.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Apply user normalization (use_user_normalization)</span><span> = If this is true, then the user will be prompted for the normalization correction data. This file can be either a mat-file with one variable (the normalization coefficients, such that normalized_data = un_normalized_data * normalization) or an Inveon PET .nrm-file. In the latter case, the file needs to be exactly as output by the Siemens software.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Arc correction (arc_correction)</span><span> = Applies arc correction to the input sinogram data. For the interpolation method, see below.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Arc correction interpolation (arc_interpolation)</span><span> = Method used in the arc correction interpolation. All methods supported either by </span><span style=' font-family: monospace;'>scatteredInterpolant</span><span> or </span><span style=' font-family: monospace;'>griddata</span><span> are available. By default </span><span style=' font-family: monospace;'>scatteredInterpolant</span><span> is used, but if the method is not supported by it </span><span style=' font-family: monospace;'>gridddata</span><span> is used. </span><span style=' font-family: monospace;'>griddata</span><span> is also used if </span><span style=' font-family: monospace;'>scatteredInterpolant</span><span> is not found.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Apply corrections during reconstruction (corrections_during_reconstruction)</span><span> = If set to true, then the corrections are applied during the reconstruction phase. I.e. uncorrected sinogram/raw data is automatically loaded and used in the reconstruction process. The corrections data is also automatically loaded (assuming it has been previously created). Smoothing and/or variance reduction needs to be performed beforehand.</span></div><h2  class = 'S1'><span>DYNAMIC IMAGING PROPERTIES</span></h2><div  class = 'S2'><span>Total time (tot_time)</span><span> = The total time of the experiment (seconds). If you have a static experiment, use inf to load all the data regardless of the total time.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Number of time step (partitions)</span><span> = How many time steps are in the dynamic case.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Start time (start)</span><span> = The start time for the data load (seconds). Any measurements before this time will be ignored and will not be loaded.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>End time (end)</span><span> = The end time for the data load (seconds). Any measurements after this time will be ignored and will not be loaded.</span></div><h2  class = 'S1'><span>MISCELLANEOUS PROPERTIES</span></h2><div  class = 'S2'><span>Name (name)</span><span> = Name of the experiment/simulation/whatever (char). Used for naming purposes.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Precompute necessary data (precompute)</span><span> = If this is true, then some of the obligatory mat-files are computed that are required if the </span><span style=' font-family: monospace;'>options.precompute_lor</span><span> is set to true. Otherwise, there is no need to pass the precomputation step. All mat-files are saved in the </span><span style=' font-family: monospace;'>mat-files</span><span> folder.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Path to the input data (fpath)</span><span> = This is the path to the folder where the input data is (char). All the files for the specified GATE output will be read. E.g. if you set use_ASCII to true, then from the folder specified by fpath, all the .dat files with Coincidences in them will be loaded, for LMF all .ccs files will be loaded and for Root all .root files will be loaded. If you use Windows, use the </span><span style=' font-family: monospace;'>fpat</span><span> value after </span><span style=' font-family: monospace;'>ispc</span><span>, otherwise the one after </span><span style=' font-family: monospace;'>else</span><span>.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Form only sinograms (only_sinos)</span><span> = If this is set to true, then running the m-file only performs steps up to the sinogram formation. I.e. data is loaded and then the sinogram is formed. No reconstructions, normalization coefficient computations or precomputations will be done.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Precompute the observation/system matrix (precompute_obs_matrix)</span><span> = Experimental feature. Setting to true computes the entire system matrix on one go and will most likely require a significant amount of memory (most likely over 100 GB). Supports only MLEM reconstruction. If set to false, then the system matrix is calculated on-the-fly (recommended).</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Only reconstructions (only_reconstruction)</span><span> = Setting to true skips all other steps except the reconstruction phase. Precompute step is also skipped even if set to true. All necessary data is loaded from the previously computed mat-files. This step also overwrites ´only_sinos`.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Use raw data (use_raw_data)</span><span> = Set this to true if you want to use raw list-mode data. I.e. data that has not been compressed at all. This step requires its own precompute phase if </span><span style=' font-family: monospace;'>options.precompute_lor = true</span><span>. The raw data in OMEGA is formatted such that the saved measurement data is a vector formed from a lower triangular matrix. This lower triangular matrix is extracted from a matrix of size </span><span style=' font-family: monospace;'>total_number_of_detectors x total_number_of_detectors</span><span>. The matrix contains all the possible line of response combinations, e.g. between detector 1 and detector 3. Since the LOR between detectors 1 and 3 is the same as the LOR between detectors 3 and 1, the upper triangular part is added to the lower triangular part before the lower triangular part is extracted. The raw date is always saved in cell format, regardless of the number of time steps. Non-cell data should work, but cell data is recommended.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>How many pixels a LOR traverses (precompute_lor)</span><span> = When true, this option changes the reconstruction process quite radically. First, it requires its own precompute phase. Secondly, it affects greatly on how the system matrix is formed. With this option set to true, the number of pixels each LOR traverses is determined beforehand. For implementation 1 this allows for more efficient memory management, while with other methods the computational speed is enhanced (more for raw data). This step is recommended if you use implementation 1. Improved Siddon’s algorithm with more than 1 rays is not supported when this is true.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Precompute everything (precompute_all)</span><span> = This option causes the prepass phase to compute all mat-files even if they were not selected. E.g. if you use sinogram data, also all precomputations for raw list-mode data are done.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Status messages (verbose)</span><span> = If this is set to true, then you will receive occasional status messages and also elapsed time of functions.</span></div><h2  class = 'S1'><span>RECONSTRUCTION PROPERTIES</span></h2><div  class = 'S2'><span style=' font-weight: bold;'>IMPLEMENTATIONS</span></div><div  class = 'S2'><span>In OMEGA the different ways to compute the different algorithms and projections is referred to as implementations.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Implementation (reconstruction_method)</span><span> = This option determines how the reconstructions and the system matrix are computed. In all cases the system matrix is done through a mex-file (implementation 1 does have fallback non-mex system matrix formation method, but that is very slow).</span></div><div  class = 'S2'><span>If set to 1, then all the reconstructions will be done purely in MATLAB using nothing but MATLAB commands. Implementation 1 also supports all algorithms available.</span></div><div  class = 'S2'><span>Implementation 2 is an OpenCL/ArrayFire reconstruction, and everything is done in a mex-file. This is a matrix-free method. In Implementation 2 both the system matrix creation and reconstruction are performed on the selected device. Supports all the same algorithms as implementation 1 except non-local means prior (there is preliminary beta support). AD-MRP prior also behaves differently.</span></div><div  class = 'S2'><span>Implementation 3 uses pure OpenCL, i.e. not requiring ArrayFire libraries. This is a matrix-free method. Implementation 3, however, only supports OSEM and MLEM, but does support multi-device computation. The multi-device computation consists using of multiple GPUs (from the same manufacturer) or using GPU + CPU combination (from the same manufacturer).</span></div><div  class = 'S2'><span>If set to 4, then all the computations are done parallel on the CPU by using OpenMP (if supported by the compiler). This is a matrix-free method. This implementation does not require OpenCL and should work on all CPUs. All CPUs/cores are used automatically. Supported algorithms are MLEM, OSEM, RAMLA, ROSEM, OSL-MLEM, OSL-OSEM, BSREM and ROSEM-MAP. All priors are supported. Only one MLEM-based algorithm and one OS-based algorithm are supported (with one prior) at a time. E.g. you can have MLEM and OSL-OSEM with NLM, but not OSEM and OSL-OSEM.</span></div><div  class = 'S2'><span>In Implementations 2 and 3, the system matrix is created by using single precision numbers, meaning that it can be slightly inaccurate when compared to Implementations 1 and 4 that use double precision numbers.</span></div><div  class = 'S2'><span>On which implementation to select, see Recommendations.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Device (use_device)</span><span> = This determines the device used in implementation 2 and the platform in 4. For implementation 2 the devices mean the actual devices available that are either CPUs, GPUs or accelerators, with GPUs usually being first in the list (0 should use always use your GPU if you have one). Use </span><span style=' font-family: monospace;'>ArrayFire_OpenCL_device_info()</span><span> to determine the devices you have and their respective number. For implementation 4, the platforms are divided by manufacturer. Same manufacturer can have multiple platforms, however, if you have multiple OpenCL runtimes installed. Use </span><span style=' font-family: monospace;'>OpenCL_device_info()</span><span> to see the available platforms and the devices included in each of them. In implementation 4, by default, all the devices associated with certain platform are used except devices that have less than 2 GB of memory. Single device can also be selected with the </span><span style=' font-family: monospace;'>options.cpu_to_gpu_factor</span><span> (see below).</span></div><div  class = 'S2'><span style=' font-weight: bold;'>64 bit atomics (use_64bit_atomics)</span><span> = If true, then the 64 bit atomic functions are used. This affects ONLY implementations 2 and 3. If your device does not support 64-bit atomics, the result will be equivalent to setting this to false. Intel hardware usually do not support 64-bit atomics, but AMD or Nvidia GPUs should. Setting this to false will cause slower computations if the 64-bit atomics are supported but can be slightly more reliable and accurate.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Force build (force_build)</span><span> = If true, forces the building of the OpenCL binaries. Affects only implementation 2. By default, OMEGA precompiles OpenCL binaries for each device on the first run but setting this to true will cause the binaries to be rewritten to be built even if they had been previously built. Necessary when hardware changes occur, or new OMEGA versions are installed and recommended after driver updates.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>CPU to GPU factor (cpu_to_gpu_factor)</span><span> = Affects only implementation 3. This variable has dual purpose. The first purpose is in heterogeneous computing by delegating more LORs to the GPU part. E.g. if this is set to 2, then the GPU will have 2x more LORs compared to the CPU. Another use is obtained by setting this to 0, when it will use only a single device from the platform. GPUs are prioritized with the GPU having the most memory taken.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>PROJECTOR</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Projector used (projector_type)</span><span> = Two different projectors are available for all implementations. These are the improved Siddon’s algorithm (1) and orthogonal distance-based ray tracer (2). Implementation 1, when </span><span style=' font-family: monospace;'>options.precompute_lor = false</span><span> also has the original Siddon’s ray tracer (0).</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Strip width (tube_width_xy)</span><span> = Affects only orthogonal distance-based ray tracer. This is the maximum distance from the ray to a voxel center allowed in the projector in 2D (x- and y-directions). I.e. the width of the strip of response.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Tube width (tube_width_z)</span><span> = Affects only orthogonal distance-based ray tracer. This is the maximum distance from the ray to a voxel center allowed in the projector in 3D (x-, y- and z-directions). I.e. the width and height of the tube of response. Only square tubes are allowed; if this is non-zero, any value in </span><span style=' font-family: monospace;'>tube_width_xy</span><span> is ignored.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Accuracy factor (accuracy_factor)</span><span> = Affects only orthogonal distance-based ray tracer in 3D mode. This value determines the minimum distance in voxels where the distance is computed. Higher values allow for more accurate estimates while also taking longer to compute. The default value (5) should be good in most cases, though more accurate image sizes might benefit from higher value.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Number of rays (n_rays)</span><span> = Affects only improved Siddon’s algorithm when </span><span style=' font-family: monospace;'>options.precompute_lor = false</span><span> and using any implementation other than 1 (i.e. works with implementations 2, 3 and 4). Allowed values range from 1 to 5, though it is recommended to use either 1 or 5. When using 5 rays, the pattern follows that of number five in six-sided dice.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>RECONSTRUCTION SETTINGS</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Number of iterations (Niter)</span><span> = The number of iterations.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Number of subsets (subsets)</span><span> = In subset methods, this value determines the number of subsets that the sinogram/raw data is divided into. Depending on the data type used (sinogram or raw), there are several different ways to select the subsets (see below </span><span style=' font-family: monospace;'>subset_type</span><span>).</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Type of subset division (subset_type)</span><span> = Six different methods, numbered from 1 to 6, to sort the measurements into subsets.</span></div><div  class = 'S2'><span>1 = Every nth column is taken in order (sinogram only), e.g. once the end of the column is reached, indexing starts from the first column again in the next row.</span></div><div  class = 'S2'><span>2 = Every nth row (both sinogram and raw data, default in raw data), once the end of the row is reached, indexing starts from the first row again in the next column.</span></div><div  class = 'S2'><span>3 = The measurements are taken randomly, by default uses </span><span style=' font-family: monospace;'>randperm</span><span>, but can use the file exchange </span><span style=' font-family: monospace;'>Shuffle</span><span> (see below) for faster speed and better memory use.</span></div><div  class = 'S2'><span>4 = Every nth column from the sinogram, takes an entire column and then jumps n columns to the next.</span></div><div  class = 'S2'><span>5 = Every nth row from the sinogram, takes an entire row and then jumps n row to the next.</span></div><div  class = 'S2'><span>6 = Uses n number of angles to form each subset. First the LORs are sorted according to the angle they create with the (positive) x-axis. Then </span><span style=' font-family: monospace;'>n_angles</span><span> (see below) angles are grouped together to form one subset. E.g. if </span><span style=' font-family: monospace;'>n_angles = 2</span><span> then angles 0 and 1 form one subset, 2 and 3 another, etc. For 2D slices there will be a total of 180°/n</span><span>angles</span><span> subsets and 360°/n</span><span>angles</span><span> for 3D. This method is explained in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[4</span></a><span>].</span></div><div  class = 'S2'><span>7 = Uses golden angle sampling to select the subsets. Each sinogram uses the same number of angles and the same angles, the golden angle sampling is thus performed on single sinogram basis. The next angle is selected such that the difference is roughly the same as the golden angle (approx. 111.246°). Currently this subset sampling is supported only by sinogram data.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Number of angles (n_angles)</span><span> = If the above method 6 is selected, this value is used to determine how many angles are used in one subset.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Initial value (x0)</span><span> = The initial value of all of the reconstruction methods. In dynamic studies all the time steps have the same initial value.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Epsilon value (epps)</span><span> = This small value is added to divisions to prevent division by zero.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>MISC SETTINGS</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Use Shuffle (use_Shuffle)</span><span> = Whether the MATLAB file exchange code </span><a href = "https://se.mathworks.com/matlabcentral/fileexchange/27076-shuffle"><span style=' text-decoration: underline;'>Shuffle</span></a><span> is used. Applies only to </span><span style=' font-family: monospace;'>subset_type = 3</span><span>. Speeds up the pre-process a bit and also uses less memory.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Use FSparse (use_fsparse)</span><span> = Whether </span><a href = "https://github.com/stefanengblom/stenglib"><span style=' text-decoration: underline;'>FSparse</span></a><span> is used. Only used if precompute_lor is set to false.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>MRP-type prior without normalization (med_no_norm)</span><span> = Normally MPR-type priors (MRP, FMH, L-filter, AD and weighted mean) are of the form (λ - M</span><span>b</span><span>)/M</span><span>b</span><span>. If this is set to true, then the denominator (normalization) is removed (i.e. (λ - M</span><span>b</span><span>)/1).</span></div><div  class = 'S2'><span style=' font-weight: bold;'>RECONSTRUCTION ALGORITHMS</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Use MLEM/OSEM/etc.</span><span> = When any of these are set to true, the specific algorithm is computed. This is dependent on the selected implementation. Separate sections are for the maximum likelihood-based methods, maximum a posteriori methods and priors. MAP methods require at least one prior and priors require at least one MAP method.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>ACOSEM properties</span><span> = Only the acceleration factor can be adjusted. See the original article for details.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>MRAMLA/MBSREM properties</span><span> = Relaxation parameter and the upper bound can be adjusted.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>RAMLA/BSREM properties</span><span> = Relaxation parameter can be adjusted.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>ROSEM properties</span><span> = Relaxation parameter can be adjusted.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>DRAMA properties</span><span> = Parameters α, β and β</span><span>0</span><span> can be adjusted. See [4], e.g. eq. (20).</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Neighborhood properties</span><span> = Adjust how many neighboring voxels are taken into account (</span><span style=' font-family: monospace;'>Ndx</span><span>, </span><span style=' font-family: monospace;'>Ndy</span><span> and </span><span style=' font-family: monospace;'>Ndz</span><span>). Used in MRP, quadratic prior, FMH, L-filter, weighted mean and NLM.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>MRP properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Quadratic prior properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span>Custom weights can be input. The weights vector should be of size </span><span style=' font-family: monospace;'>(Ndx*2+1) * (Ndy*2+1) * (Ndz*2+1)</span><span> and the middle value inf.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>L-filter properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span>Custom weights can be input. The weights vector should be of size </span><span style=' font-family: monospace;'>(Ndx*2+1) * (Ndy*2+1) * (Ndz*2+1)</span><span> (middle value is NOT inf).</span></div><div  class = 'S2'><span>If custom weights are not given, the </span><span style=' font-family: monospace;'>options.oneD_weights</span><span> determines whether 1D (true) or 2D (false) weighting scheme is used. In 1D case, if </span><span style=' font-family: monospace;'>(Ndx*2+1) * (Ndy*2+1) * (Ndz*2+1)</span><span> = 3, = 9 or = 25 then the weights are exactly as in literature </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[5</span></a><span>]. Otherwise the pattern follows a </span><a href = "https://en.wikipedia.org/wiki/Laplace_distribution"><span style=' text-decoration: underline;'>Laplace distribution</span></a><span>. In 2D case, the weights follow Laplace distribution, but are also weighted based on the distance of the neighboring voxel from the center voxel. For Laplace distribution, the mean value is set to 0 and b = 1/sqrt(2). The weights are normalized such that the sum equals 1.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>FMH properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span>Custom weights can be input. The weights vector should be of size </span><span style=' font-family: monospace;'>[Ndx*2+1, 4]</span><span> if </span><span style=' font-family: monospace;'>Nz = 1</span><span> or </span><span style=' font-family: monospace;'>Ndz = 0</span><span> or ´[Ndx*2+1, 13]´ otherwise. The weight for the center pixel should also be the middle value when the weight matrix is in vector form. The weights are normalized such that the sum equals 1.</span></div><div  class = 'S2'><span>If custom weights are not provided, then the </span><span style=' font-family: monospace;'>options.fmh_center_weight</span><span> parameter is needed. Default value is 4 as in the original article </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[6</span></a><span>].</span></div><div  class = 'S2'><span style=' font-weight: bold;'>Weighted mean properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span>Custom weights can be input. The weights vector should be of size </span><span style=' font-family: monospace;'>(Ndx*2+1) * (Ndy*2+1) * (Ndz*2+1)</span><span>.</span></div><div  class = 'S2'><span>If custom weights are not provided, then the </span><span style=' font-family: monospace;'>options.weighted_center_weight</span><span> parameter is needed. Default value is 4 as in the original article </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[6</span></a><span>]</span></div><div  class = 'S2'><span style=' font-weight: bold;'>TV properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.TVsmoothing</span><span> is a "smoothing" parameter that also prevents zero in square root (it is summed to the square root values). (variable β in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[7</span></a><span>] eq. 11 and </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>] eq. 13).</span></div><div  class = 'S2'><span>If </span><span style=' font-family: monospace;'>options.TV_use_anatomical = true</span><span>, then an anatomical prior is used in TV regularization. </span><span style=' font-family: monospace;'>options.TV_reference_image</span><span> is the name of the file containing the anatomical reference images (image size needs to be the same as the reconstructed images). The reference images need to be the only variable in the file.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.TVtype</span><span> controls the type of TV regularization used. For </span><span style=' font-family: monospace;'>TVtype = 1</span><span> see </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[7</span></a><span>], </span><span style=' font-family: monospace;'>TVtype = 2</span><span> </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>] and </span><span style=' font-family: monospace;'>TVtype = 3</span><span> </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[9</span></a><span>]. If no anatomical prior is used, then type 1 and 2 are the same. Type 3 uses the same weights as quadratic prior.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.T</span><span> is the edge threshold parameter in type 1 (variable C in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[7</span></a><span>], see e.g. eq. 8), scale parameter for side information in type 2 (variable γ in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>], see eq. 13), weight parameter for anatomical information in type 2 (variable η in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[9</span></a><span>], see eq. 11).</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.C</span><span> is the weight of the original image in type 3 (variable δ in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[9</span></a><span>], see e.g. eq. 11).</span></div><div  class = 'S2'><span>All TV types are isotropic.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>MRP-AD properties</span><span> = In MRP-AD, the median filtered image is replaced with anisotropic diffusion smoothed image. I.e. if M</span><span>AD</span><span> is the anisotropic diffusion smoothed image, the prior is (λ - M</span><span>AD</span><span>)/M</span><span>AD</span><span>. Using this with implementation 1 requires the Image Processing Toolbox. This prior does not work on Octave.</span></div><div  class = 'S2'><span>Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.TimeStepAD</span><span> is the time step for the AD filter (implementation 2 only). More information </span><a href = "http://arrayfire.org/docs/group__image__func__anisotropic__diffusion.htm"><span style=' text-decoration: underline;'>here</span></a><span>.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.KAD</span><span> is the conductivity/connectivity parameter. More information </span><a href = "https://se.mathworks.com/help/images/ref/imdiffusefilt.html"><span style=' text-decoration: underline;'>here</span></a><span> and </span><a href = "http://arrayfire.org/docs/group__image__func__anisotropic__diffusion.htm"><span style=' text-decoration: underline;'>here</span></a><span>.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.NiterAD</span><span> number of iterations for the AD smoothing part.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.FluxType</span><span> is the flux/conduction type. Available methods are Exponential (1) and Quadratic (2). E.g. </span><span style=' font-family: monospace;'>options.FluxType = 2</span><span> uses quadratic.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.DiffusionType</span><span> is the diffusion type (implementation 2 only). Available methods are Gradient (1) and Modified curvature (2). E.g. </span><span style=' font-family: monospace;'>options.DiffusionType= 2</span><span> uses modified curvature.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>APLS properties</span><span> = Using asymmetric parallel level sets requires the use of anatomic prior. Without anatomical prior it functions as TV types 1 and 2.</span></div><div  class = 'S2'><span>Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.eta</span><span> is a scaling parameter in regularized norm (see variable η in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>]).</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.APLSsmoothing</span><span> is a "smoothing" parameter that also prevents zero in square root (it is summed to the square root values). Has the same function as the </span><span style=' font-family: monospace;'>TVsmoothing</span><span> parameter (see </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[8</span></a><span>] eq. 9).</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.APLS_reference_image</span><span> is the name of the file containing the anatomical reference images (image size needs to be the same as the reconstructed images). The reference images need to be the only variable in the file.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>TGV properties</span><span> = Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.betaTGV</span><span> is the first weighting value for the TGV (see parameter α</span><span>1</span><span> in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[10</span></a><span>]).</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.alphaTGV</span><span> is the second weighting value for the TGV (see parameter α</span><span>0</span><span> in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[10</span></a><span>]). Weight for the symmetrized derivative.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.NiterTGV</span><span> number of iterations for the TGV smoothing part.</span></div><div  class = 'S2'><span style=' font-weight: bold;'>NLM properties</span><span> = Non-local means is only supported by implementation 1 at the moment.</span></div><div  class = 'S2'><span>Regularization parameters for all MAP-methods can be adjusted.</span></div><div  class = 'S2'><span style=' font-family: monospace;'>options.sigma</span><span> is the filtering parameter (see parameter h in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[11</span></a><span>] or σ in </span><a href = "https://github.com/villekf/OMEGA/wiki/Function-help#references"><span style=' text-decoration: underline;'>[12</span></a><span>], eq. 6).</span></div><div  class = 'S2'><span>The patch radius is controlled with parameters </span><span style=' font-family: monospace;'>options.Nlx</span><span>, </span><span style=' font-family: monospace;'>options.Nly</span><span> and </span><span style=' font-family: monospace;'>options.Nlz</span><span>. The similarity is investigated in this area.</span></div><div  class = 'S2'><span>The strength of the Gaussian weighting (standard deviation) of the weights can be adjusted with </span><span style=' font-family: monospace;'>options.NLM_gauss</span><span>.</span></div><div  class = 'S2'><span>If </span><span style=' font-family: monospace;'>options.NLM_use_anatomical = true</span><span> then an anatomical reference image is used in the similarity search of the neighborhood. Normally the original image is used for this. </span><span style=' font-family: monospace;'>options.NLM_reference_image</span><span> is the name of the anatomical reference data file. The reference images need to be the only variable in the file.</span></div><div  class = 'S2'><span>If you wish to use non-local total variation, set </span><span style=' font-family: monospace;'>options.NLTV = true</span><span>. This overwrites the MRP selection (see below). All other NLM options apply.</span></div><div  class = 'S2'><span>NLM can also be used like MRP (and MRP-AD) where the median filtered image is replaced with NLM replaced image. This is achieved by setting </span><span style=' font-family: monospace;'>options.NLM_MRP = true</span><span>. This is computed without normalization ((λ - M</span><span>NLM</span><span>)/1). All other NLM options apply.</span></div><h2  class = 'S1'><span>Load measurement data</span></h2><div  class = 'S2'><span>This function is for non-GATE data ONLY (</span><span style=' font-family: monospace;'>main_nongate.m</span><span>).</span></div><div  class = 'S2'><span>The function </span><span style=' font-family: monospace;'>loadMeasurementData</span><span> allows you to load  measurement data in different formats. Curently supported are  MATLAB-data, NIfTI, Analyze 7.5, DICOM, Interfile, MetaImage, and raw  data. Analyze requires </span><a href = "https://se.mathworks.com/matlabcentral/fileexchange/8797-tools-for-nifti-and-analyze-image"><span style=' text-decoration: underline;'>Tools for NIfTI and ANALYZE image</span></a><span> from MathWorks file exchange, NIfTI either image processing toolbox or  Tools for NIfTI and ANALYZE image and DICOM support requires image  processing toolbox on MATLAB and dicom package on Octave (untested on  Octave).</span></div><div  class = 'S2'><span>The data is saved in the </span><span style=' font-family: monospace;'>options</span><span> structure, either in </span><span style=' font-family: monospace;'>SinM</span><span> (sinogram data) or </span><span style=' font-family: monospace;'>coincidences</span><span> (raw list-mode data).</span></div><div  class = 'S2'><span>Raw data can be of any type, but if raw data other than int32 is used, then it has to be specified. E.g. </span><span style=' font-family: monospace;'>options = loadMeasurementData(options,'uint16')</span><span> loads 16-bit unsigned integer data. If the raw data has a header of </span><span style=' font-style: italic;'>n</span><span> bytes, it can be skipped by specifying the number of bytes (e.g. </span><span style=' font-family: monospace;'>options = loadMeasurementData(options,'uint16', n)</span><span>. If the header is at the end of the file, using a negative value will ignore the last </span><span style=' font-style: italic;'>n</span><span> bytes. The data is saved in the </span><span style=' font-family: monospace;'>options</span><span> structure.</span></div><div  class = 'S2'><span>Raw list-mode data can only be used with MATLAB-data.</span></div><div  class = 'S2'><span>DICOM data currently supports only 2D slices.</span></div><div  class = 'S2'><span>The user should also always check that the output measurement data looks correct (e.g. </span><span style=' font-family: monospace;'>imagesc(options.SinM(:,:,30))</span><span>).</span></div></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% nongate_main
%% MACHINE PROPERTIES
% The first section contains the device parameters and is included in both files. 
% These include (name in parenthesis is the MATLAB variable name):
% 
% *Blocks per ring (blocks_per_ring)* = This is the number of "blocks" in your 
% machine on each ring. If you have cylindrical PET geometry, then this should 
% be the number of R-sectors/modules per ring. For ECAT it is the number of blocks/R-sectors. 
% If you need more help, see the included example (# R E P E A T R S E C T O R).
% 
% *Linear multiply (linear_multip)* = The repeater number in GATE. See the example 
% on how this compares with the GATE macros (# R E P E A T M O D U L E). For non-GATE 
% it is the number of blocks in axial direction.
% 
% *Crystals per block (cryst_per_block)* = The number of crystals on the side 
% of each block. In the example the crystals are in 8x8 grids meaning this value 
% is 8. Blocks need to contain square crystal grids.
% 
% *Crystal pitch x/y-direction (cr_p)* = Crystal pitch in the x- and y-directions. 
% I.e. the distance between the centers of adjacent crystals.
% 
% *Crystal pitch z-direction (cr_pz)* = Same as above, but in z-direction.
% 
% *Bore diameter (diameter)* = Diameter of the machine bore. I.e. distance between 
% perpendicular crystals.
% 
% *Transaxial field-of-view (FOVa_x)* = Transaxial field-of-view (x-direction), 
% i.e. the reconstructed image location.
% 
% *Transaxial field-of-view (FOVa_y)* = Transaxial field-of-view (y-direction), 
% i.e. the reconstructed image location.
% 
% *Axial FOV (axial_fov)* = Same as above, but in axial (z) direction.
% 
% *Pseudo rings (pseudot)* = The number of pseudo rings. Use 0 or [] if none.
% 
% *Detectors per ring (det_per_ring)* = Number of detectors per ring without 
% pseudo detectors. Can be automatically determined as in the example.
% 
% *Detectors per ring w/ pseudo detectors (det_w_pseudo)* = Same as above, but 
% with pseudo detectors included. Since pseudo detectors are usually included 
% in each detector block, you can determine this number by adding +1 to crystals 
% per block. E.g. |options.det_w_pseudo = options.blocks_per_ring*(options.cryst_per_block 
% + 1);|
% 
% *Total number of rings (rings)* = Number of crystal rings. Can be computed 
% automatically.
% 
% *Total number of detectors (detectors)* = Can be automatically determined.
% 
% *Machine name* = The name of your machine. Used for naming purposes.
%% IMAGE PROPERTIES
% Image size in x-direction (Nx) = If the total image size is 128x128x63 then 
% this is 128. Non-square sizes are technically supported, but untested.
% 
% *Image size in y-direction (Ny)* = If the total image size is 128x128x63 then 
% this is 128. Non-square sizes are technically supported, but untested.
% 
% *Image size in z-direction (Nz)* = If the total image size is 128x128x63 then 
% this is 63.
%% SINOGRAM PROPERTIES
% Span (span) = The span factor (also called axial compression). The higher 
% the number, the greater the compression of oblique LORs).
% 
% *Maximum ring difference (ring_difference)* = The maximum distance (in rings) 
% from which oblique LORs are included.
% 
% *Number of angles (Nang)* = How many different angles (tangential positions) 
% are in the sinogram. The angles depict the angle between the LOR and x-axis. 
% Is mashing is used, this value should be the final sinogram size AFTER mashing.
% 
% *Number of views (Ndist)* = How many different views (angular positions) are 
% in the sinogram. The views are the shortest (orthogonal) distance between the 
% LOR and the origin.
% 
% *Segment table (segment_table)* = Oblique sinograms are divided into groups 
% specified by the segment table. This value depends on the span value and can 
% be automatically computed as in the example.
% 
% *Total number of sinograms (TotSinos)* = The total number of sinograms. Can 
% be obtained by summing the segment table.
% 
% *Number of sinograms used in reconstruction (NSinos)* = Less sinograms can 
% be used in the reconstruction process itself (e.g. only parallel LORs). This 
% is an experimental feature. Only the N first sinograms can be used, e.g. you 
% can’t pick only 100 last sinograms, but you can pick the first 100.
% 
% *Distance side (ndist_side)* = When Ndist value is even, then one extra view 
% has to be taken either from the "negative" or "positive" side. With this you 
% can specify whether this is from the "negative" (+1) or "positive" (-1). If 
% you are unsure what value to use, use the default value. This varies from device 
% to device. If you compare the sinogram produced by OMEGA to the machine generated 
% one and see a slight shift, then this parameter is most likely incorrect.
% 
% *Increasing sinogram sampling (sampling)* = The first dimension of the sinogram 
% (views) can be increased with this value. For example setting sampling to 2, 
% would double the size of the first dimension. The extra values are interpolated 
% (see below). This can be used to prevent aliasing artifacts. Value should be 
% either 1 or divisible by two.
% 
% *Sampling interpolation type (sampling_interpolation_method)* = Specifies 
% the interpolation method used for increased sampling. All methods supported 
% by |interp1| are available.
% 
% *Fill sinogram gaps (fill_sinogram_gaps)* = If pseudo detectors are used, 
% setting this to true will fill the gaps caused by them. Experimental feature.
% 
% *Gap filling method (gap_filling_method)* = What method is used to fill the 
% gaps. Available methods are the MATLAB’s built-in |fillmissing| or alternatively 
% <https://se.mathworks.com/matlabcentral/fileexchange/4551-inpaint_nans |inpaint_nans|> 
% from file exchange. Must be in char format.
% 
% *Interpolation method (fillmissing) (interpolation_method_fillmissing)* = 
% Which of the interpolation methods are used when using |fillmissing| for gap 
% filling. See the help file on |fillmissing| for more information. Input is char, 
% e.g. |'linear'|.
% 
% *Interpolation method (inpaint_nans) (interpolation_method_inpaint)* = Which 
% of the interpolation methods are used when using |inpaint_nans| for gap filling. 
% See the help on |inpaint_nans| for more information. Input is a number.
%% CORRECTIONS
% Randoms correction (randoms_correction) = If set to true, then the delayed 
% coincidences are stored during data load (GATE and Inveon data) and used for 
% randoms correction during sinogram formation or image reconstruction. For other 
% data, the user will be prompted for the randoms correction data when it is required. 
% The data (mat-file) should then include a variable named SinDelayed (sinogram 
% data), delayed_coincidences (raw_data) or be the only variable in the file.
% 
% *Variance reduction (variance_reduction)* = If true, performs variance reduction 
% to randoms data before corrections. The variance reduction uses 3D fan sum algorithm 
% [<https://github.com/villekf/OMEGA/wiki/Function-help#references 3>].
% 
% *Randoms smoothing (randoms_smoothing)* = If true, performs smoothing to the 
% randoms data before corrections. The smoothing is a fixed 8x8 moving mean smoothing. 
% The window size can be adjusted in the original function |randoms_smoothing|. 
% For sinogram data, the smoothing is done when the randoms sinogram is formed. 
% Activating smoothing later and performing the corrections during reconstructions 
% does NOT perform smoothing unless the sinogram formation step is done as well.
% 
% *Scatter correction (scatter_correction)* = If set to true, scatter correction 
% will be performed during sinogram formation or image reconstruction. In all 
% cases, the user will be prompted for the scatter correction data. The input 
% data (mat-file) must include a variable named SinScatter (sinogram data), scattered_coincidences 
% (raw data) or be the only variable in the file. In the first two cases, the 
% data can be scatter data created by OMEGA from a different MC scatter correction 
% simulation.
% 
% *Normalize scatter (normalize_scatter)* = If set to true, performs normalization 
% correction to the scatter correction data before the reconstruction phase. This 
% phase is ignored if the corrections are applied directly to the measured data 
% in which case it will be subtracted before the normalization correction.
% 
% *Scatter smoothing (scatter_smoothing)* = If true, performs smoothing to the 
% scatter data before corrections. The smoothing is a fixed 8x8 moving mean smoothing. 
% The window size can be adjusted in the original function |randoms_smoothing|.
% 
% *Attenuation correction (attenuation_correction)* = If true, performs attenuation 
% correction during the reconstruction. You need attenuation images scaled to 
% 511 keV for this. CT images can be scaled with the function |attenuationCT_to_511| 
% provided with OMEGA. DICOM CT images might automatically scale with |create_atten_matrix_CT|, 
% but currently it has been tested only with one machine. |attenuation122_to_511| 
% can be used to scale 122 keV blank/transmission data to 511 keV, i.e. GE-68 
% attenuation measurement.
% 
% *Attenuation datafile (attenuation_datafile)* = Name of the data file containing 
% the (scaled) attenuation images. Use full path if it is not on MATLAB/Octave 
% path. This is required if the attenuation correction is applied. One exception 
% is if you are using Inveon data and have an atn-file, you can then leave this 
% one blank and will be asked separately to input the atn-data.
% 
% *Compute normalization coefficients (compute_normalization)* = If true and 
% the main-file is run, then the input data will be used to compute the normalization 
% coefficients. Currently supported normalization correction components are axial 
% geometric correction (axial block profile and geometric factors), detector efficiency 
% (fan-sum algorithm for both sinogram and raw data or SPC for raw data), transaxial 
% block profile correction and transaxial geometric correction. Supports both 
% raw list-mode data or sinogram data. Transaxial geometric correction is not 
% recommended for objects that do not cover the entire FOV (or rather do not irradiate 
% the entire FOV region). The corresponding function will output the corrected 
% measurement data, the normalization matrix (multiplying this with the original 
% measurement data gives the same corrected data) and each individual correction 
% factors. Computation of the normalization coefficients follows the book [<https://github.com/villekf/OMEGA/wiki/Function-help#references 
% 1>]. Fan-sum algorithm, used in computing the detector efficiencies, can be 
% found from [<https://github.com/villekf/OMEGA/wiki/Function-help#references 
% 2>].
% 
% *Normalization options (normalization_options)* = A vector representing all 
% the four possible normalization correction steps that can be performed (see 
% above). 1 means that the method is included, 0 that it is excluded. E.g. the 
% default setting |[1 1 1 0] |computes axial geometric, detector efficiency and 
% transaxial block profile corrections, but not transaxial geometric correction.
% 
% *Phantom radius (normalization_phantom_radius)* = If the source phantom is 
% cylinder that is smaller than the FOV, input the radius of the cylinder here 
% (in cm). For an object encompassing the entire FOV, use an empty array |[]| 
% or |inf|.
% 
% *Scatter correction (normalization_scatter_correction)* = If a phantom, that 
% is smaller than the FOV, is used, compute the scatter correction for the data. 
% Requires the above cylinder radius and only supports sinogram data. For GATE 
% data it is recommended to use trues in the normalization correction in order 
% to skip this phase.
% 
% *Apply normalization (normalization_correction)* = Once the normalization 
% correction coefficients have been separately computed, turning this to true 
% will enable them in the sinogram formation or in the reconstruction phase.
% 
% *Apply user normalization (use_user_normalization)* = If this is true, then 
% the user will be prompted for the normalization correction data. This file can 
% be either a mat-file with one variable (the normalization coefficients, such 
% that normalized_data = un_normalized_data * normalization) or an Inveon PET 
% .nrm-file. In the latter case, the file needs to be exactly as output by the 
% Siemens software.
% 
% *Arc correction (arc_correction)* = Applies arc correction to the input sinogram 
% data. For the interpolation method, see below.
% 
% *Arc correction interpolation (arc_interpolation)* = Method used in the arc 
% correction interpolation. All methods supported either by |scatteredInterpolant| 
% or |griddata| are available. By default |scatteredInterpolant| is used, but 
% if the method is not supported by it |gridddata| is used. |griddata| is also 
% used if |scatteredInterpolant| is not found.
% 
% *Apply corrections during reconstruction (corrections_during_reconstruction)* 
% = If set to true, then the corrections are applied during the reconstruction 
% phase. I.e. uncorrected sinogram/raw data is automatically loaded and used in 
% the reconstruction process. The corrections data is also automatically loaded 
% (assuming it has been previously created). Smoothing and/or variance reduction 
% needs to be performed beforehand.
%% DYNAMIC IMAGING PROPERTIES
% Total time (tot_time) = The total time of the experiment (seconds). If you 
% have a static experiment, use inf to load all the data regardless of the total 
% time.
% 
% *Number of time step (partitions)* = How many time steps are in the dynamic 
% case.
% 
% *Start time (start)* = The start time for the data load (seconds). Any measurements 
% before this time will be ignored and will not be loaded.
% 
% *End time (end)* = The end time for the data load (seconds). Any measurements 
% after this time will be ignored and will not be loaded.
%% MISCELLANEOUS PROPERTIES
% Name (name) = Name of the experiment/simulation/whatever (char). Used for 
% naming purposes.
% 
% *Precompute necessary data (precompute)* = If this is true, then some of the 
% obligatory mat-files are computed that are required if the |options.precompute_lor| 
% is set to true. Otherwise, there is no need to pass the precomputation step. 
% All mat-files are saved in the |mat-files| folder.
% 
% *Path to the input data (fpath)* = This is the path to the folder where the 
% input data is (char). All the files for the specified GATE output will be read. 
% E.g. if you set use_ASCII to true, then from the folder specified by fpath, 
% all the .dat files with Coincidences in them will be loaded, for LMF all .ccs 
% files will be loaded and for Root all .root files will be loaded. If you use 
% Windows, use the |fpat| value after |ispc|, otherwise the one after |else|.
% 
% *Form only sinograms (only_sinos)* = If this is set to true, then running 
% the m-file only performs steps up to the sinogram formation. I.e. data is loaded 
% and then the sinogram is formed. No reconstructions, normalization coefficient 
% computations or precomputations will be done.
% 
% *Precompute the observation/system matrix (precompute_obs_matrix)* = Experimental 
% feature. Setting to true computes the entire system matrix on one go and will 
% most likely require a significant amount of memory (most likely over 100 GB). 
% Supports only MLEM reconstruction. If set to false, then the system matrix is 
% calculated on-the-fly (recommended).
% 
% *Only reconstructions (only_reconstruction)* = Setting to true skips all other 
% steps except the reconstruction phase. Precompute step is also skipped even 
% if set to true. All necessary data is loaded from the previously computed mat-files. 
% This step also overwrites ´only_sinos`.
% 
% *Use raw data (use_raw_data)* = Set this to true if you want to use raw list-mode 
% data. I.e. data that has not been compressed at all. This step requires its 
% own precompute phase if |options.precompute_lor = true|. The raw data in OMEGA 
% is formatted such that the saved measurement data is a vector formed from a 
% lower triangular matrix. This lower triangular matrix is extracted from a matrix 
% of size |total_number_of_detectors x total_number_of_detectors|. The matrix 
% contains all the possible line of response combinations, e.g. between detector 
% 1 and detector 3. Since the LOR between detectors 1 and 3 is the same as the 
% LOR between detectors 3 and 1, the upper triangular part is added to the lower 
% triangular part before the lower triangular part is extracted. The raw date 
% is always saved in cell format, regardless of the number of time steps. Non-cell 
% data should work, but cell data is recommended.
% 
% *How many pixels a LOR traverses (precompute_lor)* = When true, this option 
% changes the reconstruction process quite radically. First, it requires its own 
% precompute phase. Secondly, it affects greatly on how the system matrix is formed. 
% With this option set to true, the number of pixels each LOR traverses is determined 
% beforehand. For implementation 1 this allows for more efficient memory management, 
% while with other methods the computational speed is enhanced (more for raw data). 
% This step is recommended if you use implementation 1. Improved Siddon’s algorithm 
% with more than 1 rays is not supported when this is true.
% 
% *Precompute everything (precompute_all)* = This option causes the prepass 
% phase to compute all mat-files even if they were not selected. E.g. if you use 
% sinogram data, also all precomputations for raw list-mode data are done.
% 
% *Status messages (verbose)* = If this is set to true, then you will receive 
% occasional status messages and also elapsed time of functions.
%% RECONSTRUCTION PROPERTIES
% *IMPLEMENTATIONS*
% 
% In OMEGA the different ways to compute the different algorithms and projections 
% is referred to as implementations.
% 
% *Implementation (reconstruction_method)* = This option determines how the 
% reconstructions and the system matrix are computed. In all cases the system 
% matrix is done through a mex-file (implementation 1 does have fallback non-mex 
% system matrix formation method, but that is very slow).
% 
% If set to 1, then all the reconstructions will be done purely in MATLAB using 
% nothing but MATLAB commands. Implementation 1 also supports all algorithms available.
% 
% Implementation 2 is an OpenCL/ArrayFire reconstruction, and everything is 
% done in a mex-file. This is a matrix-free method. In Implementation 2 both the 
% system matrix creation and reconstruction are performed on the selected device. 
% Supports all the same algorithms as implementation 1 except non-local means 
% prior (there is preliminary beta support). AD-MRP prior also behaves differently.
% 
% Implementation 3 uses pure OpenCL, i.e. not requiring ArrayFire libraries. 
% This is a matrix-free method. Implementation 3, however, only supports OSEM 
% and MLEM, but does support multi-device computation. The multi-device computation 
% consists using of multiple GPUs (from the same manufacturer) or using GPU + 
% CPU combination (from the same manufacturer).
% 
% If set to 4, then all the computations are done parallel on the CPU by using 
% OpenMP (if supported by the compiler). This is a matrix-free method. This implementation 
% does not require OpenCL and should work on all CPUs. All CPUs/cores are used 
% automatically. Supported algorithms are MLEM, OSEM, RAMLA, ROSEM, OSL-MLEM, 
% OSL-OSEM, BSREM and ROSEM-MAP. All priors are supported. Only one MLEM-based 
% algorithm and one OS-based algorithm are supported (with one prior) at a time. 
% E.g. you can have MLEM and OSL-OSEM with NLM, but not OSEM and OSL-OSEM.
% 
% In Implementations 2 and 3, the system matrix is created by using single precision 
% numbers, meaning that it can be slightly inaccurate when compared to Implementations 
% 1 and 4 that use double precision numbers.
% 
% On which implementation to select, see Recommendations.
% 
% *Device (use_device)* = This determines the device used in implementation 
% 2 and the platform in 4. For implementation 2 the devices mean the actual devices 
% available that are either CPUs, GPUs or accelerators, with GPUs usually being 
% first in the list (0 should use always use your GPU if you have one). Use |ArrayFire_OpenCL_device_info()| 
% to determine the devices you have and their respective number. For implementation 
% 4, the platforms are divided by manufacturer. Same manufacturer can have multiple 
% platforms, however, if you have multiple OpenCL runtimes installed. Use |OpenCL_device_info()| 
% to see the available platforms and the devices included in each of them. In 
% implementation 4, by default, all the devices associated with certain platform 
% are used except devices that have less than 2 GB of memory. Single device can 
% also be selected with the |options.cpu_to_gpu_factor| (see below).
% 
% *64 bit atomics (use_64bit_atomics)* = If true, then the 64 bit atomic functions 
% are used. This affects ONLY implementations 2 and 3. If your device does not 
% support 64-bit atomics, the result will be equivalent to setting this to false. 
% Intel hardware usually do not support 64-bit atomics, but AMD or Nvidia GPUs 
% should. Setting this to false will cause slower computations if the 64-bit atomics 
% are supported but can be slightly more reliable and accurate.
% 
% *Force build (force_build)* = If true, forces the building of the OpenCL binaries. 
% Affects only implementation 2. By default, OMEGA precompiles OpenCL binaries 
% for each device on the first run but setting this to true will cause the binaries 
% to be rewritten to be built even if they had been previously built. Necessary 
% when hardware changes occur, or new OMEGA versions are installed and recommended 
% after driver updates.
% 
% *CPU to GPU factor (cpu_to_gpu_factor)* = Affects only implementation 3. This 
% variable has dual purpose. The first purpose is in heterogeneous computing by 
% delegating more LORs to the GPU part. E.g. if this is set to 2, then the GPU 
% will have 2x more LORs compared to the CPU. Another use is obtained by setting 
% this to 0, when it will use only a single device from the platform. GPUs are 
% prioritized with the GPU having the most memory taken.
% 
% *PROJECTOR*
% 
% *Projector used (projector_type)* = Two different projectors are available 
% for all implementations. These are the improved Siddon’s algorithm (1) and orthogonal 
% distance-based ray tracer (2). Implementation 1, when |options.precompute_lor 
% = false| also has the original Siddon’s ray tracer (0).
% 
% *Strip width (tube_width_xy)* = Affects only orthogonal distance-based ray 
% tracer. This is the maximum distance from the ray to a voxel center allowed 
% in the projector in 2D (x- and y-directions). I.e. the width of the strip of 
% response.
% 
% *Tube width (tube_width_z)* = Affects only orthogonal distance-based ray tracer. 
% This is the maximum distance from the ray to a voxel center allowed in the projector 
% in 3D (x-, y- and z-directions). I.e. the width and height of the tube of response. 
% Only square tubes are allowed; if this is non-zero, any value in |tube_width_xy| 
% is ignored.
% 
% *Accuracy factor (accuracy_factor)* = Affects only orthogonal distance-based 
% ray tracer in 3D mode. This value determines the minimum distance in voxels 
% where the distance is computed. Higher values allow for more accurate estimates 
% while also taking longer to compute. The default value (5) should be good in 
% most cases, though more accurate image sizes might benefit from higher value.
% 
% *Number of rays (n_rays)* = Affects only improved Siddon’s algorithm when 
% |options.precompute_lor = false| and using any implementation other than 1 (i.e. 
% works with implementations 2, 3 and 4). Allowed values range from 1 to 5, though 
% it is recommended to use either 1 or 5. When using 5 rays, the pattern follows 
% that of number five in six-sided dice.
% 
% *RECONSTRUCTION SETTINGS*
% 
% *Number of iterations (Niter)* = The number of iterations.
% 
% *Number of subsets (subsets)* = In subset methods, this value determines the 
% number of subsets that the sinogram/raw data is divided into. Depending on the 
% data type used (sinogram or raw), there are several different ways to select 
% the subsets (see below |subset_type|).
% 
% *Type of subset division (subset_type)* = Six different methods, numbered 
% from 1 to 6, to sort the measurements into subsets.
% 
% 1 = Every nth column is taken in order (sinogram only), e.g. once the end 
% of the column is reached, indexing starts from the first column again in the 
% next row.
% 
% 2 = Every nth row (both sinogram and raw data, default in raw data), once 
% the end of the row is reached, indexing starts from the first row again in the 
% next column.
% 
% 3 = The measurements are taken randomly, by default uses |randperm|, but can 
% use the file exchange |Shuffle| (see below) for faster speed and better memory 
% use.
% 
% 4 = Every nth column from the sinogram, takes an entire column and then jumps 
% n columns to the next.
% 
% 5 = Every nth row from the sinogram, takes an entire row and then jumps n 
% row to the next.
% 
% 6 = Uses n number of angles to form each subset. First the LORs are sorted 
% according to the angle they create with the (positive) x-axis. Then |n_angles| 
% (see below) angles are grouped together to form one subset. E.g. if |n_angles 
% = 2| then angles 0 and 1 form one subset, 2 and 3 another, etc. For 2D slices 
% there will be a total of 180°/nangles subsets and 360°/nangles for 3D. This 
% method is explained in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [4>].
% 
% 7 = Uses golden angle sampling to select the subsets. Each sinogram uses the 
% same number of angles and the same angles, the golden angle sampling is thus 
% performed on single sinogram basis. The next angle is selected such that the 
% difference is roughly the same as the golden angle (approx. 111.246°). Currently 
% this subset sampling is supported only by sinogram data.
% 
% *Number of angles (n_angles)* = If the above method 6 is selected, this value 
% is used to determine how many angles are used in one subset.
% 
% *Initial value (x0)* = The initial value of all of the reconstruction methods. 
% In dynamic studies all the time steps have the same initial value.
% 
% *Epsilon value (epps)* = This small value is added to divisions to prevent 
% division by zero.
% 
% *MISC SETTINGS*
% 
% *Use Shuffle (use_Shuffle)* = Whether the MATLAB file exchange code <https://se.mathworks.com/matlabcentral/fileexchange/27076-shuffle 
% Shuffle> is used. Applies only to |subset_type = 3|. Speeds up the pre-process 
% a bit and also uses less memory.
% 
% *Use FSparse (use_fsparse)* = Whether <https://github.com/stefanengblom/stenglib 
% FSparse> is used. Only used if precompute_lor is set to false.
% 
% *MRP-type prior without normalization (med_no_norm)* = Normally MPR-type priors 
% (MRP, FMH, L-filter, AD and weighted mean) are of the form (λ - Mb)/Mb. If this 
% is set to true, then the denominator (normalization) is removed (i.e. (λ - Mb)/1).
% 
% *RECONSTRUCTION ALGORITHMS*
% 
% *Use MLEM/OSEM/etc.* = When any of these are set to true, the specific algorithm 
% is computed. This is dependent on the selected implementation. Separate sections 
% are for the maximum likelihood-based methods, maximum a posteriori methods and 
% priors. MAP methods require at least one prior and priors require at least one 
% MAP method.
% 
% *ACOSEM properties* = Only the acceleration factor can be adjusted. See the 
% original article for details.
% 
% *MRAMLA/MBSREM properties* = Relaxation parameter and the upper bound can 
% be adjusted.
% 
% *RAMLA/BSREM properties* = Relaxation parameter can be adjusted.
% 
% *ROSEM properties* = Relaxation parameter can be adjusted.
% 
% *DRAMA properties* = Parameters α, β and β0 can be adjusted. See [4], e.g. 
% eq. (20).
% 
% *Neighborhood properties* = Adjust how many neighboring voxels are taken into 
% account (|Ndx|, |Ndy| and |Ndz|). Used in MRP, quadratic prior, FMH, L-filter, 
% weighted mean and NLM.
% 
% *MRP properties* = Regularization parameters for all MAP-methods can be adjusted.
% 
% *Quadratic prior properties* = Regularization parameters for all MAP-methods 
% can be adjusted.
% 
% Custom weights can be input. The weights vector should be of size |(Ndx*2+1) 
% * (Ndy*2+1) * (Ndz*2+1)| and the middle value inf.
% 
% *L-filter properties* = Regularization parameters for all MAP-methods can 
% be adjusted.
% 
% Custom weights can be input. The weights vector should be of size |(Ndx*2+1) 
% * (Ndy*2+1) * (Ndz*2+1)| (middle value is NOT inf).
% 
% If custom weights are not given, the |options.oneD_weights| determines whether 
% 1D (true) or 2D (false) weighting scheme is used. In 1D case, if |(Ndx*2+1) 
% * (Ndy*2+1) * (Ndz*2+1)| = 3, = 9 or = 25 then the weights are exactly as in 
% literature <https://github.com/villekf/OMEGA/wiki/Function-help#references [5>]. 
% Otherwise the pattern follows a <https://en.wikipedia.org/wiki/Laplace_distribution 
% Laplace distribution>. In 2D case, the weights follow Laplace distribution, 
% but are also weighted based on the distance of the neighboring voxel from the 
% center voxel. For Laplace distribution, the mean value is set to 0 and b = 1/sqrt(2). 
% The weights are normalized such that the sum equals 1.
% 
% *FMH properties* = Regularization parameters for all MAP-methods can be adjusted.
% 
% Custom weights can be input. The weights vector should be of size |[Ndx*2+1, 
% 4]| if |Nz = 1| or |Ndz = 0| or ´[Ndx*2+1, 13]´ otherwise. The weight for the 
% center pixel should also be the middle value when the weight matrix is in vector 
% form. The weights are normalized such that the sum equals 1.
% 
% If custom weights are not provided, then the |options.fmh_center_weight| parameter 
% is needed. Default value is 4 as in the original article <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [6>].
% 
% *Weighted mean properties* = Regularization parameters for all MAP-methods 
% can be adjusted.
% 
% Custom weights can be input. The weights vector should be of size |(Ndx*2+1) 
% * (Ndy*2+1) * (Ndz*2+1)|.
% 
% If custom weights are not provided, then the |options.weighted_center_weight| 
% parameter is needed. Default value is 4 as in the original article <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [6>]
% 
% *TV properties* = Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.TVsmoothing| is a "smoothing" parameter that also prevents zero in 
% square root (it is summed to the square root values). (variable β in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [7>] eq. 11 and <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [8>] eq. 13).
% 
% If |options.TV_use_anatomical = true|, then an anatomical prior is used in 
% TV regularization. |options.TV_reference_image| is the name of the file containing 
% the anatomical reference images (image size needs to be the same as the reconstructed 
% images). The reference images need to be the only variable in the file.
% 
% |options.TVtype| controls the type of TV regularization used. For |TVtype 
% = 1| see <https://github.com/villekf/OMEGA/wiki/Function-help#references [7>], 
% |TVtype = 2| <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [8>] and |TVtype = 3| <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [9>]. If no anatomical prior is used, then type 1 and 2 are the same. Type 3 
% uses the same weights as quadratic prior.
% 
% |options.T| is the edge threshold parameter in type 1 (variable C in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [7>], see e.g. eq. 8), scale parameter for side information in type 2 (variable 
% γ in <https://github.com/villekf/OMEGA/wiki/Function-help#references [8>], see 
% eq. 13), weight parameter for anatomical information in type 2 (variable η in 
% <https://github.com/villekf/OMEGA/wiki/Function-help#references [9>], see eq. 
% 11).
% 
% |options.C| is the weight of the original image in type 3 (variable δ in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [9>], see e.g. eq. 11).
% 
% All TV types are isotropic.
% 
% *MRP-AD properties* = In MRP-AD, the median filtered image is replaced with 
% anisotropic diffusion smoothed image. I.e. if MAD is the anisotropic diffusion 
% smoothed image, the prior is (λ - MAD)/MAD. Using this with implementation 1 
% requires the Image Processing Toolbox. This prior does not work on Octave.
% 
% Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.TimeStepAD| is the time step for the AD filter (implementation 2 
% only). More information <http://arrayfire.org/docs/group__image__func__anisotropic__diffusion.htm 
% here>.
% 
% |options.KAD| is the conductivity/connectivity parameter. More information 
% <https://se.mathworks.com/help/images/ref/imdiffusefilt.html here> and <http://arrayfire.org/docs/group__image__func__anisotropic__diffusion.htm 
% here>.
% 
% |options.NiterAD| number of iterations for the AD smoothing part.
% 
% |options.FluxType| is the flux/conduction type. Available methods are Exponential 
% (1) and Quadratic (2). E.g. |options.FluxType = 2| uses quadratic.
% 
% |options.DiffusionType| is the diffusion type (implementation 2 only). Available 
% methods are Gradient (1) and Modified curvature (2). E.g. |options.DiffusionType= 
% 2| uses modified curvature.
% 
% *APLS properties* = Using asymmetric parallel level sets requires the use 
% of anatomic prior. Without anatomical prior it functions as TV types 1 and 2.
% 
% Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.eta| is a scaling parameter in regularized norm (see variable η in 
% <https://github.com/villekf/OMEGA/wiki/Function-help#references [8>]).
% 
% |options.APLSsmoothing| is a "smoothing" parameter that also prevents zero 
% in square root (it is summed to the square root values). Has the same function 
% as the |TVsmoothing| parameter (see <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [8>] eq. 9).
% 
% |options.APLS_reference_image| is the name of the file containing the anatomical 
% reference images (image size needs to be the same as the reconstructed images). 
% The reference images need to be the only variable in the file.
% 
% *TGV properties* = Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.betaTGV| is the first weighting value for the TGV (see parameter 
% α1 in <https://github.com/villekf/OMEGA/wiki/Function-help#references [10>]).
% 
% |options.alphaTGV| is the second weighting value for the TGV (see parameter 
% α0 in <https://github.com/villekf/OMEGA/wiki/Function-help#references [10>]). 
% Weight for the symmetrized derivative.
% 
% |options.NiterTGV| number of iterations for the TGV smoothing part.
% 
% *NLM properties* = Non-local means is only supported by implementation 1 at 
% the moment.
% 
% Regularization parameters for all MAP-methods can be adjusted.
% 
% |options.sigma| is the filtering parameter (see parameter h in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [11>] or σ in <https://github.com/villekf/OMEGA/wiki/Function-help#references 
% [12>], eq. 6).
% 
% The patch radius is controlled with parameters |options.Nlx|, |options.Nly| 
% and |options.Nlz|. The similarity is investigated in this area.
% 
% The strength of the Gaussian weighting (standard deviation) of the weights 
% can be adjusted with |options.NLM_gauss|.
% 
% If |options.NLM_use_anatomical = true| then an anatomical reference image 
% is used in the similarity search of the neighborhood. Normally the original 
% image is used for this. |options.NLM_reference_image| is the name of the anatomical 
% reference data file. The reference images need to be the only variable in the 
% file.
% 
% If you wish to use non-local total variation, set |options.NLTV = true|. This 
% overwrites the MRP selection (see below). All other NLM options apply.
% 
% NLM can also be used like MRP (and MRP-AD) where the median filtered image 
% is replaced with NLM replaced image. This is achieved by setting |options.NLM_MRP 
% = true|. This is computed without normalization ((λ - MNLM)/1). All other NLM 
% options apply.
%% Load measurement data
% This function is for non-GATE data ONLY (|main_nongate.m|).
% 
% The function |loadMeasurementData| allows you to load  measurement data in 
% different formats. Curently supported are  MATLAB-data, NIfTI, Analyze 7.5, 
% DICOM, Interfile, MetaImage, and raw  data. Analyze requires <https://se.mathworks.com/matlabcentral/fileexchange/8797-tools-for-nifti-and-analyze-image 
% Tools for NIfTI and ANALYZE image> from MathWorks file exchange, NIfTI either 
% image processing toolbox or  Tools for NIfTI and ANALYZE image and DICOM support 
% requires image  processing toolbox on MATLAB and dicom package on Octave (untested 
% on  Octave).
% 
% The data is saved in the |options| structure, either in |SinM| (sinogram data) 
% or |coincidences| (raw list-mode data).
% 
% Raw data can be of any type, but if raw data other than int32 is used, then 
% it has to be specified. E.g. |options = loadMeasurementData(options,'uint16')| 
% loads 16-bit unsigned integer data. If the raw data has a header of _n_ bytes, 
% it can be skipped by specifying the number of bytes (e.g. |options = loadMeasurementData(options,'uint16', 
% n)|. If the header is at the end of the file, using a negative value will ignore 
% the last _n_ bytes. The data is saved in the |options| structure.
% 
% Raw list-mode data can only be used with MATLAB-data.
% 
% DICOM data currently supports only 2D slices.
% 
% The user should also always check that the output measurement data looks correct 
% (e.g. |imagesc(options.SinM(:,:,30))|).
##### SOURCE END #####
--></body></html>