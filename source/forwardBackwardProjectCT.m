%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (C) 2021 Ville-Veikko Wettenhovi
%
% This program is free software: you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation, either version 3 of the License, or (at your
% option) any later version.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
% Public License for more details.
%
% You should have received a copy of the GNU General Public License along
% with this program. If not, see <https://www.gnu.org/licenses/>.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classdef forwardBackwardProjectCT
    %FORWARDBACKWARDPROJECTCT A MATLAB class for computing the backward and
    %forward projections in OMEGA or forming the entire system matrix for
    %transmission tomography (e.g. computed tomography (CT))
    %   Simplified version of the forward_backward_projections_example.m
    %   (an example of this class is included in the same file).
    
    properties
        OProperties
        n_meas
        nn
        sens
        subset
        index
        sysmat
        trans
        n_meas_subs
        TOF
    end
    
    methods
        function obj = forwardBackwardProjectCT(options, varargin)
            %FORWARDBACKWARDPROJECT Construct an instance of this class
            %   Input is the options struct generated by any of the (CT)
            %   main-files. All parameters should be adjusted in the
            %   corresponding main-file, though manual adjustment is also
            %   possible. However, the object should be always re-created
            %   after any parameters are changed, otherwise the
            %   reconstructions may not work or might produce wrong
            %   results.
            %
            %   Alternatively, the user can manually input the necessary
            %   variables. Two possibilities are available in this case. 
            %   In the first case the inputs are the projection
            %   angles (also the total number of projections), number of
            %   rows in a projection, number of columns in a projection,
            %   image size, FOV sizes (mm), the detector pitch/size, source
            %   to detector distance (mm) and source to center of rotation
            %   distance (mm). Second possibility is to input manually the
            %   detector coordinates (x, y, and z coordinates). x should be
            %   horizontal and y the vertical, while z is the axial
            %   direction. These should be row vectors of size [N 2], i.e.
            %   with 2 columns. The source coordinates are assumed to be in
            %   the second column. The number of coordinates should equal
            %   the total number of projection bins (i.e. numel(x)/2 ==
            %   numel(projectionImages). The other inputs are the same as
            %   previously, except that sourceToDetector, sourceToCRot and
            %   dPitch are not needed. 
            %
            %   When using manual inputs the projector is always improved
            %   Siddon. The number of subsets can be optionally specified,
            %   with the default being no subsets (i.e. subsets = 1).
            %   Default implementation is 4, but it can be changed to 3
            %   (OpenCL) in which case the default platform is 0, but this
            %   can be changed as well. Only one device is used at all
            %   times. 
            %   Examples:
            %       A = forwardBackwardProjectCT(options);
            %       A = forwardBackwardProjectCT(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot);
            %       A = forwardBackwardProjectCT(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot, 
            %           horizontalOffset, bedOffset);
            %       A = forwardBackwardProjectCT(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot, 
            %           horizontalOffset, bedOffset, subsets);
            %       A = forwardBackwardProjectCT(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot, 
            %           horizontalOffset, bedOffset, subsets, implementation, use_device);
            %       A = forwardBackwardProjectCT(angles, Prows, Pcolumns, Nx, Ny, Nz, FOV_tr, axial_fov, dPitch, sourceToDetector, sourceToCRot, 
            %           [], [], [], implementation, use_device);
            %       A = forwardBackwardProjectCT(x, y, z, Nx, Ny, Nz, FOV_tr, axial_fov, subsets, implementation, use_device);
            %   INPUTS:
            %       angles = The angles corresponding to the projections,
            %       can be either degrees or radians (degrees will be
            %       converted to radians). If you have multiple bed
            %       positions (step and shoot), then this must include the
            %       angles of each bed positions. E.g. if you have 2 bed
            %       positions with 50 projections each, then numel(angles)
            %       has to be 100 for correct operation. If each bed
            %       position uses the same angles, then simply use repmat
            %       to repeat the angles-vector (e.g. repmat(angles,
            %       nBedPositions,1), assuming a column vector).
            %       Prows = The number of rows in a single projection
            %       image.
            %       Pcolumns = The number of columns in a single projection
            %       image (if you use sinogram data, set this to 1).
            %       Nx = Image size (in voxels) in x-direction.
            %       Ny = Image size (in voxels) in y-direction.
            %       Nz = Image size (in voxels) in z-direction.
            %       FOV_tr = FOV size in transaxial direction (mm).
            %       axial_fov = FOV size in axial direction (mm). For 2D
            %       cases, use the detector pitch.
            %       dPitch = The detector/pixel pitch/size (mm).
            %       sourceToDetector = The (orthogonal) distance (in mm)
            %       from the source to the detector.
            %       sourceToCRot = The (orthogonal) distance (in mm)
            %       from the source to the center of rotation.
            %       horizontalOffset = (Optional) The horizontal offset of
            %       the source (mm). Can be a vector containing different
            %       offset for each projection. Default is 0.
            %       bedOffset = (Optional) The different offsets for the
            %       bed positions. The number of bed bed positions is
            %       assumed to be the number of offset values (first should
            %       be 0). Default is scalar 0.
            %       subsets = (Optional) Number of subsets. Default is 1.
            %       implementation = (Optional) Implementation to use (1, 3
            %       and 4 are supported). Default is 4.
            %       use_device = (Optional) (Implementation 3 only) the
            %       OpenCL platform used. Default is 0.
            %       x = x (horizontal/column) coordinates (mm)
            %       y = y (vertical/row) coordinates (mm)
            %       z = z (axial) coordinates (mm)
            %
            % OUTPUTS:
            %       A = The class object.
            
            if nargin > 1 && isvector(options) && isscalar(varargin{1})
                obj.OProperties.angles = options;
                obj.OProperties.ySize = varargin{1};
                obj.OProperties.xSize = varargin{2};
                obj.OProperties.Nx = varargin{3};
                obj.OProperties.Ny = varargin{4};
                obj.OProperties.Nz = varargin{5};
                obj.OProperties.FOVa_x = varargin{6};
                obj.OProperties.FOVa_y = obj.OProperties.FOVa_x;
                obj.OProperties.axial_fov = varargin{7};
                obj.OProperties.dPitch = varargin{8};
                obj.OProperties.sourceToDetector = varargin{9};
                obj.OProperties.sourceToCRot = varargin{10};
                if nargin >= 12 && ~isempty(varargin{11})
                    obj.OProperties.horizontalOffset = varargin{11};
                else
                    obj.OProperties.horizontalOffset = 0;
                end
                if nargin >= 13 && ~isempty(varargin{12})
                    obj.OProperties.bedOffset = varargin{12};
                else
                    obj.OProperties.bedOffset = 0;
                end
                if nargin >= 14 && ~isempty(varargin{13})
                    obj.OProperties.subsets = varargin{13};
                else
                    obj.OProperties.subsets = 1;
                end
                if nargin >= 15 && ~isempty(varargin{14})
                    obj.OProperties.implementation = varargin{14};
                else
                    obj.OProperties.implementation = 4;
                end
                if nargin >= 16 && ~isempty(varargin{15})
                    obj.OProperties.use_device = varargin{15};
                else
                    obj.OProperties.use_device = 0;
                end
                obj.OProperties.nBed = numel(obj.OProperties.bedOffset);
                obj.OProperties.nProjections = numel(obj.OProperties.angles);
                obj.OProperties.simple = false;
                obj.OProperties.use_64bit_atomics = true;
                obj.OProperties.verbose = true;
                obj.OProperties.tube_width_z = 0;
                obj.OProperties.tube_radius = 0;
                obj.OProperties.voxel_radius = 0;
                obj.OProperties.projector_type = 1;
                obj.OProperties.use_psf = false;
                obj.OProperties.FWHM = 0;
                obj.OProperties.subset_type = 3;
                obj.OProperties.use_Shuffle = false;
            elseif nargin > 1 && (ismatrix(options) || isvector(options)) && (ismatrix(varargin{1}) || isvector(varargin{1}))
                obj.OProperties.x = options;
                obj.OProperties.y = varargin{1};
                obj.OProperties.z = varargin{2};
                if isvector(obj.OProperties.x)
                    obj.OProperties.x = reshape(obj.OProperties.x, [], 2);
                end
                if isvector(obj.OProperties.y)
                    obj.OProperties.y = reshape(obj.OProperties.y, [], 2);
                end
                if isvector(obj.OProperties.z)
                    obj.OProperties.z = reshape(obj.OProperties.z, [], 2);
                end
                obj.OProperties.Nx = varargin{3};
                obj.OProperties.Ny = varargin{4};
                obj.OProperties.Nz = varargin{5};
                obj.OProperties.FOVa_x = varargin{6};
                obj.OProperties.FOVa_y = obj.OProperties.FOVa_x;
                obj.OProperties.axial_fov = varargin{7};
                obj.OProperties.simple = true;
                obj.OProperties.dPitch = 0;
                obj.OProperties.sourceToDetector = 0;
                obj.OProperties.sourceToCRot = 0;
                if nargin >= 9 && ~isempty(varargin{8})
                    obj.OProperties.subsets = varargin{8};
                else
                    obj.OProperties.subsets = 1;
                end
                if nargin >= 10 && ~isempty(varargin{9})
                    obj.OProperties.implementation = varargin{9};
                else
                    obj.OProperties.implementation = 4;
                end
                if nargin >= 11 && ~isempty(varargin{10})
                    obj.OProperties.use_device = varargin{10};
                else
                    obj.OProperties.use_device = 0;
                end
                obj.OProperties.angles = 0;
                obj.OProperties.ySize = 1;
                obj.OProperties.xSize = 1;
                obj.OProperties.nBed = 1;
                obj.OProperties.nProjections = 1;
                obj.OProperties.simple = true;
                obj.OProperties.use_64bit_atomics = true;
                obj.OProperties.verbose = true;
                obj.OProperties.tube_width_z = 0;
                obj.OProperties.tube_radius = 0;
                obj.OProperties.voxel_radius = 0;
                obj.OProperties.projector_type = 1;
                obj.OProperties.use_psf = false;
                obj.OProperties.FWHM = 0;
                obj.OProperties.subset_type = 3;
                obj.OProperties.use_Shuffle = false;
            else
                obj.OProperties = options;
                obj.OProperties.simple = false;
            end
            if ~isfield(obj.OProperties, 'verticalOffset')
                obj.OProperties.verticalOffset = 0;
            end
            if ~isfield(obj.OProperties, 'horizontalOffset')
                obj.OProperties.horizontalOffset = 0;
            end
            obj.OProperties.NSinos = obj.OProperties.nProjections;
            obj.OProperties.TotSinos = obj.OProperties.nProjections;
            if ~isfield(obj.OProperties,'bedOffset')
                obj.OProperties.bedOffset = 0;
            end
            if ~isfield(obj.OProperties,'nBed')
                obj.OProperties.nBed = 1;
            end
            obj.OProperties.span = 3;
            obj.OProperties.segment_table = [];
            obj.OProperties.Ndist = obj.OProperties.ySize;
            obj.OProperties.Nang = obj.OProperties.xSize;
            obj.OProperties.use_raw_data = false;
            obj.OProperties.randoms_correction = false;
            obj.OProperties.scatter_correction = false;
            obj.OProperties.scatter = false;
            obj.OProperties.attenuation_correction = false;
            obj.OProperties.normalization_correction = false;
            obj.OProperties.vaimennus = 0;
            obj.OProperties.global_correction_factor = 1;
            obj.OProperties.partitions = 1;
            obj.OProperties.reconstruct_trues = false;
            obj.OProperties.reconstruct_scatter = false;
            obj.OProperties.machine_name = 'CT';
            obj.OProperties.corrections_during_reconstruction = false;
            obj.OProperties.precompute_obs_matrix = false;
            obj.OProperties.precompute_all = false;
            obj.OProperties.diameter = 0;
            obj.OProperties.pseudot = [];
            obj.OProperties.rings = obj.OProperties.xSize * obj.OProperties.nBed;
            obj.OProperties.det_per_ring = obj.OProperties.ySize * obj.OProperties.nProjections;
            obj.OProperties.precompute_lor = false;
            obj.OProperties.sampling = 1;
            obj.OProperties.CT = true;
            obj.OProperties.start = 0;
            obj.OProperties.arc_correction = false;
            obj.OProperties.tot_time = 0;
            obj.OProperties.fill_sinogram_gaps = false;
            obj.OProperties.det_w_pseudo = obj.OProperties.det_per_ring;
            obj.OProperties.blocks_per_ring = 1;
            obj.OProperties.linear_multip = 0;
            obj.OProperties.cryst_per_block = obj.OProperties.xSize * obj.OProperties.ySize;
            obj.OProperties.cr_pz = obj.OProperties.dPitch;
            obj.OProperties.deblurring = false;
            obj.OProperties.deblur_iterations = 0;
            obj.OProperties.tube_width_xy = 0;
            obj.OProperties.det_w_pseudo = obj.OProperties.det_per_ring;
            obj.OProperties.n_rays_transaxial = 1;
            obj.OProperties.n_rays_axial = 1;
            obj.OProperties.pseudot = [];
            obj.OProperties.apply_acceleration = false;
            obj.OProperties.cpu_to_gpu_factor = 0;
            obj.OProperties.name = '';
            if ~isfield(obj.OProperties,'flip_image')
                obj.OProperties.flip_image = false;
            end
            if ~isfield(obj.OProperties,'offangle')
                obj.OProperties.offangle = 0;
            end
            obj.OProperties.ndist_side = 1;
            obj.OProperties.epps = 1e-8;
            obj.OProperties.segment_table = 0;
            obj.OProperties.listmode = false;
            obj.OProperties.lor_a = [];
            obj.OProperties.lor_orth = [];
            obj.OProperties.CT = true;
            if max(abs(obj.OProperties.angles(:))) > 2*pi
                obj.OProperties.angles = obj.OProperties.angles * (pi / 180);
            end
            if obj.OProperties.implementation == 1 %&& obj.OProperties.xSize > 1
                obj.OProperties.precompute_lor = true;
            else
                obj.OProperties.precompute_lor = false;
            end
            if obj.OProperties.implementation == 1 && obj.OProperties.precompute_lor
                storeMatrix = true;
            else
                storeMatrix = false;
            end
            if (isfield(obj.OProperties,'x') && isfield(obj.OProperties,'y') && (isfield(obj.OProperties,'z') || isfield(obj.OProperties,'z_det')))
%                 obj.index = uint32(1:numel(obj.OProperties.x)/2)';
                obj.OProperties.listmode = true;
                obj.OProperties.diameter = 0;
                det_per_ring = numel(obj.OProperties.x) / 2;
                obj.OProperties.Nang = det_per_ring;
                obj.OProperties.xSize = det_per_ring;
                obj.OProperties.ySize = det_per_ring;
                if obj.OProperties.subsets > 1 || (obj.OProperties.implementation == 1 && ~obj.OProperties.precompute_lor)
                    obj.OProperties.precompute_lor = false;
                    [obj.index, obj.n_meas, obj.OProperties.subsets, obj.OProperties.lor_a, obj.OProperties.lor_orth] = index_maker(obj.OProperties.Nx, obj.OProperties.Ny, obj.OProperties.Nz, obj.OProperties.subsets, obj.OProperties.use_raw_data, ...
                        obj.OProperties.machine_name, obj.OProperties, obj.OProperties.Nang, obj.OProperties.Ndist, obj.OProperties.TotSinos, obj.OProperties.NSinos,storeMatrix);
                    if ~isempty(obj.index) && iscell(obj.index)
                        obj.index = cell2mat(obj.index);
                    end
                    obj.OProperties.x = obj.OProperties.x(obj.index,:);
                    obj.OProperties.y = obj.OProperties.y(obj.index,:);
                    if isfield(obj.OProperties,'z')
                        obj.OProperties.z = obj.OProperties.z(obj.index,:);
                    else
                        obj.OProperties.z_det = obj.OProperties.z_det(obj.index,:);
                    end
                    if obj.OProperties.implementation == 1
                        obj.OProperties.precompute_lor = true;
                    end
                end
                obj.n_meas = floor(det_per_ring / obj.OProperties.subsets);
                obj.n_meas = int64([repmat(obj.n_meas,obj.OProperties.subsets - 1,1); det_per_ring - obj.n_meas*(obj.OProperties.subsets - 1)]);
%                 if abs(min(obj.OProperties.x(:))) + abs(max(obj.OProperties.x(:))) > obj.OProperties.diameter
%                     obj.OProperties.diameter = abs(min(obj.OProperties.x(:))) + abs(max(obj.OProperties.x(:)));
%                 end
            else
                if obj.OProperties.subsets > 1 || (obj.OProperties.implementation == 1 && ~obj.OProperties.precompute_lor)
                    [obj.index, obj.n_meas, obj.OProperties.subsets, obj.OProperties.lor_a, obj.OProperties.lor_orth] = index_maker(obj.OProperties.Nx, obj.OProperties.Ny, obj.OProperties.Nz, obj.OProperties.subsets, obj.OProperties.use_raw_data, ...
                        obj.OProperties.machine_name, obj.OProperties, obj.OProperties.Nang, obj.OProperties.Ndist, obj.OProperties.TotSinos, obj.OProperties.NSinos);
                else
                    obj.n_meas = int64(obj.OProperties.nProjections * obj.OProperties.ySize * obj.OProperties.xSize);
                    obj.index = 0;
                end
            end
            obj.nn = [int64(0);int64(cumsum(obj.n_meas))];
            if ~isempty(obj.index) && iscell(obj.index)
                obj.index = cell2mat(obj.index);
            end
            obj.n_meas_subs = obj.n_meas;
            if obj.OProperties.subsets > 1
                obj.n_meas = [int64(0);int64(cumsum(obj.n_meas))];
            end
            if obj.OProperties.subsets == 1
                obj.subset = 1;
            end
            
            
            if ~isfield(obj.OProperties,'use_machine')
                obj.OProperties.use_machine = 0;
            end
            if ~isfield(obj.OProperties,'TOF_bins') || obj.OProperties.TOF_bins == 0
                obj.OProperties.TOF_bins = 1;
            end
            if ~isfield(obj.OProperties,'TOF_width') || obj.OProperties.TOF_bins == 0
                obj.OProperties.TOF_width = 0;
            end
            
            obj.TOF = obj.OProperties.TOF_bins > 1;
            
            [gaussK, obj.OProperties] = PSFKernel(obj.OProperties);
            obj.OProperties.gaussK = gaussK;
            if obj.OProperties.implementation == 1
                obj.sens = 0;
            elseif obj.OProperties.implementation == 4
                obj.sens = zeros(obj.OProperties.Nx*obj.OProperties.Ny*obj.OProperties.Nz,obj.OProperties.subsets);
            else
                obj.sens = zeros(obj.OProperties.Nx*obj.OProperties.Ny*obj.OProperties.Nz,obj.OProperties.subsets,'single');
            end
            
            
            pseudot = uint32(obj.OProperties.pseudot);
            temp = pseudot;
            if ~isempty(temp) && temp > 0
                for kk = int32(1) : temp
                    pseudot(kk) = int32(obj.OProperties.cryst_per_block + 1) * kk;
                end
            elseif temp == 0
                pseudot = [];
            end
            FOVax = obj.OProperties.FOVa_x;
            FOVay = obj.OProperties.FOVa_y;
            FOVax = double(FOVax);
            FOVay = double(FOVay);
            axial_fov = double(obj.OProperties.axial_fov);
            rings = obj.OProperties.rings;
            blocks = uint32(rings + length(pseudot) - 1);
            % block1 = uint32(0);
            if (~isfield(obj.OProperties,'x') && ~isfield(obj.OProperties,'y') && (~isfield(obj.OProperties,'z') || ~isfield(obj.OProperties,'z_det')))
                if obj.OProperties.flip_image
                    obj.OProperties.angles = -obj.OProperties.angles;
                end
                if obj.OProperties.offangle > 0
                    obj.OProperties.angles = obj.OProperties.angles + obj.OProperties.offangle;
                end
                [x,y,z_det] = CTDetectorCoordinates(obj.OProperties.angles(1:obj.OProperties.nProjections/obj.OProperties.nBed),obj.OProperties.sourceToDetector,...
                    obj.OProperties.sourceToCRot,obj.OProperties.dPitch,obj.OProperties.xSize,obj.OProperties.ySize,obj.OProperties.horizontalOffset,...
                    obj.OProperties.verticalOffset,obj.OProperties.bedOffset);
            end
            if exist('x','var')
                obj.OProperties.x = x;
                if obj.OProperties.listmode
                    clear x
                end
            end
            if exist('y','var')
                obj.OProperties.y = y;
                if obj.OProperties.listmode
                    clear y
                end
            end
            if isfield(obj.OProperties,'z')
                obj.OProperties.z_det = obj.OProperties.z;
                obj.OProperties = rmfield(obj.OProperties,'z');
            end
            if exist('z_det','var')
                obj.OProperties.z_det = z_det;
                if obj.OProperties.listmode
                    clear z_det
                end
            end
            if numel(obj.OProperties.z_det)/2 > numel(obj.OProperties.angles)
                if size(obj.OProperties.angles,1) == 1
                    obj.OProperties.angles = reshape(obj.OProperties.angles, [],1);
                end
                obj.OProperties.angles = repmat(obj.OProperties.angles,numel(obj.OProperties.z_det)/2/numel(obj.OProperties.angles),1);
            end
            
            if obj.OProperties.implementation == 2 || obj.OProperties.implementation == 3 || obj.OProperties.implementation == 5
                obj.OProperties.x = single(obj.OProperties.x);
                obj.OProperties.y = single(obj.OProperties.y);
                obj.OProperties.z_det = single(obj.OProperties.z_det);
            else
                obj.OProperties.x = double(obj.OProperties.x);
                obj.OProperties.y = double(obj.OProperties.y);
                obj.OProperties.z_det = double(obj.OProperties.z_det);
            end
            if obj.OProperties.listmode
                obj.OProperties.x = reshape(obj.OProperties.x, numel(obj.OProperties.x)/2,2);
                obj.OProperties.y = reshape(obj.OProperties.y, numel(obj.OProperties.y)/2,2);
                obj.OProperties.z_det = reshape(obj.OProperties.z_det, numel(obj.OProperties.z_det)/2,2);
            end
            
            size_x = uint32(obj.OProperties.ySize);
            obj.OProperties.size_y = uint32(obj.OProperties.xSize);
            if obj.OProperties.listmode
                size_x = size_x * uint32(obj.OProperties.xSize * obj.OProperties.nProjections);
            end
            if obj.OProperties.implementation == 2 || obj.OProperties.implementation == 3
                obj.OProperties.angles = single(obj.OProperties.angles);
                obj.OProperties.dPitch = single(obj.OProperties.dPitch);
            end
            
            if ~obj.OProperties.listmode
                [obj.OProperties, obj.OProperties.lor_a, obj.OProperties.xy_index, obj.OProperties.z_index, obj.OProperties.LL, obj.OProperties.summa, obj.n_meas,~,obj.OProperties.lor_orth,discard] = ...
                    form_subset_indices(obj.OProperties, obj.n_meas, obj.OProperties.subsets, obj.index, size_x, y, z_det, blocks, false, obj.TOF, [], obj.OProperties.lor_a, obj.OProperties.lor_orth, storeMatrix);
            else
                obj.OProperties.LL = uint16(0);
                obj.OProperties.xy_index = uint32(0);
                obj.OProperties.z_index = uint16(0);
                obj.OProperties.summa = zeros(obj.OProperties.subsets, 1, 'uint64');
            end
            if ~obj.OProperties.precompute_lor
                obj.OProperties.lor_a = uint16(0);
            end
            if obj.OProperties.subsets == 1
                obj.nn = [int64(0);int64(sum(obj.n_meas))];
                if obj.OProperties.precompute_lor && ~obj.OProperties.listmode
                    obj.index = find(discard);
                end
            end
            
            R = 0;
            if ~obj.OProperties.simple
                Z = obj.OProperties.dPitch * double(obj.OProperties.xSize) + obj.OProperties.z_det(obj.OProperties.nProjections);
            else
                Z = max(obj.OProperties.z_det(:)) + min(obj.OProperties.z_det(:));
                if Z == obj.OProperties.axial_fov && min(obj.OProperties.z_det(:)) > 0
                    Z = Z + min(obj.OProperties.z_det(:)) + max(obj.OProperties.z_det(:));
                end
                obj.OProperties.Z = Z;
            end
            
            [obj.OProperties.xx,obj.OProperties.yy,obj.OProperties.zz,obj.OProperties.dx,obj.OProperties.dy,obj.OProperties.dz,obj.OProperties.bx,obj.OProperties.by,...
                obj.OProperties.bz] = computePixelSize(R, FOVax, FOVay, Z, axial_fov, obj.OProperties.Nx, obj.OProperties.Ny, obj.OProperties.Nz, obj.OProperties.implementation);
            
            [obj.OProperties.x_center,obj.OProperties.y_center,obj.OProperties.z_center,obj.OProperties.dec] = computePixelCenters(obj.OProperties.xx,...
                obj.OProperties.yy,obj.OProperties.zz,obj.OProperties.dx,obj.OProperties.dy,obj.OProperties.dz,obj.TOF,obj.OProperties);
            
            [obj.OProperties.V,obj.OProperties.Vmax,obj.OProperties.bmin,obj.OProperties.bmax] = computeVoxelVolumes(obj.OProperties.dx,obj.OProperties.dy,...
                obj.OProperties.dz,obj.OProperties);
            
            % Multi-ray Siddon
%             if (obj.OProperties.implementation > 1 && obj.OProperties.n_rays_transaxial > 1 && ~obj.OProperties.precompute_lor && obj.OProperties.projector_type == 1) && ~obj.OProperties.listmode
%                 [obj.OProperties.x,obj.OProperties.y] = getMultirayCoordinates(obj.OProperties);
%             end
            obj.trans = false;
        end
        
        function y = forwardProject(obj, input, varargin)
            %FORWARDPROJECT Computes the forward projection between the
            %object and the input vector.
            %   Output is stored in the y-vector. PSF blurring is performed
            %   if it has been selected.
            % Inputs:
            %   obj = The forwardBackwardProject object created by
            %   forwardBackwardProject
            %   input = The input vector, i.e. this computes A * input
            %   subset_number = Current subset, used to select the correct
            %   LORs. Applicable only when using subsets, omit otherwise.
            % Outputs:
            %   y = The result of y = A * input
            
            if nargin >=3 && ~isempty(varargin{1})
                obj.subset = varargin{1};
                obj.OProperties.useSubsets = true;
            elseif obj.OProperties.subsets > 1 && nargin == 2
                obj.OProperties.useSubsets = true;
%                 error('When using subsets you must specify the current subset number (e.g. y = forwardProject(A, input, subset_number))')
            else
                obj.OProperties.useSubsets = false;
                obj.subset = 1;
            end
            
            if obj.OProperties.use_psf
                input = computeConvolution(input, obj.OProperties, obj.OProperties.Nx, obj.OProperties.Ny, obj.OProperties.Nz, obj.OProperties.gaussK);
            end
            if obj.OProperties.useSubsets || (obj.OProperties.precompute_lor == false && obj.OProperties.implementation == 1)
                indeksi = obj.index(obj.nn(obj.subset) + 1:obj.nn(obj.subset+1));
            else
                indeksi = 0;
            end
            y = forward_project(obj.OProperties, indeksi, obj.nn(obj.subset + 1) - obj.nn(obj.subset), input, [obj.nn(obj.subset) + 1 , obj.nn(obj.subset+1)], ...
                obj.subset, true);
        end
        
        
        function [f, varargout] = backwardProject(obj, input, varargin)
            %BACKWARDPROJECT Computes the backprojection between the object
            %and the input vector. Can also (optionally) compute the
            %sensitivity image.
            %   Output is stored in the f-vector. PSF blurring is performed
            %   if it has been selected.
            % Inputs:
            %   obj = The forwardBackwardProject object created by
            %   forwardBackwardProject
            %   input = The input vector, i.e. this computes A' * input
            %   subset_number = Current subset, used to select the correct
            %   LORs. Applicable only when using subsets, omit otherwise.
            % Outputs:
            %   f = The result of f = A' * input
            %   obj = The modified object. Sensitivity image is stored in
            %   sens. Can be omitted if sensitivity image is not required.
            
            if nargin >=3 && ~isempty(varargin{1})
                obj.subset = varargin{1};
                obj.OProperties.useSubsets = true;
            elseif obj.OProperties.subsets == 1 || isempty(obj.OProperties.subsets)
                obj.subset = 1;
                obj.OProperties.useSubsets = false;
            elseif obj.OProperties.subsets > 1
                obj.OProperties.useSubsets = true;
            end
            if nargout >= 2
                iter = 1;
            else
                iter = 10;
            end
            if obj.OProperties.useSubsets || (obj.OProperties.precompute_lor == false && obj.OProperties.implementation == 1)
                indeksi = obj.index(obj.nn(obj.subset) + 1:obj.nn(obj.subset+1));
            else
                indeksi = 0;
            end
            if iter == 1
                [f, norm] = backproject(obj.OProperties, indeksi, obj.nn(obj.subset + 1) - obj.nn(obj.subset), input, ...
                    [obj.nn(obj.subset) + 1,obj.nn(obj.subset+1)], obj.subset, true);
                
                if obj.OProperties.useSubsets
                    obj.sens(:,obj.subset) = norm;
                else
                    obj.sens = norm;
                end
                if obj.OProperties.use_psf
                    obj.sens(:,obj.subset) = computeConvolution(obj.sens(:,obj.subset), obj.OProperties, obj.OProperties.Nx, obj.OProperties.Ny, obj.OProperties.Nz, obj.OProperties.gaussK);
                end
            else
                f = backproject(obj.OProperties, indeksi, obj.nn(obj.subset + 1) - obj.nn(obj.subset), input, ...
                    [obj.nn(obj.subset) + 1,obj.nn(obj.subset+1)], obj.subset, true);
            end
            if obj.OProperties.use_psf
                f = computeConvolution(f, obj.OProperties, obj.OProperties.Nx, obj.OProperties.Ny, obj.OProperties.Nz, obj.OProperties.gaussK);
            end
            if nargout >= 2
                varargout{1} = obj;
            end
        end
        function f = mtimes(obj, input)
            %MTIMES Automatically compute either the forward projection or
            %backprojection, based on the input vector length.
            %   Backprojection is selected if transpose operator is used.
            if obj.OProperties.subsets > 1
                subs = obj.n_meas_subs(obj.subset);
            else
                subs = obj.n_meas(end);
            end
            if obj.trans == true || size(input,1) == subs || size(input,2) == subs || size(input,1) == subs * obj.OProperties.TOF_bins || size(input,2) == subs * obj.OProperties.TOF_bins
                if size(input,2) == subs
                    input = input';
                end
                f = backwardProject(obj, input);
            elseif size(input,1) == obj.OProperties.Nx*obj.OProperties.Ny*obj.OProperties.Nz || size(input,2) == obj.OProperties.Nx*obj.OProperties.Ny*obj.OProperties.Nz  || obj.trans == false
                if size(input,2) == obj.OProperties.Nx*obj.OProperties.Ny*obj.OProperties.Nz
                    input = input';
                end
                f = forwardProject(obj, input);
            end
        end
        function A = formMatrix(obj, varargin)
            %FORMMATRIX Forms the PET system matrix for the current subset
            %or, if no subsets are used, the entire matrix
            %   Corrections are applied to the matrix if they were
            %   selected. Always uses implementation 1 regardless of
            %   choice.
            % Inputs:
            %   obj = The forwardBackwardProject object created by
            %   forwardBackwardProject
            %   subset_number = Current subset, used to select the correct
            %   LORs. Applicable only when using subsets, omit otherwise.
            % Output:
            %   A = The system matrix for the current subset or the entire
            %   system matrix if subsets are set to 1 or omitted.
            if obj.OProperties.implementation ~= 1
                error('Implementation not set to 1. Rerun the class constructor with implementation set to 1.')
            end
            if nargin >= 2 && ~isempty(varargin{1})
                obj.subset = varargin{1};
            elseif obj.OProperties.subsets > 1 && nargin == 1
                error('When using subsets you must specify the current subset number (e.g. sysMat = formMatrix(A, subset_number))')
            end
            if obj.OProperties.subsets > 1 || (obj.OProperties.precompute_lor == false && obj.OProperties.implementation == 1)
                indeksi = obj.index(obj.nn(obj.subset) + 1:obj.nn(obj.subset+1));
            else
                indeksi = 0;
            end
            A = forward_project(obj.OProperties, indeksi, obj.nn(obj.subset + 1) - obj.nn(obj.subset), [], [obj.nn(obj.subset) + 1 , obj.nn(obj.subset+1)], ...
                obj.subset, true, true);
        end
        function obj = transpose(obj)
            obj.trans = true;
        end
        function obj = ctranspose(obj)
            obj.trans = true;
        end
    end
end

